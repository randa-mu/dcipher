//! A behaviour used to keep track of connected peers and periodically inform the swarm to
//! dial disconnected peers.

use crate::transports::libp2p::PeerDetail;
use libp2p::core::transport::PortUse;
use libp2p::core::Endpoint;
use libp2p::swarm::behaviour::{ConnectionClosed, ConnectionEstablished, DialFailure};
use libp2p::swarm::dial_opts::{DialOpts, PeerCondition};
use libp2p::swarm::{
    dummy, ConnectionDenied, ConnectionId, FromSwarm, NetworkBehaviour, THandler,
    THandlerInEvent, THandlerOutEvent, ToSwarm,
};
use libp2p::{Multiaddr, PeerId};
use std::collections::HashMap;
use std::task::{Context, Poll};
use std::time::{Duration, SystemTime};

#[derive(Clone, Debug)]
enum PeerStatus {
    Connected {
        last_seen: SystemTime,
        num_connections: usize,
    },
    Disconnected {
        #[allow(unused)] // only used in debug logs
        last_seen: SystemTime,
    },
    FailedToDial,
    Unknown,
}

impl PeerStatus {
    fn is_connected(&self) -> bool {
        matches!(self, PeerStatus::Connected { .. })
    }
}

#[derive(Clone, Debug)]
struct CurrentPeerStatus {
    detail: PeerDetail,
    status: PeerStatus,
}

/// Behaviour generating events indicating which peers should be re-dialed.
/// By itself, this behaviour does not do anything but track peers. However, it periodically
/// emits a list of peers through the [`PeriodicDialEvent::MultiDial`] event. The user should
/// use the provided [`Vec<DialOpts>`] to dial peers.
#[derive(Debug)]
pub struct PeriodicDialBehaviour {
    peers: HashMap<PeerId, CurrentPeerStatus>,
    dial_interval: tokio::time::Interval,
}

/// Events generated by the [`PeriodicDialBehaviour`].
#[derive(Debug)]
pub enum PeriodicDialEvent {
    MultiDial(Vec<DialOpts>),
}
impl PeriodicDialBehaviour {
    pub fn new(dial_interval: Duration, peers: impl IntoIterator<Item = PeerDetail>) -> Self {
        let peers = HashMap::from_iter(peers.into_iter().map(|detail| {
            (
                detail.peer_id,
                CurrentPeerStatus {
                    detail,
                    status: PeerStatus::Unknown,
                },
            )
        }));

        Self {
            peers,
            dial_interval: tokio::time::interval(dial_interval),
        }
    }
}

impl PeriodicDialBehaviour {
    fn handle_swarm_event(&mut self, event: FromSwarm) {
        match event {
            // The swarm has established a new connection with a peer.
            FromSwarm::ConnectionEstablished(ConnectionEstablished {
                peer_id,
                other_established,
                ..
            }) => {
                if let Some(peer) = self.peers.get_mut(&peer_id) {
                    peer.status = PeerStatus::Connected {
                        last_seen: SystemTime::now(),
                        num_connections: other_established + 1,
                    };
                }
            }

            // The swarm has closed / detected a closed connection to a peer.
            FromSwarm::ConnectionClosed(ConnectionClosed {
                peer_id,
                remaining_established,
                ..
            }) => {
                if let Some(peer) = self.peers.get_mut(&peer_id) {
                    if remaining_established != 0 {
                        // Peer still connected
                        if let PeerStatus::Connected {
                            num_connections, ..
                        } = &mut peer.status
                        {
                            *num_connections = remaining_established;
                        } else {
                            tracing::warn!(peer_id = %peer_id, short_id = peer.detail.short_id, "ConnectionClosed on peer that is not marked as connected");
                        }
                    } else {
                        // Peer is now disconnected

                        // ConnectionClosed => the peer should have been connected
                        let last_seen = if let PeerStatus::Connected { last_seen, .. } =
                            &peer.status
                        {
                            *last_seen
                        } else {
                            tracing::warn!(peer_id = %peer_id, short_id = peer.detail.short_id, "ConnectionClosed on peer that is not marked as connected");
                            SystemTime::now()
                        };

                        peer.status = PeerStatus::Disconnected { last_seen };
                    }
                }
            }

            // Failed to dial a specific peer.
            FromSwarm::DialFailure(DialFailure { peer_id, error, .. }) => {
                if let Some((peer_id, peer)) =
                    peer_id.and_then(|id| self.peers.get_mut(&id).map(|info| (id, info)))
                {
                    peer.status = PeerStatus::FailedToDial;
                    tracing::warn!(?error, peer_id = %peer_id, short_id = peer.detail.short_id, "Failed to dial peer");
                } else {
                    tracing::warn!(?error, "Failed to dial unknown peer");
                }
            }

            _ => {}
        }
    }
}

impl NetworkBehaviour for PeriodicDialBehaviour {
    type ConnectionHandler = dummy::ConnectionHandler;

    type ToSwarm = PeriodicDialEvent;

    fn handle_established_inbound_connection(
        &mut self,
        _connection_id: ConnectionId,
        _peer: PeerId,
        _local_addr: &Multiaddr,
        _remote_addr: &Multiaddr,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        Ok(dummy::ConnectionHandler)
    }

    fn handle_established_outbound_connection(
        &mut self,
        _connection_id: ConnectionId,
        _peer: PeerId,
        _addr: &Multiaddr,
        _role_override: Endpoint,
        _port_use: PortUse,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        Ok(dummy::ConnectionHandler)
    }

    fn on_swarm_event(&mut self, event: FromSwarm) {
        self.handle_swarm_event(event);
    }

    fn on_connection_handler_event(
        &mut self,
        _peer_id: PeerId,
        _connection_id: ConnectionId,
        _event: THandlerOutEvent<Self>,
    ) {
        unreachable!("dummy ConnectionHandler should never have an established connection");
    }

    fn poll(
        &mut self,
        cx: &mut Context<'_>,
    ) -> Poll<ToSwarm<Self::ToSwarm, THandlerInEvent<Self>>> {
        if let Poll::Ready(_elapsed) = self.dial_interval.poll_tick(cx) {
            // Log the current status of peers
            tracing::debug!(peers = ?self.peers.values(), "Peer status");

            // Every time the interval is resolved,
            let dial_opts: Vec<_> = self
                .peers
                .iter()
                // filter only disconnected peers
                .filter(|&(_, peer)| !peer.status.is_connected())
                // create DialOpts
                .map(|(peer_id, peer)| {
                    DialOpts::peer_id(*peer_id)
                        .condition(PeerCondition::Always)
                        .addresses(peer.detail.multiaddrs.clone())
                        .build()
                })
                .collect();

            if !dial_opts.is_empty() {
                return Poll::Ready(ToSwarm::GenerateEvent(PeriodicDialEvent::MultiDial(
                    dial_opts,
                )));
            }
        }

        Poll::Pending
    }
}
