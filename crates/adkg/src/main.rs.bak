pub(crate) mod aba;
mod adkg;
pub(crate) mod helpers;
/// Allow unused since we have yet to interface with those modules.
/// TODO: Remove allow unused
#[allow(unused)]
pub(crate) mod network;
pub(crate) mod nizk;
pub mod pke;
#[allow(unused)]
pub(crate) mod rbc;
pub mod vss;

use crate::adkg::socket::SocketNetworkInstance;
use crate::adkg::Adkg;
use crate::helpers::PartyId;
use crate::rbc::r4::Rbc4Rounds;
use ark_bn254::Bn254;
use ark_ec::pairing::Pairing;
use ark_ec::{CurveGroup, Group};
use ark_std::UniformRand;
use clap::{Parser, Subcommand};
use itertools::Itertools;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::sync::Arc;

/// CLI for key generation and distributed key generation.
#[derive(Parser)]
#[command(name = "Keygen CLI")]
#[command(about = "CLI for key generation and distributed key generation.")]
struct Cli {
    /// Subcommand for key generation or distributed key generation
    #[command(subcommand)]
    command: Commands,
}

/// Subcommands available in the CLI
#[derive(Subcommand)]
enum Commands {
    /// Generate long-term keys for a party
    #[command(about = "Generate long-term keys for a given party")]
    Generate {
        /// The unique party identifier
        #[arg(
            long,
            help = "The unique identifier for the party for which the keys will be generated"
        )]
        id: usize,
    },

    /// Start distributed key generation
    #[command(about = "Start distributed key generation with a set of parties")]
    Adkg {
        /// The unique party identifier for distributed key generation
        #[arg(
            long,
            help = "The unique identifier for the party participating in the distributed key generation"
        )]
        id: usize,

        /// Path to the JSON file containing party information
        #[arg(long, help = "Path to the JSON file containing the ADKG configuration")]
        config: String,
    },
}

type G = <Bn254 as Pairing>::G1;
type ScalarField = <Bn254 as Pairing>::ScalarField;

#[derive(Clone, Serialize, Deserialize)]
struct KeyMaterial {
    id: usize,
    #[serde(with = "utils::serialize::fq::base64")]
    sk: ScalarField,
    #[serde(with = "utils::serialize::point::base64")]
    pk: G,
}

#[derive(Clone, Serialize, Deserialize)]
struct AdkgConfig {
    n: usize,
    t: usize,
    parties: Vec<PartyDetail>,
}

#[derive(Clone, Serialize, Deserialize)]
struct PartyDetail {
    id: usize,
    socket: String,
    #[serde(with = "utils::serialize::point::base64")]
    pk: G,
}

#[tokio::main(worker_threads = 4)]
async fn main() {
    console_subscriber::init();
    // construct a subscriber that prints formatted traces to stdout
    // let subscriber = tracing_subscriber::fmt()
    //     // Use a more compact, abbreviated log format
    //     .compact()
    //     // Display source code file paths
    //     .with_file(true)
    //     // Display source code line numbers
    //     .with_line_number(true)
    //     // Display the thread ID an event was recorded on
    //     .with_thread_ids(true)
    //     // Don't display the event's target (module path)
    //     .with_target(false)
    //     .with_max_level(tracing::Level::WARN)
    //     // Build the subscriber
    //     .finish();
    // // use that subscriber to process traces emitted after this point
    // tracing::subscriber::set_global_default(subscriber).unwrap();

    // Parse the CLI arguments into the Cli struct
    let args = Cli::parse();

    match args.command {
        Commands::Generate { id } => {
            println!("Generating long-term key for party: {}", id);
            let sk = ScalarField::rand(&mut rand::thread_rng());
            let pk = G::generator() * sk;

            let key = KeyMaterial { id, sk, pk };
            let key_m = serde_json::to_string(&key).unwrap();
            std::fs::write(format!("key_{id}.json"), key_m).unwrap();
            println!("Long-term key for party: {id} saved to key_{id}.json");
        }
        Commands::Adkg { id, config } => {
            // TODO: Load the list of parties from the parties_file
            // TODO: Perform distributed key generation for the given party_id

            // println!("Starting distributed key generation for party: {}", id);
            // println!("Config file: {}", config);
            let config_m = std::fs::read_to_string(config).unwrap();
            let config: AdkgConfig = serde_json::from_str(&config_m).unwrap();

            let key_m = std::fs::read_to_string(format!("key_{id}.json")).unwrap();
            let key: KeyMaterial = serde_json::from_str(&key_m).unwrap();

            let network = SocketNetworkInstance::new(PathBuf::from("/tmp"), PartyId(id), config.n);
            let transport = network.get_topic_transport();

            let adkg = Adkg::<G, Rbc4Rounds, Rbc4Rounds, _>::new(
                config.n,
                config.t,
                PartyId(id),
                key.sk,
                key.pk,
                config
                    .parties
                    .iter()
                    .sorted_by(|p1, p2| p1.id.cmp(&p2.id))
                    .map(|p| p.pk)
                    .collect(),
            );

            tokio::spawn(async move { network.start().await });

            let mut buffer = String::new();
            println!("Press enter to start the adkg");

            std::io::stdin()
                .read_line(&mut buffer)
                .expect("Failed to read line");

            let (id, z_i, h_z) = adkg.start(transport).await;
            println!("Node `{id}` got share {z_i}");
            println!("Node `{id}` got public key {h_z}\n");
            tokio::time::sleep(std::time::Duration::from_secs(1000)).await;
        }
    }
}
