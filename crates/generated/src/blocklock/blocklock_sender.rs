///Module containing a contract's types and functions.
/**

```solidity
library BLS {
    struct PointG2 { uint256[2] x; uint256[2] y; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod BLS {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct PointG2 { uint256[2] x; uint256[2] y; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PointG2 {
        #[allow(missing_docs)]
        pub x: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        #[allow(missing_docs)]
        pub y: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::Uint<256>,
                2usize,
            >,
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::Uint<256>,
                2usize,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PointG2> for UnderlyingRustTuple<'_> {
            fn from(value: PointG2) -> Self {
                (value.x, value.y)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PointG2 {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { x: tuple.0, y: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PointG2 {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PointG2 {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.x),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.y),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PointG2 {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PointG2 {
            const NAME: &'static str = "PointG2";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PointG2(uint256[2] x,uint256[2] y)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.x)
                        .0,
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.y)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PointG2 {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.x)
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.y)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.x, out);
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.y, out);
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`BLS`](self) contract instance.

See the [wrapper's documentation](`BLSInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(address: alloy_sol_types::private::Address, provider: P) -> BLSInstance<P, N> {
        BLSInstance::<P, N>::new(address, provider)
    }
    /**A [`BLS`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`BLS`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct BLSInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for BLSInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("BLSInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BLSInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`BLS`](self) contract instance.

See the [wrapper's documentation](`BLSInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> BLSInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> BLSInstance<P, N> {
            BLSInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BLSInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BLSInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
///Module containing a contract's types and functions.
/**

```solidity
library TypesLib {
    struct BlocklockRequest { uint256 subId; uint256 directFundingFeePaid; uint32 callbackGasLimit; uint256 decryptionRequestId; bytes condition; Ciphertext ciphertext; bytes signature; bytes decryptionKey; address callback; }
    struct Ciphertext { BLS.PointG2 u; bytes v; bytes w; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TypesLib {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct BlocklockRequest { uint256 subId; uint256 directFundingFeePaid; uint32 callbackGasLimit; uint256 decryptionRequestId; bytes condition; Ciphertext ciphertext; bytes signature; bytes decryptionKey; address callback; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlocklockRequest {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub directFundingFeePaid: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub callbackGasLimit: u32,
        #[allow(missing_docs)]
        pub decryptionRequestId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub condition: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub ciphertext: <Ciphertext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub decryptionKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub callback: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
            Ciphertext,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            u32,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
            <Ciphertext as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlocklockRequest> for UnderlyingRustTuple<'_> {
            fn from(value: BlocklockRequest) -> Self {
                (
                    value.subId,
                    value.directFundingFeePaid,
                    value.callbackGasLimit,
                    value.decryptionRequestId,
                    value.condition,
                    value.ciphertext,
                    value.signature,
                    value.decryptionKey,
                    value.callback,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlocklockRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    subId: tuple.0,
                    directFundingFeePaid: tuple.1,
                    callbackGasLimit: tuple.2,
                    decryptionRequestId: tuple.3,
                    condition: tuple.4,
                    ciphertext: tuple.5,
                    signature: tuple.6,
                    decryptionKey: tuple.7,
                    callback: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BlocklockRequest {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BlocklockRequest {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.directFundingFeePaid),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.callbackGasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.decryptionRequestId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.condition,
                    ),
                    <Ciphertext as alloy_sol_types::SolType>::tokenize(&self.ciphertext),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionKey,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callback,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BlocklockRequest {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BlocklockRequest {
            const NAME: &'static str = "BlocklockRequest";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BlocklockRequest(uint256 subId,uint256 directFundingFeePaid,uint32 callbackGasLimit,uint256 decryptionRequestId,bytes condition,Ciphertext ciphertext,bytes signature,bytes decryptionKey,address callback)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <Ciphertext as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <Ciphertext as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.subId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.directFundingFeePaid,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.callbackGasLimit,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.decryptionRequestId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.condition,
                        )
                        .0,
                    <Ciphertext as alloy_sol_types::SolType>::eip712_data_word(
                            &self.ciphertext,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.decryptionKey,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.callback,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BlocklockRequest {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.subId)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.directFundingFeePaid,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.callbackGasLimit,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.decryptionRequestId,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.condition,
                    )
                    + <Ciphertext as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.ciphertext,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.decryptionKey,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.callback,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.subId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.directFundingFeePaid,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.callbackGasLimit,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.decryptionRequestId,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.condition,
                    out,
                );
                <Ciphertext as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.ciphertext,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.decryptionKey,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.callback,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Ciphertext { BLS.PointG2 u; bytes v; bytes w; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Ciphertext {
        #[allow(missing_docs)]
        pub u: <BLS::PointG2 as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub v: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub w: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            BLS::PointG2,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <BLS::PointG2 as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Ciphertext> for UnderlyingRustTuple<'_> {
            fn from(value: Ciphertext) -> Self {
                (value.u, value.v, value.w)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Ciphertext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    u: tuple.0,
                    v: tuple.1,
                    w: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Ciphertext {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Ciphertext {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <BLS::PointG2 as alloy_sol_types::SolType>::tokenize(&self.u),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.v,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.w,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Ciphertext {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Ciphertext {
            const NAME: &'static str = "Ciphertext";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Ciphertext(PointG2 u,bytes v,bytes w)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BLS::PointG2 as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BLS::PointG2 as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <BLS::PointG2 as alloy_sol_types::SolType>::eip712_data_word(&self.u)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.v,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.w,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Ciphertext {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <BLS::PointG2 as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.u,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.v,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.w,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <BLS::PointG2 as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.u,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.v,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.w,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TypesLib`](self) contract instance.

See the [wrapper's documentation](`TypesLibInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TypesLibInstance<P, N> {
        TypesLibInstance::<P, N>::new(address, provider)
    }
    /**A [`TypesLib`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TypesLib`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TypesLibInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for TypesLibInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TypesLibInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TypesLibInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`TypesLib`](self) contract instance.

See the [wrapper's documentation](`TypesLibInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> TypesLibInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TypesLibInstance<P, N> {
            TypesLibInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TypesLibInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TypesLibInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library BLS {
    struct PointG2 {
        uint256[2] x;
        uint256[2] y;
    }
}

library TypesLib {
    struct BlocklockRequest {
        uint256 subId;
        uint256 directFundingFeePaid;
        uint32 callbackGasLimit;
        uint256 decryptionRequestId;
        bytes condition;
        Ciphertext ciphertext;
        bytes signature;
        bytes decryptionKey;
        address callback;
    }
    struct Ciphertext {
        BLS.PointG2 u;
        bytes v;
        bytes w;
    }
}

interface BlocklockSender {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AddressEmptyCode(address target);
    error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance);
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error FailedCall();
    error FailedToSendNative();
    error IndexOutOfRange();
    error InsufficientBalance();
    error InvalidCalldata();
    error InvalidConsumer(uint256 subId, address consumer);
    error InvalidDSTLength(bytes dst);
    error InvalidInitialization();
    error InvalidSubscription();
    error MustBeRequestedOwner(address proposedOwner);
    error MustBeSubOwner(address owner);
    error NotInitializing();
    error PendingRequestExists();
    error ReentrancyGuardReentrantCall();
    error TooManyConsumers();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);

    event BlocklockCallbackFailed(uint256 indexed requestId);
    event BlocklockCallbackSuccess(uint256 indexed requestId, bytes condition, TypesLib.Ciphertext ciphertext, bytes decryptionKey);
    event BlocklockRequested(uint256 indexed requestId, bytes condition, TypesLib.Ciphertext ciphertext, address indexed requester, uint256 requestedAt);
    event ConfigSet(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation, uint32 fulfillmentFlatFeeNativePPM, uint32 weiPerUnitGas, uint32 blsPairingCheckOverhead, uint8 nativePremiumPercentage, uint32 gasForCallExactCheck);
    event DecryptionSenderUpdated(address indexed decryptionSender);
    event Disabled();
    event Enabled();
    event Initialized(uint64 version);
    event L1GasFee(uint256 fee);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event SubscriptionCanceled(uint256 indexed subId, address to, uint256 amountNative);
    event SubscriptionConsumerAdded(uint256 indexed subId, address consumer);
    event SubscriptionConsumerRemoved(uint256 indexed subId, address consumer);
    event SubscriptionCreated(uint256 indexed subId, address owner);
    event SubscriptionFundedWithNative(uint256 indexed subId, uint256 oldNativeBalance, uint256 newNativeBalance);
    event SubscriptionOwnerTransferRequested(uint256 indexed subId, address from, address to);
    event SubscriptionOwnerTransferred(uint256 indexed subId, address from, address to);
    event Upgraded(address indexed implementation);

    constructor();

    function ADMIN_ROLE() external view returns (bytes32);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DST_H1_G1() external view returns (bytes memory);
    function DST_H2() external view returns (bytes memory);
    function DST_H3() external view returns (bytes memory);
    function DST_H4() external view returns (bytes memory);
    function MAX_CONSUMERS() external view returns (uint16);
    function SCHEME_ID() external view returns (string memory);
    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function acceptSubscriptionOwnerTransfer(uint256 subId) external;
    function addConsumer(uint256 subId, address consumer) external;
    function blocklockRequestsWithDecryptionKey(uint256) external view returns (uint256 subId, uint256 directFundingFeePaid, uint32 callbackGasLimit, uint256 decryptionRequestId, bytes memory condition, TypesLib.Ciphertext memory ciphertext, bytes memory signature, bytes memory decryptionKey, address callback);
    function calculateRequestPriceNative(uint32 _callbackGasLimit) external view returns (uint256);
    function cancelSubscription(uint256 subId, address to) external;
    function createSubscription() external returns (uint256 subId);
    function decrypt(TypesLib.Ciphertext memory ciphertext, bytes memory decryptionKey) external view returns (bytes memory);
    function decryptionSender() external view returns (address);
    function disable() external;
    function enable() external;
    function estimateRequestPriceNative(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);
    function fundSubscriptionWithNative(uint256 subId) external payable;
    function getActiveSubscriptionIds(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory ids);
    function getChainId() external view returns (uint256 chainId);
    function getConfig() external view returns (uint32 maxGasLimit, uint32 gasAfterPaymentCalculation, uint32 fulfillmentFlatFeeNativePPM, uint32 weiPerUnitGas, uint32 blsPairingCheckOverhead, uint8 nativePremiumPercentage, uint32 gasForCallExactCheck);
    function getRequest(uint256 requestId) external view returns (TypesLib.BlocklockRequest memory);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
    function getRoleMembers(bytes32 role) external view returns (address[] memory);
    function getSubscription(uint256 subId) external view returns (uint96 nativeBalance, uint64 reqCount, address subOwner, address[] memory consumers);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function initialize(address owner, address _decryptionSender) external;
    function isInFlight(uint256 requestId) external view returns (bool);
    function ownerCancelSubscription(uint256 subId) external;
    function pendingRequestExists(uint256 subId) external view returns (bool);
    function proxiableUUID() external view returns (bytes32);
    function receiveDecryptionData(uint256 requestId, bytes memory decryptionKey, bytes memory signature) external;
    function removeConsumer(uint256 subId, address consumer) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function requestBlocklock(uint32 callbackGasLimit, bytes memory condition, TypesLib.Ciphertext memory ciphertext) external payable returns (uint256);
    function requestBlocklockWithSubscription(uint32 callbackGasLimit, uint256 subId, bytes memory condition, TypesLib.Ciphertext memory ciphertext) external payable returns (uint256);
    function requestSubscriptionOwnerTransfer(uint256 subId, address newOwner) external;
    function revokeRole(bytes32 role, address account) external;
    function s_config() external view returns (uint32 maxGasLimit, uint32 gasAfterPaymentCalculation, uint32 fulfillmentFlatFeeNativePPM, uint32 weiPerUnitGas, uint32 blsPairingCheckOverhead, uint8 nativePremiumPercentage, uint32 gasForCallExactCheck);
    function s_configured() external view returns (bool);
    function s_currentSubNonce() external view returns (uint64);
    function s_disabled() external view returns (bool);
    function s_totalNativeBalance() external view returns (uint96);
    function s_withdrawableDirectFundingFeeNative() external view returns (uint96);
    function s_withdrawableSubscriptionFeeNative() external view returns (uint96);
    function setConfig(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation, uint32 fulfillmentFlatFeeNativePPM, uint32 weiPerUnitGas, uint32 blsPairingCheckOverhead, uint8 nativePremiumPercentage, uint32 gasForCallExactCheck) external;
    function setDecryptionSender(address newDecryptionSender) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function version() external pure returns (string memory);
    function withdrawDirectFundingFeesNative(address payable recipient) external;
    function withdrawSubscriptionFeesNative(address payable recipient) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DST_H1_G1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DST_H2",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DST_H3",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DST_H4",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MAX_CONSUMERS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SCHEME_ID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "acceptSubscriptionOwnerTransfer",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addConsumer",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "consumer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "blocklockRequestsWithDecryptionKey",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "directFundingFeePaid",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "callbackGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "decryptionRequestId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "condition",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "ciphertext",
        "type": "tuple",
        "internalType": "struct TypesLib.Ciphertext",
        "components": [
          {
            "name": "u",
            "type": "tuple",
            "internalType": "struct BLS.PointG2",
            "components": [
              {
                "name": "x",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              },
              {
                "name": "y",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              }
            ]
          },
          {
            "name": "v",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "w",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "decryptionKey",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "callback",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calculateRequestPriceNative",
    "inputs": [
      {
        "name": "_callbackGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "cancelSubscription",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createSubscription",
    "inputs": [],
    "outputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "decrypt",
    "inputs": [
      {
        "name": "ciphertext",
        "type": "tuple",
        "internalType": "struct TypesLib.Ciphertext",
        "components": [
          {
            "name": "u",
            "type": "tuple",
            "internalType": "struct BLS.PointG2",
            "components": [
              {
                "name": "x",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              },
              {
                "name": "y",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              }
            ]
          },
          {
            "name": "v",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "w",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "decryptionKey",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decryptionSender",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IDecryptionSender"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "disable",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enable",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "estimateRequestPriceNative",
    "inputs": [
      {
        "name": "_callbackGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_requestGasPriceWei",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "fundSubscriptionWithNative",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "getActiveSubscriptionIds",
    "inputs": [
      {
        "name": "startIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "ids",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getChainId",
    "inputs": [],
    "outputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getConfig",
    "inputs": [],
    "outputs": [
      {
        "name": "maxGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "gasAfterPaymentCalculation",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "fulfillmentFlatFeeNativePPM",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "weiPerUnitGas",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "blsPairingCheckOverhead",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "nativePremiumPercentage",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "gasForCallExactCheck",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRequest",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct TypesLib.BlocklockRequest",
        "components": [
          {
            "name": "subId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "directFundingFeePaid",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "callbackGasLimit",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "decryptionRequestId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "condition",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "ciphertext",
            "type": "tuple",
            "internalType": "struct TypesLib.Ciphertext",
            "components": [
              {
                "name": "u",
                "type": "tuple",
                "internalType": "struct BLS.PointG2",
                "components": [
                  {
                    "name": "x",
                    "type": "uint256[2]",
                    "internalType": "uint256[2]"
                  },
                  {
                    "name": "y",
                    "type": "uint256[2]",
                    "internalType": "uint256[2]"
                  }
                ]
              },
              {
                "name": "v",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "w",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          },
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "decryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "callback",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMember",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMemberCount",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMembers",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSubscription",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "nativeBalance",
        "type": "uint96",
        "internalType": "uint96"
      },
      {
        "name": "reqCount",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "subOwner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "consumers",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_decryptionSender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isInFlight",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ownerCancelSubscription",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pendingRequestExists",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "receiveDecryptionData",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decryptionKey",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeConsumer",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "consumer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "requestBlocklock",
    "inputs": [
      {
        "name": "callbackGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "condition",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "ciphertext",
        "type": "tuple",
        "internalType": "struct TypesLib.Ciphertext",
        "components": [
          {
            "name": "u",
            "type": "tuple",
            "internalType": "struct BLS.PointG2",
            "components": [
              {
                "name": "x",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              },
              {
                "name": "y",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              }
            ]
          },
          {
            "name": "v",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "w",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "requestBlocklockWithSubscription",
    "inputs": [
      {
        "name": "callbackGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "condition",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "ciphertext",
        "type": "tuple",
        "internalType": "struct TypesLib.Ciphertext",
        "components": [
          {
            "name": "u",
            "type": "tuple",
            "internalType": "struct BLS.PointG2",
            "components": [
              {
                "name": "x",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              },
              {
                "name": "y",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              }
            ]
          },
          {
            "name": "v",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "w",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "requestSubscriptionOwnerTransfer",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "s_config",
    "inputs": [],
    "outputs": [
      {
        "name": "maxGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "gasAfterPaymentCalculation",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "fulfillmentFlatFeeNativePPM",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "weiPerUnitGas",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "blsPairingCheckOverhead",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "nativePremiumPercentage",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "gasForCallExactCheck",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "s_configured",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "s_currentSubNonce",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "s_disabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "s_totalNativeBalance",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint96",
        "internalType": "uint96"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "s_withdrawableDirectFundingFeeNative",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint96",
        "internalType": "uint96"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "s_withdrawableSubscriptionFeeNative",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint96",
        "internalType": "uint96"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setConfig",
    "inputs": [
      {
        "name": "maxGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "gasAfterPaymentCalculation",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "fulfillmentFlatFeeNativePPM",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "weiPerUnitGas",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "blsPairingCheckOverhead",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "nativePremiumPercentage",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "gasForCallExactCheck",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setDecryptionSender",
    "inputs": [
      {
        "name": "newDecryptionSender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "version",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "withdrawDirectFundingFeesNative",
    "inputs": [
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address payable"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawSubscriptionFeesNative",
    "inputs": [
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address payable"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "BlocklockCallbackFailed",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlocklockCallbackSuccess",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "condition",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "ciphertext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct TypesLib.Ciphertext",
        "components": [
          {
            "name": "u",
            "type": "tuple",
            "internalType": "struct BLS.PointG2",
            "components": [
              {
                "name": "x",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              },
              {
                "name": "y",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              }
            ]
          },
          {
            "name": "v",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "w",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "decryptionKey",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlocklockRequested",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "condition",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "ciphertext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct TypesLib.Ciphertext",
        "components": [
          {
            "name": "u",
            "type": "tuple",
            "internalType": "struct BLS.PointG2",
            "components": [
              {
                "name": "x",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              },
              {
                "name": "y",
                "type": "uint256[2]",
                "internalType": "uint256[2]"
              }
            ]
          },
          {
            "name": "v",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "w",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "requester",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "requestedAt",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ConfigSet",
    "inputs": [
      {
        "name": "maxGasLimit",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "gasAfterPaymentCalculation",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "fulfillmentFlatFeeNativePPM",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "weiPerUnitGas",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "blsPairingCheckOverhead",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "nativePremiumPercentage",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      },
      {
        "name": "gasForCallExactCheck",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DecryptionSenderUpdated",
    "inputs": [
      {
        "name": "decryptionSender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Disabled",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Enabled",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "L1GasFee",
    "inputs": [
      {
        "name": "fee",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubscriptionCanceled",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amountNative",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubscriptionConsumerAdded",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "consumer",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubscriptionConsumerRemoved",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "consumer",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubscriptionCreated",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "owner",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubscriptionFundedWithNative",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "oldNativeBalance",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newNativeBalance",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubscriptionOwnerTransferRequested",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubscriptionOwnerTransferred",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "BalanceInvariantViolated",
    "inputs": [
      {
        "name": "internalBalance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "externalBalance",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedToSendNative",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IndexOutOfRange",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidCalldata",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidConsumer",
    "inputs": [
      {
        "name": "subId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "consumer",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidDSTLength",
    "inputs": [
      {
        "name": "dst",
        "type": "bytes",
        "internalType": "bytes"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSubscription",
    "inputs": []
  },
  {
    "type": "error",
    "name": "MustBeRequestedOwner",
    "inputs": [
      {
        "name": "proposedOwner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "MustBeSubOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PendingRequestExists",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TooManyConsumers",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod BlocklockSender {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a060405230608052348015610013575f5ffd5b5060015f55610020610025565b6100d7565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000900460ff16156100755760405163f92ee8a960e01b815260040160405180910390fd5b80546001600160401b03908116146100d45780546001600160401b0319166001600160401b0390811782556040519081527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b50565b608051615ab56100fd5f395f81816137250152818161374e015261389b0152615ab55ff3fe608060405260043610610371575f3560e01c80637350f456116101c8578063aa433aff116100fd578063c58343ef1161009d578063cd802c911161006d578063cd802c9114610b1a578063d547741f14610b39578063dac83d2914610b58578063dc311dd314610b77575f5ffd5b8063c58343ef14610a91578063c9bc18c414610abd578063ca15c87314610adc578063cb63179714610afb575f5ffd5b8063b2a7cac5116100d8578063b2a7cac5146109da578063bd18636b146109f9578063bec4c08c14610a18578063c3f909d414610a37575f5ffd5b8063aa433aff1461095f578063ad3cb1cc1461097e578063aefb212f146109ae575f5ffd5b8063995cb36e11610168578063a21a23e411610143578063a21a23e4146108ed578063a3246ad314610901578063a3907d711461092d578063a608a1e114610941575f5ffd5b8063995cb36e146108845780639d40a6fd146108a3578063a217fddf146108da575f5ffd5b80638a1f165a116101a35780638a1f165a146107f55780639010d07c1461083357806391d148541461085257806395b55cfc14610871575f5ffd5b80637350f456146107ae57806375b238fc146107c25780637909dc7b146107e2575f5ffd5b806338c27d12116102a957806352d1902d116102495780635d3be001116102195780635d3be001146107205780635f7bda9f1461073f57806364d51a2a1461077357806367b276af1461079a575f5ffd5b806352d1902d146106a757806354236fb3146106bb57806354fd4d50146106da57806357a8070a14610707575f5ffd5b806345fa43541161028457806345fa435414610637578063485cc955146106565780634b160935146106755780634f1ef28614610694575f5ffd5b806338c27d12146105de5780633bc32c75146105f257806341af6c8714610618575f5ffd5b8063235296f7116103145780632f2ff15d116102ef5780632f2ff15d1461056f5780633255c4561461058e5780633408e470146105ad57806336568abe146105bf575f5ffd5b8063235296f71461051b578063248a9ca31461053c5780632f2770db1461055b575f5ffd5b80630ae095401161034f5780630ae095401461046d578063133c40c71461048e57806318e3dd27146104c55780631e6ba15b146104fc575f5ffd5b806301ffc9a714610375578063062b1d90146103a9578063088070f5146103ca575b5f5ffd5b348015610380575f5ffd5b5061039461038f3660046149b0565b610ba6565b60405190151581526020015b60405180910390f35b6103bc6103b7366004614aca565b610bd0565b6040519081526020016103a0565b3480156103d5575f5ffd5b50600a546104269063ffffffff808216916401000000008104821691600160401b8204811691600160601b8104821691600160801b820481169160ff600160a01b82041691600160a81b9091041687565b6040805163ffffffff988916815296881660208801529487169486019490945291851660608501528416608084015260ff1660a083015290911660c082015260e0016103a0565b348015610478575f5ffd5b5061048c610487366004614b5a565b610f15565b005b348015610499575f5ffd5b506001546104ad906001600160a01b031681565b6040516001600160a01b0390911681526020016103a0565b3480156104d0575f5ffd5b506008546104e4906001600160601b031681565b6040516001600160601b0390911681526020016103a0565b348015610507575f5ffd5b5061048c610516366004614b88565b610f66565b348015610526575f5ffd5b5061052f610fc5565b6040516103a09190614bd1565b348015610547575f5ffd5b506103bc610556366004614be3565b611051565b348015610566575f5ffd5b5061048c611071565b34801561057a575f5ffd5b5061048c610589366004614b5a565b6110c0565b348015610599575f5ffd5b506103bc6105a8366004614bfa565b6110e2565b3480156105b8575f5ffd5b50466103bc565b3480156105ca575f5ffd5b5061048c6105d9366004614b5a565b6110fa565b3480156105e9575f5ffd5b5061052f61112d565b3480156105fd575f5ffd5b506008546104e490600160601b90046001600160601b031681565b348015610623575f5ffd5b50610394610632366004614be3565b61113a565b348015610642575f5ffd5b5061048c610651366004614c22565b6111cf565b348015610661575f5ffd5b5061048c610670366004614caa565b6113ac565b348015610680575f5ffd5b506103bc61068f366004614cd6565b61163f565b61048c6106a2366004614cef565b611650565b3480156106b2575f5ffd5b506103bc61166f565b3480156106c6575f5ffd5b5061048c6106d5366004614b88565b61168b565b3480156106e5575f5ffd5b50604080518082019091526005815264302e302e3160d81b602082015261052f565b348015610712575f5ffd5b50600b546103949060ff1681565b34801561072b575f5ffd5b5061048c61073a366004614d78565b6116ff565b34801561074a575f5ffd5b5061075e610759366004614be3565b6117d2565b6040516103a099989796959493929190614e63565b34801561077e575f5ffd5b50610787606481565b60405161ffff90911681526020016103a0565b3480156107a5575f5ffd5b5061052f611b58565b3480156107b9575f5ffd5b5061052f611b65565b3480156107cd575f5ffd5b506103bc5f516020615a955f395f51905f5281565b6103bc6107f0366004614eef565b611b72565b348015610800575f5ffd5b5061052f60405180604001604052806013815260200172424e3235342d424c532d424c4f434b4c4f434b60681b81525081565b34801561083e575f5ffd5b506104ad61084d366004614f4f565b611c62565b34801561085d575f5ffd5b5061039461086c366004614b5a565b611c8f565b61048c61087f366004614be3565b611cc5565b34801561088f575f5ffd5b506009546104e4906001600160601b031681565b3480156108ae575f5ffd5b506005546108c2906001600160401b031681565b6040516001600160401b0390911681526020016103a0565b3480156108e5575f5ffd5b506103bc5f81565b3480156108f8575f5ffd5b506103bc611dd0565b34801561090c575f5ffd5b5061092061091b366004614be3565b611f7a565b6040516103a09190614fb2565b348015610938575f5ffd5b5061048c611fa3565b34801561094c575f5ffd5b50600b5461039490610100900460ff1681565b34801561096a575f5ffd5b5061048c610979366004614be3565b611fee565b348015610989575f5ffd5b5061052f604051806040016040528060058152602001640352e302e360dc1b81525081565b3480156109b9575f5ffd5b506109cd6109c8366004614f4f565b61202e565b6040516103a09190614fc4565b3480156109e5575f5ffd5b5061048c6109f4366004614be3565b612123565b348015610a04575f5ffd5b5061048c610a13366004614b88565b61220e565b348015610a23575f5ffd5b5061048c610a32366004614b5a565b6122a7565b348015610a42575f5ffd5b50600a5463ffffffff808216916401000000008104821691600160401b8204811691600160601b8104821691600160801b820481169160ff600160a01b82041691600160a81b90910416610426565b348015610a9c575f5ffd5b50610ab0610aab366004614be3565b61239b565b6040516103a09190615006565b348015610ac8575f5ffd5b5061052f610ad73660046150d2565b6127a0565b348015610ae7575f5ffd5b506103bc610af6366004614be3565b612bbe565b348015610b06575f5ffd5b5061048c610b15366004614b5a565b612be2565b348015610b25575f5ffd5b50610394610b34366004614be3565b612dce565b348015610b44575f5ffd5b5061048c610b53366004614b5a565b612e59565b348015610b63575f5ffd5b5061048c610b72366004614b5a565b612e75565b348015610b82575f5ffd5b50610b96610b91366004614be3565b612f12565b6040516103a09493929190615139565b5f6001600160e01b03198216635a05180f60e01b1480610bca5750610bca82612fd1565b92915050565b600b545f9060ff16610c295760405162461bcd60e51b815260206004820152601a60248201527f436f6e7472616374206973206e6f7420636f6e6669677572656400000000000060448201526064015b60405180910390fd5b600b54610100900460ff1615610c785760405162461bcd60e51b815260206004820152601460248201527310dbdb9d1c9858dd081a5cc8191a5cd8589b195960621b6044820152606401610c20565b83151580610c8557505f34115b610cf75760405162461bcd60e51b815260206004820152603860248201527f4469726563742066756e64696e6720726571756972656420666f72207265717560448201527f6573742066756c66696c6c6d656e742063616c6c6261636b00000000000000006064820152608401610c20565b610d018585613005565b5f610d5760405180604001604052806013815260200172424e3235342d424c532d424c4f434b4c4f434b60681b81525084604051602001610d429190615238565b6040516020818303038152906040528661322f565b90506040518061012001604052808681526020013481526020018763ffffffff16815260200182815260200185815260200184610d93906152ca565b815260408051602080820183525f808352818501929092528251808201845282815283850152336060948501528582526010815290829020845181559084015160018201559083015160028201805463ffffffff191663ffffffff90921691909117905590820151600382015560808201516004820190610e1490826153db565b5060a0820151805180516005840191908290610e3390829060026147fc565b506020820151610e4990600280840191906147fc565b50505060208201516004820190610e6090826153db565b5060408201516005820190610e7590826153db565b50505060c0820151600b820190610e8c90826153db565b5060e0820151600c820190610ea190826153db565b506101009190910151600d90910180546001600160a01b0319166001600160a01b03909216919091179055604051339082907fa7cf57609b4abed689b408db0b0c3dc6309786b6c07d5efbbd1d5b150e6d2c0690610f0490889088904290615495565b60405180910390a395945050505050565b81610f1f816132a3565b610f276132f7565b610f308361113a565b15610f4e57604051631685ecdd60e31b815260040160405180910390fd5b610f58838361331f565b610f6160015f55565b505050565b610f7c5f516020615a955f395f51905f5261338f565b600180546001600160a01b0319166001600160a01b0383169081179091556040517f0dae1d002e96c238ebe140ca1799f77093ae09e0bde40f79bb29ed78d09e652d905f90a250565b600c8054610fd290615365565b80601f0160208091040260200160405190810160405280929190818152602001828054610ffe90615365565b80156110495780601f1061102057610100808354040283529160200191611049565b820191905f5260205f20905b81548152906001019060200180831161102c57829003601f168201915b505050505081565b5f9081525f516020615a755f395f51905f52602052604090206001015490565b6110875f516020615a955f395f51905f5261338f565b600b805461ff0019166101001790556040517f75884cdadc4a89e8b545db800057f06ec7f5338a08183c7ba515f2bfdd9fe1e1905f90a1565b6110c982611051565b6110d28161338f565b6110dc8383613399565b50505050565b5f6110f38363ffffffff16836133db565b9392505050565b6001600160a01b03811633146111235760405163334bd91960e11b815260040160405180910390fd5b610f6182826134e8565b600d8054610fd290615365565b5f8181526003602052604081206002018054825b818110156111c5575f60025f85848154811061116c5761116c6154ca565b5f9182526020808320909101546001600160a01b0316835282810193909352604091820181208982529092529020546001600160401b03600160481b9091041611156111bd57506001949350505050565b60010161114e565b505f949350505050565b6111e55f516020615a955f395f51905f5261338f565b60ff8216609b116112385760405162461bcd60e51b815260206004820152601a60248201527f496e76616c6964205072656d69756d2050657263656e746167650000000000006044820152606401610c20565b6040805160e08101825263ffffffff89811680835289821660208401819052898316848601819052898416606086018190528985166080870181905260ff8a1660a0880181905295891660c0909701879052600a805467ffffffffffffffff1916909517640100000000909402939093176fffffffffffffffff00000000000000001916600160401b90920263ffffffff60601b191691909117600160601b9091021764ffffffffff60801b1916600160801b90910260ff60a01b191617600160a01b9092029190911763ffffffff60a81b1916600160a81b909202919091179055600b805460ff19166001179055517f55a28fde295f482c9f32d670c116103bca15724bcef4f18b35542e0553c35ad59061139b90899089908990899089908990899063ffffffff97881681529587166020870152938616604086015291851660608501528416608084015260ff1660a083015290911660c082015260e00190565b60405180910390a150505050505050565b5f6113b5613521565b805490915060ff600160401b82041615906001600160401b03165f811580156113db5750825b90505f826001600160401b031660011480156113f65750303b155b905081158015611404575080155b156114225760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561144c57845460ff60401b1916600160401b1785555b611454613549565b61145c613549565b6114735f516020615a955f395f51905f5288613399565b6114b35760405162461bcd60e51b815260206004820152601160248201527011dc985b9d081c9bdb194819985a5b1959607a1b6044820152606401610c20565b6114bd5f88613399565b6114fd5760405162461bcd60e51b815260206004820152601160248201527011dc985b9d081c9bdb194819985a5b1959607a1b6044820152606401610c20565b600180546001600160a01b0319166001600160a01b03881617905561152146613553565b60405160200161153191906154f5565b604051602081830303815290604052600c908161154e91906153db565b5061155846613553565b604051602001611568919061554c565b604051602081830303815290604052600d908161158591906153db565b5061158f46613553565b60405160200161159f9190615588565b604051602081830303815290604052600e90816115bc91906153db565b506115c646613553565b6040516020016115d691906155c4565b604051602081830303815290604052600f90816115f391906153db565b50831561163657845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200161139b565b50505050505050565b5f610bca8263ffffffff163a6133db565b61165861371a565b611661826137be565b61166b82826137d4565b5050565b5f611678613890565b505f516020615a555f395f51905f525b90565b6116936132f7565b6116a95f516020615a955f395f51905f5261338f565b600854600160601b90046001600160601b03166116c78115156138d9565b600880546bffffffffffffffffffffffff60601b191690556116f2826001600160601b0383166138f7565b506116fc60015f55565b50565b6001546001600160a01b031633146117595760405162461bcd60e51b815260206004820152601e60248201527f4f6e6c792044656372797074696f6e53656e6465722063616e2063616c6c00006044820152606401610c20565b6117cb8585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050604080516020601f890181900481028201810190925287815292508791508690819084018382808284375f9201919091525061396792505050565b5050505050565b60106020525f9081526040902080546001820154600283015460038401546004850180549495939463ffffffff90931693919261180e90615365565b80601f016020809104026020016040519081016040528092919081815260200182805461183a90615365565b80156118855780601f1061185c57610100808354040283529160200191611885565b820191905f5260205f20905b81548152906001019060200180831161186857829003601f168201915b50506040805160e081019091529394939250506005830190508160608101828160a084018260028282826020028201915b8154815260200190600101908083116118b657505050918352505060408051808201918290526020909201919060028481019182845b8154815260200190600101908083116118ec57505050505081525050815260200160048201805461191c90615365565b80601f016020809104026020016040519081016040528092919081815260200182805461194890615365565b80156119935780601f1061196a57610100808354040283529160200191611993565b820191905f5260205f20905b81548152906001019060200180831161197657829003601f168201915b505050505081526020016005820180546119ac90615365565b80601f01602080910402602001604051908101604052809291908181526020018280546119d890615365565b8015611a235780601f106119fa57610100808354040283529160200191611a23565b820191905f5260205f20905b815481529060010190602001808311611a0657829003601f168201915b5050505050815250509080600b018054611a3c90615365565b80601f0160208091040260200160405190810160405280929190818152602001828054611a6890615365565b8015611ab35780601f10611a8a57610100808354040283529160200191611ab3565b820191905f5260205f20905b815481529060010190602001808311611a9657829003601f168201915b50505050509080600c018054611ac890615365565b80601f0160208091040260200160405190810160405280929190818152602001828054611af490615365565b8015611b3f5780601f10611b1657610100808354040283529160200191611b3f565b820191905f5260205f20905b815481529060010190602001808311611b2257829003601f168201915b505050600d90930154919250506001600160a01b031689565b600f8054610fd290615365565b600e8054610fd290615365565b600b545f9060ff16611bc65760405162461bcd60e51b815260206004820152601a60248201527f436f6e7472616374206973206e6f7420636f6e666967757265640000000000006044820152606401610c20565b600b54610100900460ff1615611c155760405162461bcd60e51b815260206004820152601460248201527310dbdb9d1c9858dd081a5cc8191a5cd8589b195960621b6044820152606401610c20565b5f611c58865f87878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250899250610bd0915050565b9695505050505050565b5f8281525f516020615a355f395f51905f52602081905260408220611c879084613aff565b949350505050565b5f9182525f516020615a755f395f51905f52602090815260408084206001600160a01b0393909316845291905290205460ff1690565b611ccd6132f7565b5f81815260036020526040902054611ced906001600160a01b0316613b0a565b5f81815260046020526040812080546001600160601b031691349190611d138385615614565b92506101000a8154816001600160601b0302191690836001600160601b031602179055503460085f8282829054906101000a90046001600160601b0316611d5a9190615614565b92506101000a8154816001600160601b0302191690836001600160601b03160217905550817f7603b205d03651ee812f803fccde89f1012e545a9c99f0abfea9cedd0fd8e902823484611dad9190615633565b604080519283526020830191909152015b60405180910390a2506116fc60015f55565b5f611dd96132f7565b6005546001600160401b031633611df1600143615646565b6040516001600160601b0319606093841b81166020830152914060348201523090921b1660548201526001600160c01b031960c083901b16606882015260700160408051601f1981840301815291905280516020909101209150611e56816001615659565b6005805467ffffffffffffffff19166001600160401b03928316179055604080515f808252606080830184526020808401838152848601848152898552600483528685209151825491516001600160601b039091166001600160a01b031992831617600160601b91909916029790971790558451918201855233825281810183815282860185815289855260038352959093208251815488166001600160a01b0391821617825593516001820180549098169416939093179095559251805192949192611f29926002850192019061483a565b50611f3991506006905084613b31565b5060405133815283907f1d3015d7ba850fa198dc7b1a3f5d42779313a681035f77c8c03764c61005518d9060200160405180910390a2505061168860015f55565b5f8181525f516020615a355f395f51905f5260208190526040909120606091906110f390613b3c565b611fb95f516020615a955f395f51905f5261338f565b600b805461ff00191690556040517fc0f961051f97b04c496472d11cb6170d844e4b2c9dfd3b602a4fa0139712d484905f90a1565b6120045f516020615a955f395f51905f5261338f565b5f818152600360205260409020546001600160a01b031661202481613b0a565b61166b828261331f565b60605f61203b6006613b48565b905080841061205d57604051631390f2a160e01b815260040160405180910390fd5b5f6120688486615633565b905081811180612076575083155b6120805780612082565b815b90505f61208f8683615646565b9050806001600160401b038111156120a9576120a96149ef565b6040519080825280602002602001820160405280156120d2578160200160208202803683370190505b5093505f5b81811015612119576120f46120ec8883615633565b600690613aff565b858281518110612106576121066154ca565b60209081029190910101526001016120d7565b5050505092915050565b61212b6132f7565b5f818152600360205260409020546001600160a01b031661214b81613b0a565b5f828152600360205260409020600101546001600160a01b031633146121a2575f828152600360205260409081902060010154905163d084e97560e01b81526001600160a01b039091166004820152602401610c20565b5f828152600360209081526040918290208054336001600160a01b03199182168117835560019092018054909116905582516001600160a01b03851681529182015283917fd4114ab6e9af9f597c52041f32d62dc57c5c4e4c0d4427006069635e216c93869101611dbe565b6122166132f7565b61222c5f516020615a955f395f51905f5261338f565b6009546001600160601b03166122438115156138d9565b600980546001600160601b0319169055600880548291905f906122709084906001600160601b0316615678565b92506101000a8154816001600160601b0302191690836001600160601b031602179055506116f282826001600160601b03166138f7565b816122b1816132a3565b6122b96132f7565b6001600160a01b0382165f9081526002602090815260408083208684529091529020805460ff16156122eb5750610f58565b5f84815260036020526040902060020180546063190161231e576040516305a48e0f60e01b815260040160405180910390fd5b8154600160ff1990911681178355815490810182555f82815260209081902090910180546001600160a01b0319166001600160a01b03871690811790915560405190815286917f1e980d04aa7648e205713e5e8ea3808672ac163d10936d36f91b2c88ac1575e191015b60405180910390a25050610f6160015f55565b6123a361488d565b5f82815260106020908152604080832081516101208101835281548152600182015493810193909352600281015463ffffffff1691830191909152600381015460608301526004810180546080840191906123fd90615365565b80601f016020809104026020016040519081016040528092919081815260200182805461242990615365565b80156124745780601f1061244b57610100808354040283529160200191612474565b820191905f5260205f20905b81548152906001019060200180831161245757829003601f168201915b50505091835250506040805160e08101909152602090910190600583018160608101828160a084018260028282826020028201915b8154815260200190600101908083116124a957505050918352505060408051808201918290526020909201919060028481019182845b8154815260200190600101908083116124df57505050505081525050815260200160048201805461250f90615365565b80601f016020809104026020016040519081016040528092919081815260200182805461253b90615365565b80156125865780601f1061255d57610100808354040283529160200191612586565b820191905f5260205f20905b81548152906001019060200180831161256957829003601f168201915b5050505050815260200160058201805461259f90615365565b80601f01602080910402602001604051908101604052809291908181526020018280546125cb90615365565b80156126165780601f106125ed57610100808354040283529160200191612616565b820191905f5260205f20905b8154815290600101906020018083116125f957829003601f168201915b5050505050815250508152602001600b8201805461263390615365565b80601f016020809104026020016040519081016040528092919081815260200182805461265f90615365565b80156126aa5780601f10612681576101008083540402835291602001916126aa565b820191905f5260205f20905b81548152906001019060200180831161268d57829003601f168201915b50505050508152602001600c820180546126c390615365565b80601f01602080910402602001604051908101604052809291908181526020018280546126ef90615365565b801561273a5780601f106127115761010080835404028352916020019161273a565b820191905f5260205f20905b81548152906001019060200180831161271d57829003601f168201915b5050509183525050600d91909101546001600160a01b03166020909101526060810151909150610bca5760405162461bcd60e51b81526020600482015260116024820152701a5b9d985b1a59081c995c5d595cdd1259607a1b6044820152606401610c20565b60606127af6080850185615697565b9050610100036128015760405162461bcd60e51b815260206004820152601d60248201527f696e76616c69642064656372797074696f6e206b6579206c656e6774680000006044820152606401610c20565b61010061281160a0860186615697565b9050106128605760405162461bcd60e51b815260206004820152601d60248201527f6d657373616765206f6620756e737570706f72746564206c656e6774680000006044820152606401610c20565b5f61286e6080860186615697565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509394505050505b83811015612902578484828181106128be576128be6154ca565b9050013560f81c60f81b8282815181106128da576128da6154ca565b0160200180516001600160f81b0319908116909218909116905f82901a9053506001016128a4565b505f61291160a0870187615697565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920182905250600f805495965090946129ef945090925061295b9150615365565b80601f016020809104026020016040519081016040528092919081815260200182805461298790615365565b80156129d25780601f106129a9576101008083540402835291602001916129d2565b820191905f5260205f20905b8154815290600101906020018083116129b557829003601f168201915b505050505084898060a001906129e89190615697565b9050613b51565b90505f5b612a0060a0890189615697565b9050811015612a6057818181518110612a1b57612a1b6154ca565b602001015160f81c60f81b838281518110612a3857612a386154ca565b0160200180516001600160f81b0319908116909218909116905f82901a9053506001016129f3565b505f612b15600e8054612a7290615365565b80601f0160208091040260200160405190810160405280929190818152602001828054612a9e90615365565b8015612ae95780601f10612ac057610100808354040283529160200191612ae9565b820191905f5260205f20905b815481529060010190602001808311612acc57829003601f168201915b50505050508585604051602001612b019291906156d9565b604051602081830303815290604052613ce6565b90505f612b2182613d45565b90505f80612b3d83612b38368e90038e018e6156ed565b613dd7565b909250905060018215158215151414612baf5760405162461bcd60e51b815260206004820152602e60248201527f696e76616c69642064656372797074696f6e206b6579202f206369706865727460448201526d195e1d081c9959da5cdd195c995960921b6064820152608401610c20565b50939998505050505050505050565b5f8181525f516020615a355f395f51905f526020819052604082206110f390613b48565b81612bec816132a3565b612bf46132f7565b612bfd8361113a565b15612c1b57604051631685ecdd60e31b815260040160405180910390fd5b6001600160a01b0382165f90815260026020908152604080832086845290915290205460ff16612c70576040516379bfd40160e01b8152600481018490526001600160a01b0383166024820152604401610c20565b5f838152600360205260408120600201805490915b81811015612d7357846001600160a01b0316838281548110612ca957612ca96154ca565b5f918252602090912001546001600160a01b031603612d6b5782612cce600184615646565b81548110612cde57612cde6154ca565b905f5260205f20015f9054906101000a90046001600160a01b0316838281548110612d0b57612d0b6154ca565b905f5260205f20015f6101000a8154816001600160a01b0302191690836001600160a01b0316021790555082805480612d4657612d46615707565b5f8281526020902081015f1990810180546001600160a01b0319169055019055612d73565b600101612c85565b506001600160a01b0384165f818152600260209081526040808320898452825291829020805460ff19169055905191825286917f32158c6058347c1601b2d12bc696ac6901d8a9a9aa3ba10c27ab0a983e8425a79101612388565b5f5f612dd98361239b565b606001519050805f03612dee57505f92915050565b60015460405163cd802c9160e01b8152600481018390526001600160a01b039091169063cd802c9190602401602060405180830381865afa158015612e35573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110f3919061571b565b612e6282611051565b612e6b8161338f565b6110dc83836134e8565b81612e7f816132a3565b612e876132f7565b5f83815260036020526040902060018101546001600160a01b03848116911614612f08576001810180546001600160a01b0319166001600160a01b03851690811790915560408051338152602081019290925285917f21a4dad170a6bf476c31bbcf4a16628295b0e450672eec25d7c93308e05344a1910160405180910390a25b50610f6160015f55565b5f8181526003602052604081205481906001600160a01b03166060612f3682613b0a565b5f85815260046020908152604080832054600383529281902060020180548251818502810185019093528083526001600160601b03851694600160601b90046001600160401b0316938793918391830182828015612fbb57602002820191905f5260205f20905b81546001600160a01b03168152600190910190602001808311612f9d575b5050505050905093509350935093509193509193565b5f6001600160e01b03198216637965db0b60e01b1480610bca57506301ffc9a760e01b6001600160e01b0319831614610bca565b600a5463ffffffff90811690831611156130615760405162461bcd60e51b815260206004820152601a60248201527f43616c6c6261636b206761734c696d697420746f6f20686967680000000000006044820152606401610c20565b80156131de575f818152600360205260409020546001600160a01b031661308781613b0a565b335f908152600260209081526040808320858452808352928190208151606081018352905460ff811615158083526001600160401b036101008304811695840195909552600160481b90910490931691810191909152906131345760405162461bcd60e51b815260206004820152602160248201527f4e6f2061637469766520737562736372697074696f6e20666f722063616c6c656044820152603960f91b6064820152608401610c20565b8060200180516131439061573a565b6001600160401b0316905260408101805161315d9061573a565b6001600160401b039081169091525f8581526020938452604090819020835181549585015192909401518316600160481b0270ffffffffffffffff00000000000000000019929093166101000268ffffffffffffffff00199415159490941668ffffffffffffffffff19909516949094179290921791909116179055505050565b5f6131ef8363ffffffff163a6133db565b905080341015610f615760405162461bcd60e51b815260206004820152600b60248201526a46656520746f6f206c6f7760a81b6044820152606401610c20565b60015460405163f87f0e6160e01b81525f916001600160a01b03169063f87f0e619061326390879087908790600401615764565b6020604051808303815f875af115801561327f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611c87919061579c565b5f818152600360205260409020546001600160a01b03166132c381613b0a565b336001600160a01b0382161461166b57604051636c51fda960e11b81526001600160a01b0382166004820152602401610c20565b60025f540361331957604051633ee5aeb560e01b815260040160405180910390fd5b60025f55565b5f61332983613f46565b905061333e82826001600160601b03166138f7565b604080516001600160a01b03841681526001600160601b038316602082015284917f3784f77e8e883de95b5d47cd713ced01229fa74d118c0a462224bcb0516d43f1910160405180910390a2505050565b6116fc8133614097565b5f5f516020615a355f395f51905f52816133b385856140d0565b90508015611c87575f8581526020839052604090206133d29085614171565b50949350505050565b6040805160e081018252600a5463ffffffff8082168352640100000000820481166020840152600160401b8204811693830193909352600160601b810483166060830152600160801b81048316608083015260ff600160a01b82041660a0830152600160a81b900490911660c08201525f90818361346357816060015163ffffffff16613465565b835b90505f61347186614185565b63ffffffff16836080015163ffffffff1687856020015163ffffffff16010101820290505f61349d5f90565b90505f8460a0015160640160ff1690505f856040015163ffffffff1664e8d4a510000290505f8160648487870102816134d8576134d86157b3565b04019a9950505050505050505050565b5f5f516020615a355f395f51905f5281613502858561419c565b90508015611c87575f8581526020839052604090206133d29085614215565b5f807ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00610bca565b613551614229565b565b604080518082018252601081526f181899199a1a9b1b9c1cb0b131b232b360811b602082015281516042808252608082019093526060925f9190602082018180368337019050509050600360fc1b815f815181106135b3576135b36154ca565b60200101906001600160f81b03191690815f1a905350600f60fb1b816001815181106135e1576135e16154ca565b60200101906001600160f81b03191690815f1a9053505f5b602081101561371257826004868360208110613617576136176154ca565b1a60f81b6001600160f81b031916901c60f81c60ff168151811061363d5761363d6154ca565b01602001516001600160f81b031916826136588360026157c7565b613663906002615633565b81518110613673576136736154ca565b60200101906001600160f81b03191690815f1a9053508285826020811061369c5761369c6154ca565b825191901a600f169081106136b3576136b36154ca565b01602001516001600160f81b031916826136ce8360026157c7565b6136d9906002615633565b6136e4906001615633565b815181106136f4576136f46154ca565b60200101906001600160f81b03191690815f1a9053506001016135f9565b509392505050565b306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614806137a057507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166137945f516020615a555f395f51905f52546001600160a01b031690565b6001600160a01b031614155b156135515760405163703e46dd60e11b815260040160405180910390fd5b6116fc5f516020615a955f395f51905f5261338f565b816001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561382e575060408051601f3d908101601f1916820190925261382b9181019061579c565b60015b61385657604051634c9c8ce360e01b81526001600160a01b0383166004820152602401610c20565b5f516020615a555f395f51905f52811461388657604051632a87526960e21b815260048101829052602401610c20565b610f61838361424e565b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146135515760405163703e46dd60e11b815260040160405180910390fd5b806116fc57604051631e9acf1760e31b815260040160405180910390fd5b5f826001600160a01b0316826040515f6040518083038185875af1925050503d805f8114613940576040519150601f19603f3d011682016040523d82523d5f602084013e613945565b606091505b5050905080610f615760405163950b247960e01b815260040160405180910390fd5b5f5a5f85815260106020526040812060038101549293509190036139cd5760405162461bcd60e51b815260206004820152601960248201527f4e6f207265717565737420666f722072657175657374206964000000000000006044820152606401610c20565b5f635d94180260e01b86866040516024016139e99291906157de565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152600d8301546002840154600a549293505f92613a599285926001600160a01b039091169163ffffffff91821691600160a81b9091048116906142a316565b5090508015613aca57600c8301613a7087826153db565b50600b8301613a7f86826153db565b50867f99fd15974cbf00f0f208baae5a2825fa736397eac7e2ba3003c827438ca093f7846004018560050186600c01604051613abd93929190615897565b60405180910390a2613af5565b60405187907f15083536507666802cbd84fcc1e37ed89879bad2345aaa38d48d91a5071d0f5d905f90a25b61163687856142da565b5f6110f383836143c9565b6001600160a01b0381166116fc57604051630fb532db60e11b815260040160405180910390fd5b5f6110f383836143ef565b60605f6110f38361443b565b5f610bca825490565b825160609060ff811115613b7a57846040516313727cdd60e11b8152600401610c209190614bd1565b60408051608880825260c082019092525f916020820181803683370190505090505f81865f875f8b88604051602001613bb9979695949392919061590c565b60405160208183030381529060405290505f818051906020012090505f8160018a87604051602001613bee9493929190615976565b60408051601f19818403018152919052805160208201209091505f60ff89166001600160401b03811115613c2457613c246149ef565b6040519080825280601f01601f191660200182016040528015613c4e576020820181803683370190505b5090505f6005613c62601f60ff8d16615633565b901c905060015b81811015613cc857858418613c7f826001615633565b8e8b604051602001613c949493929190615976565b60408051808303601f1901815291905260205f19830181028501810195909552805194810194909420939450600101613c69565b505f1901602090810282010191909152955050505050509392505050565b5f5f613cf484846030613b51565b601881015160308201519192506001600160c01b0391821691165f7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478381600160c01b850908979650505050505050565b604080518082019091525f8082526020820152613d606148df565b6001815260026020820152604081018390525f60608360808460076107d05a03fa905080613dd05760405162461bcd60e51b815260206004820152601f60248201527f4731207363616c6172206d756c7469706c69636174696f6e206661696c6564006044820152606401610c20565b5050919050565b5f5f5f604051806101800160405280865f01518152602001866020015181526020017f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec81526020017f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d81526020016001815260200160028152602001855f0151600160028110613eb557613eb56154ca565b60200201518152602001855f01515f60028110613ed457613ed46154ca565b602002015181526020018560200151600160028110613ef557613ef56154ca565b6020020151815260200185602001515f60028110613f1557613f156154ca565b602002015190529050613f266148fd565b6020816101808460086107d05a03fa9051151593509150505b9250929050565b5f8181526003602090815260408083206004909252822054600290910180546001600160601b03909216929091905b81811015613fe05760025f848381548110613f9257613f926154ca565b5f9182526020808320909101546001600160a01b0316835282810193909352604091820181208882529092529020805470ffffffffffffffffffffffffffffffffff19169055600101613f75565b505f84815260036020526040812080546001600160a01b03199081168255600182018054909116905590614017600283018261491b565b50505f84815260046020526040902080546001600160a01b031916905561403f600685614494565b506001600160601b03831615613dd057600880548491905f9061406c9084906001600160601b0316615678565b92506101000a8154816001600160601b0302191690836001600160601b031602179055505050919050565b6140a18282611c8f565b61166b5760405163e2517d3f60e01b81526001600160a01b038216600482015260248101839052604401610c20565b5f5f516020615a755f395f51905f526140e98484611c8f565b614168575f848152602082815260408083206001600160a01b03871684529091529020805460ff1916600117905561411e3390565b6001600160a01b0316836001600160a01b0316857f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a46001915050610bca565b5f915050610bca565b5f6110f3836001600160a01b0384166143ef565b5f614191603f836159b9565b610bca9060016159ec565b5f5f516020615a755f395f51905f526141b58484611c8f565b15614168575f848152602082815260408083206001600160a01b0387168085529252808320805460ff1916905551339287917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a46001915050610bca565b5f6110f3836001600160a01b03841661449b565b614231614575565b61355157604051631afcd79f60e31b815260040160405180910390fd5b6142578261458e565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a280511561429b57610f6182826145f1565b61166b614663565b5f5f5a8381106142d0578390036040810481038510156142d0575f5f885160208a015f8a8af19250600191505b5094509492505050565b5f6142e48361239b565b8051909150156143b85780515f9081526004602052604090208054600c9061431b90600160601b90046001600160401b031661573a565b82546001600160401b0391821661010093840a90810290830219909116179092558201516001600160a01b03165f9081526002602090815260408083208551845290915290208054909160099161437a91600160481b90910416615a08565b91906101000a8154816001600160401b0302191690836001600160401b031602179055505f6143a9833a614682565b90506110dc81835f01516146da565b610f618160200151825f01516146da565b5f825f0182815481106143de576143de6154ca565b905f5260205f200154905092915050565b5f81815260018301602052604081205461443457508154600181810184555f848152602080822090930184905584548482528286019093526040902091909155610bca565b505f610bca565b6060815f0180548060200260200160405190810160405280929190818152602001828054801561448857602002820191905f5260205f20905b815481526020019060010190808311614474575b50505050509050919050565b5f6110f383835b5f8181526001830160205260408120548015614168575f6144bd600183615646565b85549091505f906144d090600190615646565b905080821461452f575f865f0182815481106144ee576144ee6154ca565b905f5260205f200154905080875f01848154811061450e5761450e6154ca565b5f918252602080832090910192909255918252600188019052604090208390555b855486908061454057614540615707565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f905560019350505050610bca565b5f61457e613521565b54600160401b900460ff16919050565b806001600160a01b03163b5f036145c357604051634c9c8ce360e01b81526001600160a01b0382166004820152602401610c20565b5f516020615a555f395f51905f5280546001600160a01b0319166001600160a01b0392909216919091179055565b60605f5f846001600160a01b03168460405161460d9190615a29565b5f60405180830381855af49150503d805f8114614645576040519150601f19603f3d011682016040523d82523d5f602084013e61464a565b606091505b509150915061465a858383614777565b95945050505050565b34156135515760405163b398979f60e01b815260040160405180910390fd5b5f5f5a600a54640100000000900463ffffffff1685010390508281025f600a5460649190920160ff600160a01b8404168201020464e8d4a5100063ffffffff600160401b909304929092169190910201949350505050565b8015614740575f81815260046020526040902080546001600160601b03908116906147099085168210156138d9565b81546001600160601b039185900382166001600160601b031991821617909255600980548083168601909216919092161790555050565b600880546001600160601b03600160601b80830482168601909116026bffffffffffffffffffffffff60601b199091161790555050565b60608261478c57614787826147d3565b6110f3565b81511580156147a357506001600160a01b0384163b155b156147cc57604051639996b31560e01b81526001600160a01b0385166004820152602401610c20565b50806110f3565b8051156147e35780518082602001fd5b60405163d6bda27560e01b815260040160405180910390fd5b826002810192821561482a579160200282015b8281111561482a57825182559160200191906001019061480f565b50614836929150614932565b5090565b828054828255905f5260205f2090810192821561482a579160200282015b8281111561482a57825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190614858565b6040518061012001604052805f81526020015f81526020015f63ffffffff1681526020015f8152602001606081526020016148c6614946565b8152606060208201819052604082018190525f91015290565b60405180606001604052806003906020820280368337509192915050565b60405180602001604052806001906020820280368337509192915050565b5080545f8255905f5260205f20908101906116fc91905b5b80821115614836575f8155600101614933565b604051806060016040528061495961496d565b815260200160608152602001606081525090565b6040518060400160405280614980614992565b815260200161498d614992565b905290565b60405180604001604052806002906020820280368337509192915050565b5f602082840312156149c0575f5ffd5b81356001600160e01b0319811681146110f3575f5ffd5b803563ffffffff811681146149ea575f5ffd5b919050565b634e487b7160e01b5f52604160045260245ffd5b604080519081016001600160401b0381118282101715614a2557614a256149ef565b60405290565b5f82601f830112614a3a575f5ffd5b81356001600160401b03811115614a5357614a536149ef565b604051601f8201601f19908116603f011681016001600160401b0381118282101715614a8157614a816149ef565b604052818152838201602001851015614a98575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60c08284031215614ac4575f5ffd5b50919050565b5f5f5f5f60808587031215614add575f5ffd5b614ae6856149d7565b93506020850135925060408501356001600160401b03811115614b07575f5ffd5b614b1387828801614a2b565b92505060608501356001600160401b03811115614b2e575f5ffd5b614b3a87828801614ab4565b91505092959194509250565b6001600160a01b03811681146116fc575f5ffd5b5f5f60408385031215614b6b575f5ffd5b823591506020830135614b7d81614b46565b809150509250929050565b5f60208284031215614b98575f5ffd5b81356110f381614b46565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6110f36020830184614ba3565b5f60208284031215614bf3575f5ffd5b5035919050565b5f5f60408385031215614c0b575f5ffd5b614c14836149d7565b946020939093013593505050565b5f5f5f5f5f5f5f60e0888a031215614c38575f5ffd5b614c41886149d7565b9650614c4f602089016149d7565b9550614c5d604089016149d7565b9450614c6b606089016149d7565b9350614c79608089016149d7565b925060a088013560ff81168114614c8e575f5ffd5b9150614c9c60c089016149d7565b905092959891949750929550565b5f5f60408385031215614cbb575f5ffd5b8235614cc681614b46565b91506020830135614b7d81614b46565b5f60208284031215614ce6575f5ffd5b6110f3826149d7565b5f5f60408385031215614d00575f5ffd5b8235614d0b81614b46565b915060208301356001600160401b03811115614d25575f5ffd5b614d3185828601614a2b565b9150509250929050565b5f5f83601f840112614d4b575f5ffd5b5081356001600160401b03811115614d61575f5ffd5b602083019150836020828501011115613f3f575f5ffd5b5f5f5f5f5f60608688031215614d8c575f5ffd5b8535945060208601356001600160401b03811115614da8575f5ffd5b614db488828901614d3b565b90955093505060408601356001600160401b03811115614dd2575f5ffd5b614dde88828901614d3b565b969995985093965092949392505050565b805f5b60028110156110dc578151845260209384019390910190600101614df2565b5f8151614e1f848251614def565b60200151614e306040850182614def565b50602082015160c06080850152614e4a60c0850182614ba3565b9050604083015184820360a086015261465a8282614ba3565b89815288602082015263ffffffff8816604082015286606082015261012060808201525f614e95610120830188614ba3565b82810360a0840152614ea78188614e11565b905082810360c0840152614ebb8187614ba3565b905082810360e0840152614ecf8186614ba3565b91505060018060a01b0383166101008301529a9950505050505050505050565b5f5f5f5f60608587031215614f02575f5ffd5b614f0b856149d7565b935060208501356001600160401b03811115614f25575f5ffd5b614f3187828801614d3b565b90945092505060408501356001600160401b03811115614b2e575f5ffd5b5f5f60408385031215614f60575f5ffd5b50508035926020909101359150565b5f8151808452602084019350602083015f5b82811015614fa85781516001600160a01b0316865260209586019590910190600101614f81565b5093949350505050565b602081525f6110f36020830184614f6f565b602080825282518282018190525f918401906040840190835b81811015614ffb578351835260209384019390920191600101614fdd565b509095945050505050565b6020815281516020820152602082015160408201525f6040830151615033606084018263ffffffff169052565b5060608301516080830152608083015161012060a0840152615059610140840182614ba3565b905060a0840151601f198483030160c08501526150768282614e11565b91505060c0840151601f198483030160e08501526150948282614ba3565b91505060e0840151601f19848303016101008501526150b38282614ba3565b9150506101008401516137126101208501826001600160a01b03169052565b5f5f5f604084860312156150e4575f5ffd5b83356001600160401b038111156150f9575f5ffd5b61510586828701614ab4565b93505060208401356001600160401b03811115615120575f5ffd5b61512c86828701614d3b565b9497909650939450505050565b6001600160601b03851681526001600160401b03841660208201526001600160a01b03831660408201526080606082018190525f90611c5890830184614f6f565b5f5f8335601e1984360301811261518f575f5ffd5b83016020810192503590506001600160401b038111156151ad575f5ffd5b803603821315613f3f575f5ffd5b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b6040818337604080820160408401375f615200608083018361517a565b60c0608086015261521560c0860182846151bb565b91505061522560a084018461517a565b85830360a0870152611c588382846151bb565b602081525f6110f360208301846151e3565b5f82601f830112615259575f5ffd5b615261614a03565b806040840185811115615272575f5ffd5b845b81811015614ffb578035845260209384019301615274565b5f6080828403121561529c575f5ffd5b6152a4614a03565b90506152b0838361524a565b81526152bf836040840161524a565b602082015292915050565b5f60c082360312156152da575f5ffd5b604051606081016001600160401b03811182821017156152fc576152fc6149ef565b604052615309368461528c565b815260808301356001600160401b03811115615323575f5ffd5b61532f36828601614a2b565b60208301525060a08301356001600160401b0381111561534d575f5ffd5b61535936828601614a2b565b60408301525092915050565b600181811c9082168061537957607f821691505b602082108103614ac457634e487b7160e01b5f52602260045260245ffd5b601f821115610f6157805f5260205f20601f840160051c810160208510156153bc5750805b601f840160051c820191505b818110156117cb575f81556001016153c8565b81516001600160401b038111156153f4576153f46149ef565b615408816154028454615365565b84615397565b6020601f82116001811461543a575f83156154235750848201515b5f19600385901b1c1916600184901b1784556117cb565b5f84815260208120601f198516915b828110156154695787850151825560209485019460019092019101615449565b508482101561548657868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b606081525f6154a76060830186614ba3565b82810360208401526154b981866151e3565b915050826040830152949350505050565b634e487b7160e01b5f52603260045260245ffd5b5f81518060208401855e5f93019283525090919050565b7f424c4f434b4c4f434b5f424e32353447315f584d443a4b454343414b2d32353681526b5f535644575f524f5f48315f60a01b60208201525f61553b602c8301846154de565b605f60f81b81526001019392505050565b7f424c4f434b4c4f434b5f424e3235345f584d443a4b454343414b2d3235365f48815261325f60f01b60208201525f61553b60228301846154de565b7f424c4f434b4c4f434b5f424e3235345f584d443a4b454343414b2d3235365f48815261335f60f01b60208201525f61553b60228301846154de565b7f424c4f434b4c4f434b5f424e3235345f584d443a4b454343414b2d3235365f48815261345f60f01b60208201525f61553b60228301846154de565b634e487b7160e01b5f52601160045260245ffd5b6001600160601b038181168382160190811115610bca57610bca615600565b80820180821115610bca57610bca615600565b81810381811115610bca57610bca615600565b6001600160401b038181168382160190811115610bca57610bca615600565b6001600160601b038281168282160390811115610bca57610bca615600565b5f5f8335601e198436030181126156ac575f5ffd5b8301803591506001600160401b038211156156c5575f5ffd5b602001915036819003821315613f3f575f5ffd5b5f611c876156e783866154de565b846154de565b5f608082840312156156fd575f5ffd5b6110f3838361528c565b634e487b7160e01b5f52603160045260245ffd5b5f6020828403121561572b575f5ffd5b815180151581146110f3575f5ffd5b5f6001600160401b0382166001600160401b03810361575b5761575b615600565b60010192915050565b606081525f6157766060830186614ba3565b82810360208401526157888186614ba3565b90508281036040840152611c588185614ba3565b5f602082840312156157ac575f5ffd5b5051919050565b634e487b7160e01b5f52601260045260245ffd5b8082028115828204841417610bca57610bca615600565b828152604060208201525f611c876040830184614ba3565b5f815461580281615365565b80855260018216801561581c57600181146158385761586c565b60ff1983166020870152602082151560051b870101935061586c565b845f5260205f205f5b838110156158635781546020828a010152600182019150602081019050615841565b87016020019450505b50505092915050565b805f5b60028110156110dc578154845260209093019260019182019101615878565b606081525f6158a960608301866157f6565b82810360208401526158bb8186615875565b6158cb6040820160028701615875565b60c060808201526158e260c08201600487016157f6565b81810360a08301526158f781600588016157f6565b9150508281036040840152611c5881856157f6565b5f61592061591a838b6154de565b896154de565b6001600160f81b031960f889811b8216835288811b8216600184015287901b16600282015261595260038201866154de565b60f89490941b6001600160f81b031916845250506001909101979650505050505050565b84815260f884901b6001600160f81b03191660208201525f61599b60218301856154de565b60f89390931b6001600160f81b031916835250506001019392505050565b5f63ffffffff8316806159da57634e487b7160e01b5f52601260045260245ffd5b8063ffffffff84160491505092915050565b63ffffffff8181168382160190811115610bca57610bca615600565b5f6001600160401b03821680615a2057615a20615600565b5f190192915050565b5f6110f382846154de56fec1f6fe24621ce81ec5827caf0253cadb74709b061630e6b55e82371705932000360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800a49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0`\x80R4\x80\x15a\0\x13W__\xFD[P`\x01_Ua\0 a\0%V[a\0\xD7V[\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x80Th\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15a\0uW`@Qc\xF9.\xE8\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80T`\x01`\x01`@\x1B\x03\x90\x81\x16\x14a\0\xD4W\x80T`\x01`\x01`@\x1B\x03\x19\x16`\x01`\x01`@\x1B\x03\x90\x81\x17\x82U`@Q\x90\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x01`@Q\x80\x91\x03\x90\xA1[PV[`\x80QaZ\xB5a\0\xFD_9_\x81\x81a7%\x01R\x81\x81a7N\x01Ra8\x9B\x01RaZ\xB5_\xF3\xFE`\x80`@R`\x046\x10a\x03qW_5`\xE0\x1C\x80csP\xF4V\x11a\x01\xC8W\x80c\xAAC:\xFF\x11a\0\xFDW\x80c\xC5\x83C\xEF\x11a\0\x9DW\x80c\xCD\x80,\x91\x11a\0mW\x80c\xCD\x80,\x91\x14a\x0B\x1AW\x80c\xD5Gt\x1F\x14a\x0B9W\x80c\xDA\xC8=)\x14a\x0BXW\x80c\xDC1\x1D\xD3\x14a\x0BwW__\xFD[\x80c\xC5\x83C\xEF\x14a\n\x91W\x80c\xC9\xBC\x18\xC4\x14a\n\xBDW\x80c\xCA\x15\xC8s\x14a\n\xDCW\x80c\xCBc\x17\x97\x14a\n\xFBW__\xFD[\x80c\xB2\xA7\xCA\xC5\x11a\0\xD8W\x80c\xB2\xA7\xCA\xC5\x14a\t\xDAW\x80c\xBD\x18ck\x14a\t\xF9W\x80c\xBE\xC4\xC0\x8C\x14a\n\x18W\x80c\xC3\xF9\t\xD4\x14a\n7W__\xFD[\x80c\xAAC:\xFF\x14a\t_W\x80c\xAD<\xB1\xCC\x14a\t~W\x80c\xAE\xFB!/\x14a\t\xAEW__\xFD[\x80c\x99\\\xB3n\x11a\x01hW\x80c\xA2\x1A#\xE4\x11a\x01CW\x80c\xA2\x1A#\xE4\x14a\x08\xEDW\x80c\xA3$j\xD3\x14a\t\x01W\x80c\xA3\x90}q\x14a\t-W\x80c\xA6\x08\xA1\xE1\x14a\tAW__\xFD[\x80c\x99\\\xB3n\x14a\x08\x84W\x80c\x9D@\xA6\xFD\x14a\x08\xA3W\x80c\xA2\x17\xFD\xDF\x14a\x08\xDAW__\xFD[\x80c\x8A\x1F\x16Z\x11a\x01\xA3W\x80c\x8A\x1F\x16Z\x14a\x07\xF5W\x80c\x90\x10\xD0|\x14a\x083W\x80c\x91\xD1HT\x14a\x08RW\x80c\x95\xB5\\\xFC\x14a\x08qW__\xFD[\x80csP\xF4V\x14a\x07\xAEW\x80cu\xB28\xFC\x14a\x07\xC2W\x80cy\t\xDC{\x14a\x07\xE2W__\xFD[\x80c8\xC2}\x12\x11a\x02\xA9W\x80cR\xD1\x90-\x11a\x02IW\x80c];\xE0\x01\x11a\x02\x19W\x80c];\xE0\x01\x14a\x07 W\x80c_{\xDA\x9F\x14a\x07?W\x80cd\xD5\x1A*\x14a\x07sW\x80cg\xB2v\xAF\x14a\x07\x9AW__\xFD[\x80cR\xD1\x90-\x14a\x06\xA7W\x80cT#o\xB3\x14a\x06\xBBW\x80cT\xFDMP\x14a\x06\xDAW\x80cW\xA8\x07\n\x14a\x07\x07W__\xFD[\x80cE\xFACT\x11a\x02\x84W\x80cE\xFACT\x14a\x067W\x80cH\\\xC9U\x14a\x06VW\x80cK\x16\t5\x14a\x06uW\x80cO\x1E\xF2\x86\x14a\x06\x94W__\xFD[\x80c8\xC2}\x12\x14a\x05\xDEW\x80c;\xC3,u\x14a\x05\xF2W\x80cA\xAFl\x87\x14a\x06\x18W__\xFD[\x80c#R\x96\xF7\x11a\x03\x14W\x80c//\xF1]\x11a\x02\xEFW\x80c//\xF1]\x14a\x05oW\x80c2U\xC4V\x14a\x05\x8EW\x80c4\x08\xE4p\x14a\x05\xADW\x80c6V\x8A\xBE\x14a\x05\xBFW__\xFD[\x80c#R\x96\xF7\x14a\x05\x1BW\x80c$\x8A\x9C\xA3\x14a\x05<W\x80c/'p\xDB\x14a\x05[W__\xFD[\x80c\n\xE0\x95@\x11a\x03OW\x80c\n\xE0\x95@\x14a\x04mW\x80c\x13<@\xC7\x14a\x04\x8EW\x80c\x18\xE3\xDD'\x14a\x04\xC5W\x80c\x1Ek\xA1[\x14a\x04\xFCW__\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x03uW\x80c\x06+\x1D\x90\x14a\x03\xA9W\x80c\x08\x80p\xF5\x14a\x03\xCAW[__\xFD[4\x80\x15a\x03\x80W__\xFD[Pa\x03\x94a\x03\x8F6`\x04aI\xB0V[a\x0B\xA6V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x03\xBCa\x03\xB76`\x04aJ\xCAV[a\x0B\xD0V[`@Q\x90\x81R` \x01a\x03\xA0V[4\x80\x15a\x03\xD5W__\xFD[P`\nTa\x04&\x90c\xFF\xFF\xFF\xFF\x80\x82\x16\x91d\x01\0\0\0\0\x81\x04\x82\x16\x91`\x01`@\x1B\x82\x04\x81\x16\x91`\x01``\x1B\x81\x04\x82\x16\x91`\x01`\x80\x1B\x82\x04\x81\x16\x91`\xFF`\x01`\xA0\x1B\x82\x04\x16\x91`\x01`\xA8\x1B\x90\x91\x04\x16\x87V[`@\x80Qc\xFF\xFF\xFF\xFF\x98\x89\x16\x81R\x96\x88\x16` \x88\x01R\x94\x87\x16\x94\x86\x01\x94\x90\x94R\x91\x85\x16``\x85\x01R\x84\x16`\x80\x84\x01R`\xFF\x16`\xA0\x83\x01R\x90\x91\x16`\xC0\x82\x01R`\xE0\x01a\x03\xA0V[4\x80\x15a\x04xW__\xFD[Pa\x04\x8Ca\x04\x876`\x04aKZV[a\x0F\x15V[\0[4\x80\x15a\x04\x99W__\xFD[P`\x01Ta\x04\xAD\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x03\xA0V[4\x80\x15a\x04\xD0W__\xFD[P`\x08Ta\x04\xE4\x90`\x01`\x01``\x1B\x03\x16\x81V[`@Q`\x01`\x01``\x1B\x03\x90\x91\x16\x81R` \x01a\x03\xA0V[4\x80\x15a\x05\x07W__\xFD[Pa\x04\x8Ca\x05\x166`\x04aK\x88V[a\x0FfV[4\x80\x15a\x05&W__\xFD[Pa\x05/a\x0F\xC5V[`@Qa\x03\xA0\x91\x90aK\xD1V[4\x80\x15a\x05GW__\xFD[Pa\x03\xBCa\x05V6`\x04aK\xE3V[a\x10QV[4\x80\x15a\x05fW__\xFD[Pa\x04\x8Ca\x10qV[4\x80\x15a\x05zW__\xFD[Pa\x04\x8Ca\x05\x896`\x04aKZV[a\x10\xC0V[4\x80\x15a\x05\x99W__\xFD[Pa\x03\xBCa\x05\xA86`\x04aK\xFAV[a\x10\xE2V[4\x80\x15a\x05\xB8W__\xFD[PFa\x03\xBCV[4\x80\x15a\x05\xCAW__\xFD[Pa\x04\x8Ca\x05\xD96`\x04aKZV[a\x10\xFAV[4\x80\x15a\x05\xE9W__\xFD[Pa\x05/a\x11-V[4\x80\x15a\x05\xFDW__\xFD[P`\x08Ta\x04\xE4\x90`\x01``\x1B\x90\x04`\x01`\x01``\x1B\x03\x16\x81V[4\x80\x15a\x06#W__\xFD[Pa\x03\x94a\x0626`\x04aK\xE3V[a\x11:V[4\x80\x15a\x06BW__\xFD[Pa\x04\x8Ca\x06Q6`\x04aL\"V[a\x11\xCFV[4\x80\x15a\x06aW__\xFD[Pa\x04\x8Ca\x06p6`\x04aL\xAAV[a\x13\xACV[4\x80\x15a\x06\x80W__\xFD[Pa\x03\xBCa\x06\x8F6`\x04aL\xD6V[a\x16?V[a\x04\x8Ca\x06\xA26`\x04aL\xEFV[a\x16PV[4\x80\x15a\x06\xB2W__\xFD[Pa\x03\xBCa\x16oV[4\x80\x15a\x06\xC6W__\xFD[Pa\x04\x8Ca\x06\xD56`\x04aK\x88V[a\x16\x8BV[4\x80\x15a\x06\xE5W__\xFD[P`@\x80Q\x80\x82\x01\x90\x91R`\x05\x81Rd0.0.1`\xD8\x1B` \x82\x01Ra\x05/V[4\x80\x15a\x07\x12W__\xFD[P`\x0BTa\x03\x94\x90`\xFF\x16\x81V[4\x80\x15a\x07+W__\xFD[Pa\x04\x8Ca\x07:6`\x04aMxV[a\x16\xFFV[4\x80\x15a\x07JW__\xFD[Pa\x07^a\x07Y6`\x04aK\xE3V[a\x17\xD2V[`@Qa\x03\xA0\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90aNcV[4\x80\x15a\x07~W__\xFD[Pa\x07\x87`d\x81V[`@Qa\xFF\xFF\x90\x91\x16\x81R` \x01a\x03\xA0V[4\x80\x15a\x07\xA5W__\xFD[Pa\x05/a\x1BXV[4\x80\x15a\x07\xB9W__\xFD[Pa\x05/a\x1BeV[4\x80\x15a\x07\xCDW__\xFD[Pa\x03\xBC_Q` aZ\x95_9_Q\x90_R\x81V[a\x03\xBCa\x07\xF06`\x04aN\xEFV[a\x1BrV[4\x80\x15a\x08\0W__\xFD[Pa\x05/`@Q\x80`@\x01`@R\x80`\x13\x81R` \x01rBN254-BLS-BLOCKLOCK`h\x1B\x81RP\x81V[4\x80\x15a\x08>W__\xFD[Pa\x04\xADa\x08M6`\x04aOOV[a\x1CbV[4\x80\x15a\x08]W__\xFD[Pa\x03\x94a\x08l6`\x04aKZV[a\x1C\x8FV[a\x04\x8Ca\x08\x7F6`\x04aK\xE3V[a\x1C\xC5V[4\x80\x15a\x08\x8FW__\xFD[P`\tTa\x04\xE4\x90`\x01`\x01``\x1B\x03\x16\x81V[4\x80\x15a\x08\xAEW__\xFD[P`\x05Ta\x08\xC2\x90`\x01`\x01`@\x1B\x03\x16\x81V[`@Q`\x01`\x01`@\x1B\x03\x90\x91\x16\x81R` \x01a\x03\xA0V[4\x80\x15a\x08\xE5W__\xFD[Pa\x03\xBC_\x81V[4\x80\x15a\x08\xF8W__\xFD[Pa\x03\xBCa\x1D\xD0V[4\x80\x15a\t\x0CW__\xFD[Pa\t a\t\x1B6`\x04aK\xE3V[a\x1FzV[`@Qa\x03\xA0\x91\x90aO\xB2V[4\x80\x15a\t8W__\xFD[Pa\x04\x8Ca\x1F\xA3V[4\x80\x15a\tLW__\xFD[P`\x0BTa\x03\x94\x90a\x01\0\x90\x04`\xFF\x16\x81V[4\x80\x15a\tjW__\xFD[Pa\x04\x8Ca\ty6`\x04aK\xE3V[a\x1F\xEEV[4\x80\x15a\t\x89W__\xFD[Pa\x05/`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01d\x03R\xE3\x02\xE3`\xDC\x1B\x81RP\x81V[4\x80\x15a\t\xB9W__\xFD[Pa\t\xCDa\t\xC86`\x04aOOV[a .V[`@Qa\x03\xA0\x91\x90aO\xC4V[4\x80\x15a\t\xE5W__\xFD[Pa\x04\x8Ca\t\xF46`\x04aK\xE3V[a!#V[4\x80\x15a\n\x04W__\xFD[Pa\x04\x8Ca\n\x136`\x04aK\x88V[a\"\x0EV[4\x80\x15a\n#W__\xFD[Pa\x04\x8Ca\n26`\x04aKZV[a\"\xA7V[4\x80\x15a\nBW__\xFD[P`\nTc\xFF\xFF\xFF\xFF\x80\x82\x16\x91d\x01\0\0\0\0\x81\x04\x82\x16\x91`\x01`@\x1B\x82\x04\x81\x16\x91`\x01``\x1B\x81\x04\x82\x16\x91`\x01`\x80\x1B\x82\x04\x81\x16\x91`\xFF`\x01`\xA0\x1B\x82\x04\x16\x91`\x01`\xA8\x1B\x90\x91\x04\x16a\x04&V[4\x80\x15a\n\x9CW__\xFD[Pa\n\xB0a\n\xAB6`\x04aK\xE3V[a#\x9BV[`@Qa\x03\xA0\x91\x90aP\x06V[4\x80\x15a\n\xC8W__\xFD[Pa\x05/a\n\xD76`\x04aP\xD2V[a'\xA0V[4\x80\x15a\n\xE7W__\xFD[Pa\x03\xBCa\n\xF66`\x04aK\xE3V[a+\xBEV[4\x80\x15a\x0B\x06W__\xFD[Pa\x04\x8Ca\x0B\x156`\x04aKZV[a+\xE2V[4\x80\x15a\x0B%W__\xFD[Pa\x03\x94a\x0B46`\x04aK\xE3V[a-\xCEV[4\x80\x15a\x0BDW__\xFD[Pa\x04\x8Ca\x0BS6`\x04aKZV[a.YV[4\x80\x15a\x0BcW__\xFD[Pa\x04\x8Ca\x0Br6`\x04aKZV[a.uV[4\x80\x15a\x0B\x82W__\xFD[Pa\x0B\x96a\x0B\x916`\x04aK\xE3V[a/\x12V[`@Qa\x03\xA0\x94\x93\x92\x91\x90aQ9V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x0B\xCAWPa\x0B\xCA\x82a/\xD1V[\x92\x91PPV[`\x0BT_\x90`\xFF\x16a\x0C)W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FContract is not configured\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`\x0BTa\x01\0\x90\x04`\xFF\x16\x15a\x0CxW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01Rs\x10\xDB\xDB\x9D\x1C\x98X\xDD\x08\x1A\\\xC8\x19\x1A\\\xD8X\x9B\x19Y`b\x1B`D\x82\x01R`d\x01a\x0C V[\x83\x15\x15\x80a\x0C\x85WP_4\x11[a\x0C\xF7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7FDirect funding required for requ`D\x82\x01R\x7Fest fulfillment callback\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x0C V[a\r\x01\x85\x85a0\x05V[_a\rW`@Q\x80`@\x01`@R\x80`\x13\x81R` \x01rBN254-BLS-BLOCKLOCK`h\x1B\x81RP\x84`@Q` \x01a\rB\x91\x90aR8V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x86a2/V[\x90P`@Q\x80a\x01 \x01`@R\x80\x86\x81R` \x014\x81R` \x01\x87c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81R` \x01\x85\x81R` \x01\x84a\r\x93\x90aR\xCAV[\x81R`@\x80Q` \x80\x82\x01\x83R_\x80\x83R\x81\x85\x01\x92\x90\x92R\x82Q\x80\x82\x01\x84R\x82\x81R\x83\x85\x01R3``\x94\x85\x01R\x85\x82R`\x10\x81R\x90\x82\x90 \x84Q\x81U\x90\x84\x01Q`\x01\x82\x01U\x90\x83\x01Q`\x02\x82\x01\x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90U\x90\x82\x01Q`\x03\x82\x01U`\x80\x82\x01Q`\x04\x82\x01\x90a\x0E\x14\x90\x82aS\xDBV[P`\xA0\x82\x01Q\x80Q\x80Q`\x05\x84\x01\x91\x90\x82\x90a\x0E3\x90\x82\x90`\x02aG\xFCV[P` \x82\x01Qa\x0EI\x90`\x02\x80\x84\x01\x91\x90aG\xFCV[PPP` \x82\x01Q`\x04\x82\x01\x90a\x0E`\x90\x82aS\xDBV[P`@\x82\x01Q`\x05\x82\x01\x90a\x0Eu\x90\x82aS\xDBV[PPP`\xC0\x82\x01Q`\x0B\x82\x01\x90a\x0E\x8C\x90\x82aS\xDBV[P`\xE0\x82\x01Q`\x0C\x82\x01\x90a\x0E\xA1\x90\x82aS\xDBV[Pa\x01\0\x91\x90\x91\x01Q`\r\x90\x91\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90\x91\x17\x90U`@Q3\x90\x82\x90\x7F\xA7\xCFW`\x9BJ\xBE\xD6\x89\xB4\x08\xDB\x0B\x0C=\xC60\x97\x86\xB6\xC0}^\xFB\xBD\x1D[\x15\x0Em,\x06\x90a\x0F\x04\x90\x88\x90\x88\x90B\x90aT\x95V[`@Q\x80\x91\x03\x90\xA3\x95\x94PPPPPV[\x81a\x0F\x1F\x81a2\xA3V[a\x0F'a2\xF7V[a\x0F0\x83a\x11:V[\x15a\x0FNW`@Qc\x16\x85\xEC\xDD`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0FX\x83\x83a3\x1FV[a\x0Fa`\x01_UV[PPPV[a\x0F|_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x81\x17\x90\x91U`@Q\x7F\r\xAE\x1D\0.\x96\xC28\xEB\xE1@\xCA\x17\x99\xF7p\x93\xAE\t\xE0\xBD\xE4\x0Fy\xBB)\xEDx\xD0\x9Ee-\x90_\x90\xA2PV[`\x0C\x80Ta\x0F\xD2\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0F\xFE\x90aSeV[\x80\x15a\x10IW\x80`\x1F\x10a\x10 Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10IV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10,W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[_\x90\x81R_Q` aZu_9_Q\x90_R` R`@\x90 `\x01\x01T\x90V[a\x10\x87_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\x0B\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U`@Q\x7Fu\x88L\xDA\xDCJ\x89\xE8\xB5E\xDB\x80\0W\xF0n\xC7\xF53\x8A\x08\x18<{\xA5\x15\xF2\xBF\xDD\x9F\xE1\xE1\x90_\x90\xA1V[a\x10\xC9\x82a\x10QV[a\x10\xD2\x81a3\x8FV[a\x10\xDC\x83\x83a3\x99V[PPPPV[_a\x10\xF3\x83c\xFF\xFF\xFF\xFF\x16\x83a3\xDBV[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x11#W`@Qc3K\xD9\x19`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0Fa\x82\x82a4\xE8V[`\r\x80Ta\x0F\xD2\x90aSeV[_\x81\x81R`\x03` R`@\x81 `\x02\x01\x80T\x82[\x81\x81\x10\x15a\x11\xC5W_`\x02_\x85\x84\x81T\x81\x10a\x11lWa\x11laT\xCAV[_\x91\x82R` \x80\x83 \x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16\x83R\x82\x81\x01\x93\x90\x93R`@\x91\x82\x01\x81 \x89\x82R\x90\x92R\x90 T`\x01`\x01`@\x1B\x03`\x01`H\x1B\x90\x91\x04\x16\x11\x15a\x11\xBDWP`\x01\x94\x93PPPPV[`\x01\x01a\x11NV[P_\x94\x93PPPPV[a\x11\xE5_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\xFF\x82\x16`\x9B\x11a\x128W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FInvalid Premium Percentage\0\0\0\0\0\0`D\x82\x01R`d\x01a\x0C V[`@\x80Q`\xE0\x81\x01\x82Rc\xFF\xFF\xFF\xFF\x89\x81\x16\x80\x83R\x89\x82\x16` \x84\x01\x81\x90R\x89\x83\x16\x84\x86\x01\x81\x90R\x89\x84\x16``\x86\x01\x81\x90R\x89\x85\x16`\x80\x87\x01\x81\x90R`\xFF\x8A\x16`\xA0\x88\x01\x81\x90R\x95\x89\x16`\xC0\x90\x97\x01\x87\x90R`\n\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x95\x17d\x01\0\0\0\0\x90\x94\x02\x93\x90\x93\x17o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x19\x16`\x01`@\x1B\x90\x92\x02c\xFF\xFF\xFF\xFF``\x1B\x19\x16\x91\x90\x91\x17`\x01``\x1B\x90\x91\x02\x17d\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x01`\x80\x1B\x90\x91\x02`\xFF`\xA0\x1B\x19\x16\x17`\x01`\xA0\x1B\x90\x92\x02\x91\x90\x91\x17c\xFF\xFF\xFF\xFF`\xA8\x1B\x19\x16`\x01`\xA8\x1B\x90\x92\x02\x91\x90\x91\x17\x90U`\x0B\x80T`\xFF\x19\x16`\x01\x17\x90UQ\x7FU\xA2\x8F\xDE)_H,\x9F2\xD6p\xC1\x16\x10;\xCA\x15rK\xCE\xF4\xF1\x8B5T.\x05S\xC3Z\xD5\x90a\x13\x9B\x90\x89\x90\x89\x90\x89\x90\x89\x90\x89\x90\x89\x90\x89\x90c\xFF\xFF\xFF\xFF\x97\x88\x16\x81R\x95\x87\x16` \x87\x01R\x93\x86\x16`@\x86\x01R\x91\x85\x16``\x85\x01R\x84\x16`\x80\x84\x01R`\xFF\x16`\xA0\x83\x01R\x90\x91\x16`\xC0\x82\x01R`\xE0\x01\x90V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[_a\x13\xB5a5!V[\x80T\x90\x91P`\xFF`\x01`@\x1B\x82\x04\x16\x15\x90`\x01`\x01`@\x1B\x03\x16_\x81\x15\x80\x15a\x13\xDBWP\x82[\x90P_\x82`\x01`\x01`@\x1B\x03\x16`\x01\x14\x80\x15a\x13\xF6WP0;\x15[\x90P\x81\x15\x80\x15a\x14\x04WP\x80\x15[\x15a\x14\"W`@Qc\xF9.\xE8\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01\x17\x85U\x83\x15a\x14LW\x84T`\xFF`@\x1B\x19\x16`\x01`@\x1B\x17\x85U[a\x14Ta5IV[a\x14\\a5IV[a\x14s_Q` aZ\x95_9_Q\x90_R\x88a3\x99V[a\x14\xB3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x11\xDC\x98[\x9D\x08\x1C\x9B\xDB\x19H\x19\x98Z[\x19Y`z\x1B`D\x82\x01R`d\x01a\x0C V[a\x14\xBD_\x88a3\x99V[a\x14\xFDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x11\xDC\x98[\x9D\x08\x1C\x9B\xDB\x19H\x19\x98Z[\x19Y`z\x1B`D\x82\x01R`d\x01a\x0C V[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x88\x16\x17\x90Ua\x15!Fa5SV[`@Q` \x01a\x151\x91\x90aT\xF5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\x0C\x90\x81a\x15N\x91\x90aS\xDBV[Pa\x15XFa5SV[`@Q` \x01a\x15h\x91\x90aULV[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\r\x90\x81a\x15\x85\x91\x90aS\xDBV[Pa\x15\x8FFa5SV[`@Q` \x01a\x15\x9F\x91\x90aU\x88V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\x0E\x90\x81a\x15\xBC\x91\x90aS\xDBV[Pa\x15\xC6Fa5SV[`@Q` \x01a\x15\xD6\x91\x90aU\xC4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\x0F\x90\x81a\x15\xF3\x91\x90aS\xDBV[P\x83\x15a\x166W\x84T`\xFF`@\x1B\x19\x16\x85U`@Q`\x01\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x01a\x13\x9BV[PPPPPPPV[_a\x0B\xCA\x82c\xFF\xFF\xFF\xFF\x16:a3\xDBV[a\x16Xa7\x1AV[a\x16a\x82a7\xBEV[a\x16k\x82\x82a7\xD4V[PPV[_a\x16xa8\x90V[P_Q` aZU_9_Q\x90_R[\x90V[a\x16\x93a2\xF7V[a\x16\xA9_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\x08T`\x01``\x1B\x90\x04`\x01`\x01``\x1B\x03\x16a\x16\xC7\x81\x15\x15a8\xD9V[`\x08\x80Tk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x1B\x19\x16\x90Ua\x16\xF2\x82`\x01`\x01``\x1B\x03\x83\x16a8\xF7V[Pa\x16\xFC`\x01_UV[PV[`\x01T`\x01`\x01`\xA0\x1B\x03\x163\x14a\x17YW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FOnly DecryptionSender can call\0\0`D\x82\x01R`d\x01a\x0C V[a\x17\xCB\x85\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPP`@\x80Q` `\x1F\x89\x01\x81\x90\x04\x81\x02\x82\x01\x81\x01\x90\x92R\x87\x81R\x92P\x87\x91P\x86\x90\x81\x90\x84\x01\x83\x82\x80\x82\x847_\x92\x01\x91\x90\x91RPa9g\x92PPPV[PPPPPV[`\x10` R_\x90\x81R`@\x90 \x80T`\x01\x82\x01T`\x02\x83\x01T`\x03\x84\x01T`\x04\x85\x01\x80T\x94\x95\x93\x94c\xFF\xFF\xFF\xFF\x90\x93\x16\x93\x91\x92a\x18\x0E\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x18:\x90aSeV[\x80\x15a\x18\x85W\x80`\x1F\x10a\x18\\Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x18\x85V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x18hW\x82\x90\x03`\x1F\x16\x82\x01\x91[PP`@\x80Q`\xE0\x81\x01\x90\x91R\x93\x94\x93\x92PP`\x05\x83\x01\x90P\x81``\x81\x01\x82\x81`\xA0\x84\x01\x82`\x02\x82\x82\x82` \x02\x82\x01\x91[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x18\xB6WPPP\x91\x83RPP`@\x80Q\x80\x82\x01\x91\x82\x90R` \x90\x92\x01\x91\x90`\x02\x84\x81\x01\x91\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x18\xECWPPPPP\x81RPP\x81R` \x01`\x04\x82\x01\x80Ta\x19\x1C\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x19H\x90aSeV[\x80\x15a\x19\x93W\x80`\x1F\x10a\x19jWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x19\x93V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x19vW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x19\xAC\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x19\xD8\x90aSeV[\x80\x15a\x1A#W\x80`\x1F\x10a\x19\xFAWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1A#V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1A\x06W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x90\x80`\x0B\x01\x80Ta\x1A<\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1Ah\x90aSeV[\x80\x15a\x1A\xB3W\x80`\x1F\x10a\x1A\x8AWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1A\xB3V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1A\x96W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90\x80`\x0C\x01\x80Ta\x1A\xC8\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1A\xF4\x90aSeV[\x80\x15a\x1B?W\x80`\x1F\x10a\x1B\x16Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1B?V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1B\"W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP`\r\x90\x93\x01T\x91\x92PP`\x01`\x01`\xA0\x1B\x03\x16\x89V[`\x0F\x80Ta\x0F\xD2\x90aSeV[`\x0E\x80Ta\x0F\xD2\x90aSeV[`\x0BT_\x90`\xFF\x16a\x1B\xC6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FContract is not configured\0\0\0\0\0\0`D\x82\x01R`d\x01a\x0C V[`\x0BTa\x01\0\x90\x04`\xFF\x16\x15a\x1C\x15W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01Rs\x10\xDB\xDB\x9D\x1C\x98X\xDD\x08\x1A\\\xC8\x19\x1A\\\xD8X\x9B\x19Y`b\x1B`D\x82\x01R`d\x01a\x0C V[_a\x1CX\x86_\x87\x87\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP\x89\x92Pa\x0B\xD0\x91PPV[\x96\x95PPPPPPV[_\x82\x81R_Q` aZ5_9_Q\x90_R` \x81\x90R`@\x82 a\x1C\x87\x90\x84a:\xFFV[\x94\x93PPPPV[_\x91\x82R_Q` aZu_9_Q\x90_R` \x90\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[a\x1C\xCDa2\xF7V[_\x81\x81R`\x03` R`@\x90 Ta\x1C\xED\x90`\x01`\x01`\xA0\x1B\x03\x16a;\nV[_\x81\x81R`\x04` R`@\x81 \x80T`\x01`\x01``\x1B\x03\x16\x914\x91\x90a\x1D\x13\x83\x85aV\x14V[\x92Pa\x01\0\n\x81T\x81`\x01`\x01``\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01``\x1B\x03\x16\x02\x17\x90UP4`\x08_\x82\x82\x82\x90T\x90a\x01\0\n\x90\x04`\x01`\x01``\x1B\x03\x16a\x1DZ\x91\x90aV\x14V[\x92Pa\x01\0\n\x81T\x81`\x01`\x01``\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01``\x1B\x03\x16\x02\x17\x90UP\x81\x7Fv\x03\xB2\x05\xD06Q\xEE\x81/\x80?\xCC\xDE\x89\xF1\x01.TZ\x9C\x99\xF0\xAB\xFE\xA9\xCE\xDD\x0F\xD8\xE9\x02\x824\x84a\x1D\xAD\x91\x90aV3V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01[`@Q\x80\x91\x03\x90\xA2Pa\x16\xFC`\x01_UV[_a\x1D\xD9a2\xF7V[`\x05T`\x01`\x01`@\x1B\x03\x163a\x1D\xF1`\x01CaVFV[`@Q`\x01`\x01``\x1B\x03\x19``\x93\x84\x1B\x81\x16` \x83\x01R\x91@`4\x82\x01R0\x90\x92\x1B\x16`T\x82\x01R`\x01`\x01`\xC0\x1B\x03\x19`\xC0\x83\x90\x1B\x16`h\x82\x01R`p\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x91Pa\x1EV\x81`\x01aVYV[`\x05\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x92\x83\x16\x17\x90U`@\x80Q_\x80\x82R``\x80\x83\x01\x84R` \x80\x84\x01\x83\x81R\x84\x86\x01\x84\x81R\x89\x85R`\x04\x83R\x86\x85 \x91Q\x82T\x91Q`\x01`\x01``\x1B\x03\x90\x91\x16`\x01`\x01`\xA0\x1B\x03\x19\x92\x83\x16\x17`\x01``\x1B\x91\x90\x99\x16\x02\x97\x90\x97\x17\x90U\x84Q\x91\x82\x01\x85R3\x82R\x81\x81\x01\x83\x81R\x82\x86\x01\x85\x81R\x89\x85R`\x03\x83R\x95\x90\x93 \x82Q\x81T\x88\x16`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x17\x82U\x93Q`\x01\x82\x01\x80T\x90\x98\x16\x94\x16\x93\x90\x93\x17\x90\x95U\x92Q\x80Q\x92\x94\x91\x92a\x1F)\x92`\x02\x85\x01\x92\x01\x90aH:V[Pa\x1F9\x91P`\x06\x90P\x84a;1V[P`@Q3\x81R\x83\x90\x7F\x1D0\x15\xD7\xBA\x85\x0F\xA1\x98\xDC{\x1A?]Bw\x93\x13\xA6\x81\x03_w\xC8\xC07d\xC6\x10\x05Q\x8D\x90` \x01`@Q\x80\x91\x03\x90\xA2PPa\x16\x88`\x01_UV[_\x81\x81R_Q` aZ5_9_Q\x90_R` \x81\x90R`@\x90\x91 ``\x91\x90a\x10\xF3\x90a;<V[a\x1F\xB9_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\x0B\x80Ta\xFF\0\x19\x16\x90U`@Q\x7F\xC0\xF9a\x05\x1F\x97\xB0LIdr\xD1\x1C\xB6\x17\r\x84NK,\x9D\xFD;`*O\xA0\x13\x97\x12\xD4\x84\x90_\x90\xA1V[a \x04_Q` aZ\x95_9_Q\x90_Ra3\x8FV[_\x81\x81R`\x03` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a $\x81a;\nV[a\x16k\x82\x82a3\x1FV[``_a ;`\x06a;HV[\x90P\x80\x84\x10a ]W`@Qc\x13\x90\xF2\xA1`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a h\x84\x86aV3V[\x90P\x81\x81\x11\x80a vWP\x83\x15[a \x80W\x80a \x82V[\x81[\x90P_a \x8F\x86\x83aVFV[\x90P\x80`\x01`\x01`@\x1B\x03\x81\x11\x15a \xA9Wa \xA9aI\xEFV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a \xD2W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x93P_[\x81\x81\x10\x15a!\x19Wa \xF4a \xEC\x88\x83aV3V[`\x06\x90a:\xFFV[\x85\x82\x81Q\x81\x10a!\x06Wa!\x06aT\xCAV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a \xD7V[PPPP\x92\x91PPV[a!+a2\xF7V[_\x81\x81R`\x03` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a!K\x81a;\nV[_\x82\x81R`\x03` R`@\x90 `\x01\x01T`\x01`\x01`\xA0\x1B\x03\x163\x14a!\xA2W_\x82\x81R`\x03` R`@\x90\x81\x90 `\x01\x01T\x90Qc\xD0\x84\xE9u`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04\x82\x01R`$\x01a\x0C V[_\x82\x81R`\x03` \x90\x81R`@\x91\x82\x90 \x80T3`\x01`\x01`\xA0\x1B\x03\x19\x91\x82\x16\x81\x17\x83U`\x01\x90\x92\x01\x80T\x90\x91\x16\x90U\x82Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R\x91\x82\x01R\x83\x91\x7F\xD4\x11J\xB6\xE9\xAF\x9FY|R\x04\x1F2\xD6-\xC5|\\NL\rD'\0`ic^!l\x93\x86\x91\x01a\x1D\xBEV[a\"\x16a2\xF7V[a\",_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\tT`\x01`\x01``\x1B\x03\x16a\"C\x81\x15\x15a8\xD9V[`\t\x80T`\x01`\x01``\x1B\x03\x19\x16\x90U`\x08\x80T\x82\x91\x90_\x90a\"p\x90\x84\x90`\x01`\x01``\x1B\x03\x16aVxV[\x92Pa\x01\0\n\x81T\x81`\x01`\x01``\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01``\x1B\x03\x16\x02\x17\x90UPa\x16\xF2\x82\x82`\x01`\x01``\x1B\x03\x16a8\xF7V[\x81a\"\xB1\x81a2\xA3V[a\"\xB9a2\xF7V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x02` \x90\x81R`@\x80\x83 \x86\x84R\x90\x91R\x90 \x80T`\xFF\x16\x15a\"\xEBWPa\x0FXV[_\x84\x81R`\x03` R`@\x90 `\x02\x01\x80T`c\x19\x01a#\x1EW`@Qc\x05\xA4\x8E\x0F`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81T`\x01`\xFF\x19\x90\x91\x16\x81\x17\x83U\x81T\x90\x81\x01\x82U_\x82\x81R` \x90\x81\x90 \x90\x91\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x16\x90\x81\x17\x90\x91U`@Q\x90\x81R\x86\x91\x7F\x1E\x98\r\x04\xAAvH\xE2\x05q>^\x8E\xA3\x80\x86r\xAC\x16=\x10\x93m6\xF9\x1B,\x88\xAC\x15u\xE1\x91\x01[`@Q\x80\x91\x03\x90\xA2PPa\x0Fa`\x01_UV[a#\xA3aH\x8DV[_\x82\x81R`\x10` \x90\x81R`@\x80\x83 \x81Qa\x01 \x81\x01\x83R\x81T\x81R`\x01\x82\x01T\x93\x81\x01\x93\x90\x93R`\x02\x81\x01Tc\xFF\xFF\xFF\xFF\x16\x91\x83\x01\x91\x90\x91R`\x03\x81\x01T``\x83\x01R`\x04\x81\x01\x80T`\x80\x84\x01\x91\x90a#\xFD\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta$)\x90aSeV[\x80\x15a$tW\x80`\x1F\x10a$KWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a$tV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a$WW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`@\x80Q`\xE0\x81\x01\x90\x91R` \x90\x91\x01\x90`\x05\x83\x01\x81``\x81\x01\x82\x81`\xA0\x84\x01\x82`\x02\x82\x82\x82` \x02\x82\x01\x91[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a$\xA9WPPP\x91\x83RPP`@\x80Q\x80\x82\x01\x91\x82\x90R` \x90\x92\x01\x91\x90`\x02\x84\x81\x01\x91\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a$\xDFWPPPPP\x81RPP\x81R` \x01`\x04\x82\x01\x80Ta%\x0F\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%;\x90aSeV[\x80\x15a%\x86W\x80`\x1F\x10a%]Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a%\x86V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%iW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta%\x9F\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%\xCB\x90aSeV[\x80\x15a&\x16W\x80`\x1F\x10a%\xEDWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\x16V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%\xF9W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01`\x0B\x82\x01\x80Ta&3\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&_\x90aSeV[\x80\x15a&\xAAW\x80`\x1F\x10a&\x81Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\xAAV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&\x8DW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x0C\x82\x01\x80Ta&\xC3\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&\xEF\x90aSeV[\x80\x15a':W\x80`\x1F\x10a'\x11Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a':V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a'\x1DW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\r\x91\x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16` \x90\x91\x01R``\x81\x01Q\x90\x91Pa\x0B\xCAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x1A[\x9D\x98[\x1AY\x08\x1C\x99\\]Y\\\xDD\x12Y`z\x1B`D\x82\x01R`d\x01a\x0C V[``a'\xAF`\x80\x85\x01\x85aV\x97V[\x90Pa\x01\0\x03a(\x01W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7Finvalid decryption key length\0\0\0`D\x82\x01R`d\x01a\x0C V[a\x01\0a(\x11`\xA0\x86\x01\x86aV\x97V[\x90P\x10a(`W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7Fmessage of unsupported length\0\0\0`D\x82\x01R`d\x01a\x0C V[_a(n`\x80\x86\x01\x86aV\x97V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP\x93\x94PPPP[\x83\x81\x10\x15a)\x02W\x84\x84\x82\x81\x81\x10a(\xBEWa(\xBEaT\xCAV[\x90P\x015`\xF8\x1C`\xF8\x1B\x82\x82\x81Q\x81\x10a(\xDAWa(\xDAaT\xCAV[\x01` \x01\x80Q`\x01`\x01`\xF8\x1B\x03\x19\x90\x81\x16\x90\x92\x18\x90\x91\x16\x90_\x82\x90\x1A\x90SP`\x01\x01a(\xA4V[P_a)\x11`\xA0\x87\x01\x87aV\x97V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP`\x0F\x80T\x95\x96P\x90\x94a)\xEF\x94P\x90\x92Pa)[\x91PaSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta)\x87\x90aSeV[\x80\x15a)\xD2W\x80`\x1F\x10a)\xA9Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a)\xD2V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a)\xB5W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x84\x89\x80`\xA0\x01\x90a)\xE8\x91\x90aV\x97V[\x90Pa;QV[\x90P_[a*\0`\xA0\x89\x01\x89aV\x97V[\x90P\x81\x10\x15a*`W\x81\x81\x81Q\x81\x10a*\x1BWa*\x1BaT\xCAV[` \x01\x01Q`\xF8\x1C`\xF8\x1B\x83\x82\x81Q\x81\x10a*8Wa*8aT\xCAV[\x01` \x01\x80Q`\x01`\x01`\xF8\x1B\x03\x19\x90\x81\x16\x90\x92\x18\x90\x91\x16\x90_\x82\x90\x1A\x90SP`\x01\x01a)\xF3V[P_a+\x15`\x0E\x80Ta*r\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta*\x9E\x90aSeV[\x80\x15a*\xE9W\x80`\x1F\x10a*\xC0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a*\xE9V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a*\xCCW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x85\x85`@Q` \x01a+\x01\x92\x91\x90aV\xD9V[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra<\xE6V[\x90P_a+!\x82a=EV[\x90P_\x80a+=\x83a+86\x8E\x90\x03\x8E\x01\x8EaV\xEDV[a=\xD7V[\x90\x92P\x90P`\x01\x82\x15\x15\x82\x15\x15\x14\x14a+\xAFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7Finvalid decryption key / ciphert`D\x82\x01Rm\x19^\x1D\x08\x1C\x99Y\xDA\\\xDD\x19\\\x99Y`\x92\x1B`d\x82\x01R`\x84\x01a\x0C V[P\x93\x99\x98PPPPPPPPPV[_\x81\x81R_Q` aZ5_9_Q\x90_R` \x81\x90R`@\x82 a\x10\xF3\x90a;HV[\x81a+\xEC\x81a2\xA3V[a+\xF4a2\xF7V[a+\xFD\x83a\x11:V[\x15a,\x1BW`@Qc\x16\x85\xEC\xDD`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x02` \x90\x81R`@\x80\x83 \x86\x84R\x90\x91R\x90 T`\xFF\x16a,pW`@Qcy\xBF\xD4\x01`\xE0\x1B\x81R`\x04\x81\x01\x84\x90R`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x01a\x0C V[_\x83\x81R`\x03` R`@\x81 `\x02\x01\x80T\x90\x91[\x81\x81\x10\x15a-sW\x84`\x01`\x01`\xA0\x1B\x03\x16\x83\x82\x81T\x81\x10a,\xA9Wa,\xA9aT\xCAV[_\x91\x82R` \x90\x91 \x01T`\x01`\x01`\xA0\x1B\x03\x16\x03a-kW\x82a,\xCE`\x01\x84aVFV[\x81T\x81\x10a,\xDEWa,\xDEaT\xCAV[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x83\x82\x81T\x81\x10a-\x0BWa-\x0BaT\xCAV[\x90_R` _ \x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP\x82\x80T\x80a-FWa-FaW\x07V[_\x82\x81R` \x90 \x81\x01_\x19\x90\x81\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90U\x01\x90Ua-sV[`\x01\x01a,\x85V[P`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x89\x84R\x82R\x91\x82\x90 \x80T`\xFF\x19\x16\x90U\x90Q\x91\x82R\x86\x91\x7F2\x15\x8C`X4|\x16\x01\xB2\xD1+\xC6\x96\xACi\x01\xD8\xA9\xA9\xAA;\xA1\x0C'\xAB\n\x98>\x84%\xA7\x91\x01a#\x88V[__a-\xD9\x83a#\x9BV[``\x01Q\x90P\x80_\x03a-\xEEWP_\x92\x91PPV[`\x01T`@Qc\xCD\x80,\x91`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\xCD\x80,\x91\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a.5W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xF3\x91\x90aW\x1BV[a.b\x82a\x10QV[a.k\x81a3\x8FV[a\x10\xDC\x83\x83a4\xE8V[\x81a.\x7F\x81a2\xA3V[a.\x87a2\xF7V[_\x83\x81R`\x03` R`@\x90 `\x01\x81\x01T`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x14a/\x08W`\x01\x81\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x85\x16\x90\x81\x17\x90\x91U`@\x80Q3\x81R` \x81\x01\x92\x90\x92R\x85\x91\x7F!\xA4\xDA\xD1p\xA6\xBFGl1\xBB\xCFJ\x16b\x82\x95\xB0\xE4Pg.\xEC%\xD7\xC93\x08\xE0SD\xA1\x91\x01`@Q\x80\x91\x03\x90\xA2[Pa\x0Fa`\x01_UV[_\x81\x81R`\x03` R`@\x81 T\x81\x90`\x01`\x01`\xA0\x1B\x03\x16``a/6\x82a;\nV[_\x85\x81R`\x04` \x90\x81R`@\x80\x83 T`\x03\x83R\x92\x81\x90 `\x02\x01\x80T\x82Q\x81\x85\x02\x81\x01\x85\x01\x90\x93R\x80\x83R`\x01`\x01``\x1B\x03\x85\x16\x94`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16\x93\x87\x93\x91\x83\x91\x83\x01\x82\x82\x80\x15a/\xBBW` \x02\x82\x01\x91\x90_R` _ \x90[\x81T`\x01`\x01`\xA0\x1B\x03\x16\x81R`\x01\x90\x91\x01\x90` \x01\x80\x83\x11a/\x9DW[PPPPP\x90P\x93P\x93P\x93P\x93P\x91\x93P\x91\x93V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x0B\xCAWPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x0B\xCAV[`\nTc\xFF\xFF\xFF\xFF\x90\x81\x16\x90\x83\x16\x11\x15a0aW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FCallback gasLimit too high\0\0\0\0\0\0`D\x82\x01R`d\x01a\x0C V[\x80\x15a1\xDEW_\x81\x81R`\x03` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a0\x87\x81a;\nV[3_\x90\x81R`\x02` \x90\x81R`@\x80\x83 \x85\x84R\x80\x83R\x92\x81\x90 \x81Q``\x81\x01\x83R\x90T`\xFF\x81\x16\x15\x15\x80\x83R`\x01`\x01`@\x1B\x03a\x01\0\x83\x04\x81\x16\x95\x84\x01\x95\x90\x95R`\x01`H\x1B\x90\x91\x04\x90\x93\x16\x91\x81\x01\x91\x90\x91R\x90a14W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FNo active subscription for calle`D\x82\x01R`9`\xF9\x1B`d\x82\x01R`\x84\x01a\x0C V[\x80` \x01\x80Qa1C\x90aW:V[`\x01`\x01`@\x1B\x03\x16\x90R`@\x81\x01\x80Qa1]\x90aW:V[`\x01`\x01`@\x1B\x03\x90\x81\x16\x90\x91R_\x85\x81R` \x93\x84R`@\x90\x81\x90 \x83Q\x81T\x95\x85\x01Q\x92\x90\x94\x01Q\x83\x16`\x01`H\x1B\x02p\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\x19\x92\x90\x93\x16a\x01\0\x02h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x19\x94\x15\x15\x94\x90\x94\x16h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x95\x16\x94\x90\x94\x17\x92\x90\x92\x17\x91\x90\x91\x16\x17\x90UPPPV[_a1\xEF\x83c\xFF\xFF\xFF\xFF\x16:a3\xDBV[\x90P\x804\x10\x15a\x0FaW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01RjFee too low`\xA8\x1B`D\x82\x01R`d\x01a\x0C V[`\x01T`@Qc\xF8\x7F\x0Ea`\xE0\x1B\x81R_\x91`\x01`\x01`\xA0\x1B\x03\x16\x90c\xF8\x7F\x0Ea\x90a2c\x90\x87\x90\x87\x90\x87\x90`\x04\x01aWdV[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a2\x7FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1C\x87\x91\x90aW\x9CV[_\x81\x81R`\x03` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a2\xC3\x81a;\nV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x16kW`@QclQ\xFD\xA9`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x01a\x0C V[`\x02_T\x03a3\x19W`@Qc>\xE5\xAE\xB5`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_UV[_a3)\x83a?FV[\x90Pa3>\x82\x82`\x01`\x01``\x1B\x03\x16a8\xF7V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R`\x01`\x01``\x1B\x03\x83\x16` \x82\x01R\x84\x91\x7F7\x84\xF7~\x8E\x88=\xE9[]G\xCDq<\xED\x01\"\x9F\xA7M\x11\x8C\nF\"$\xBC\xB0QmC\xF1\x91\x01`@Q\x80\x91\x03\x90\xA2PPPV[a\x16\xFC\x813a@\x97V[__Q` aZ5_9_Q\x90_R\x81a3\xB3\x85\x85a@\xD0V[\x90P\x80\x15a\x1C\x87W_\x85\x81R` \x83\x90R`@\x90 a3\xD2\x90\x85aAqV[P\x94\x93PPPPV[`@\x80Q`\xE0\x81\x01\x82R`\nTc\xFF\xFF\xFF\xFF\x80\x82\x16\x83Rd\x01\0\0\0\0\x82\x04\x81\x16` \x84\x01R`\x01`@\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01``\x1B\x81\x04\x83\x16``\x83\x01R`\x01`\x80\x1B\x81\x04\x83\x16`\x80\x83\x01R`\xFF`\x01`\xA0\x1B\x82\x04\x16`\xA0\x83\x01R`\x01`\xA8\x1B\x90\x04\x90\x91\x16`\xC0\x82\x01R_\x90\x81\x83a4cW\x81``\x01Qc\xFF\xFF\xFF\xFF\x16a4eV[\x83[\x90P_a4q\x86aA\x85V[c\xFF\xFF\xFF\xFF\x16\x83`\x80\x01Qc\xFF\xFF\xFF\xFF\x16\x87\x85` \x01Qc\xFF\xFF\xFF\xFF\x16\x01\x01\x01\x82\x02\x90P_a4\x9D_\x90V[\x90P_\x84`\xA0\x01Q`d\x01`\xFF\x16\x90P_\x85`@\x01Qc\xFF\xFF\xFF\xFF\x16d\xE8\xD4\xA5\x10\0\x02\x90P_\x81`d\x84\x87\x87\x01\x02\x81a4\xD8Wa4\xD8aW\xB3V[\x04\x01\x9A\x99PPPPPPPPPPV[__Q` aZ5_9_Q\x90_R\x81a5\x02\x85\x85aA\x9CV[\x90P\x80\x15a\x1C\x87W_\x85\x81R` \x83\x90R`@\x90 a3\xD2\x90\x85aB\x15V[_\x80\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0a\x0B\xCAV[a5QaB)V[V[`@\x80Q\x80\x82\x01\x82R`\x10\x81Ro\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B` \x82\x01R\x81Q`B\x80\x82R`\x80\x82\x01\x90\x93R``\x92_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P`\x03`\xFC\x1B\x81_\x81Q\x81\x10a5\xB3Wa5\xB3aT\xCAV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a5\xE1Wa5\xE1aT\xCAV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP_[` \x81\x10\x15a7\x12W\x82`\x04\x86\x83` \x81\x10a6\x17Wa6\x17aT\xCAV[\x1A`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x1C`\xF8\x1C`\xFF\x16\x81Q\x81\x10a6=Wa6=aT\xCAV[\x01` \x01Q`\x01`\x01`\xF8\x1B\x03\x19\x16\x82a6X\x83`\x02aW\xC7V[a6c\x90`\x02aV3V[\x81Q\x81\x10a6sWa6saT\xCAV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP\x82\x85\x82` \x81\x10a6\x9CWa6\x9CaT\xCAV[\x82Q\x91\x90\x1A`\x0F\x16\x90\x81\x10a6\xB3Wa6\xB3aT\xCAV[\x01` \x01Q`\x01`\x01`\xF8\x1B\x03\x19\x16\x82a6\xCE\x83`\x02aW\xC7V[a6\xD9\x90`\x02aV3V[a6\xE4\x90`\x01aV3V[\x81Q\x81\x10a6\xF4Wa6\xF4aT\xCAV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x01\x01a5\xF9V[P\x93\x92PPPV[0`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14\x80a7\xA0WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16a7\x94_Q` aZU_9_Q\x90_RT`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x14\x15[\x15a5QW`@Qcp>F\xDD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x16\xFC_Q` aZ\x95_9_Q\x90_Ra3\x8FV[\x81`\x01`\x01`\xA0\x1B\x03\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a8.WP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra8+\x91\x81\x01\x90aW\x9CV[`\x01[a8VW`@QcL\x9C\x8C\xE3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x0C V[_Q` aZU_9_Q\x90_R\x81\x14a8\x86W`@Qc*\x87Ri`\xE2\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x0C V[a\x0Fa\x83\x83aBNV[0`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a5QW`@Qcp>F\xDD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80a\x16\xFCW`@Qc\x1E\x9A\xCF\x17`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82`\x01`\x01`\xA0\x1B\x03\x16\x82`@Q_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a9@W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a9EV[``\x91P[PP\x90P\x80a\x0FaW`@Qc\x95\x0B$y`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_Z_\x85\x81R`\x10` R`@\x81 `\x03\x81\x01T\x92\x93P\x91\x90\x03a9\xCDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FNo request for request id\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x0C V[_c]\x94\x18\x02`\xE0\x1B\x86\x86`@Q`$\x01a9\xE9\x92\x91\x90aW\xDEV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16`\x01`\x01`\xE0\x1B\x03\x19\x90\x93\x16\x92\x90\x92\x17\x90\x91R`\r\x83\x01T`\x02\x84\x01T`\nT\x92\x93P_\x92a:Y\x92\x85\x92`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x91c\xFF\xFF\xFF\xFF\x91\x82\x16\x91`\x01`\xA8\x1B\x90\x91\x04\x81\x16\x90aB\xA3\x16V[P\x90P\x80\x15a:\xCAW`\x0C\x83\x01a:p\x87\x82aS\xDBV[P`\x0B\x83\x01a:\x7F\x86\x82aS\xDBV[P\x86\x7F\x99\xFD\x15\x97L\xBF\0\xF0\xF2\x08\xBA\xAEZ(%\xFAsc\x97\xEA\xC7\xE2\xBA0\x03\xC8'C\x8C\xA0\x93\xF7\x84`\x04\x01\x85`\x05\x01\x86`\x0C\x01`@Qa:\xBD\x93\x92\x91\x90aX\x97V[`@Q\x80\x91\x03\x90\xA2a:\xF5V[`@Q\x87\x90\x7F\x15\x0856Pvf\x80,\xBD\x84\xFC\xC1\xE3~\xD8\x98y\xBA\xD24Z\xAA8\xD4\x8D\x91\xA5\x07\x1D\x0F]\x90_\x90\xA2[a\x166\x87\x85aB\xDAV[_a\x10\xF3\x83\x83aC\xC9V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x16\xFCW`@Qc\x0F\xB52\xDB`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x10\xF3\x83\x83aC\xEFV[``_a\x10\xF3\x83aD;V[_a\x0B\xCA\x82T\x90V[\x82Q``\x90`\xFF\x81\x11\x15a;zW\x84`@Qc\x13r|\xDD`\xE1\x1B\x81R`\x04\x01a\x0C \x91\x90aK\xD1V[`@\x80Q`\x88\x80\x82R`\xC0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_\x81\x86_\x87_\x8B\x88`@Q` \x01a;\xB9\x97\x96\x95\x94\x93\x92\x91\x90aY\x0CV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P_\x81\x80Q\x90` \x01 \x90P_\x81`\x01\x8A\x87`@Q` \x01a;\xEE\x94\x93\x92\x91\x90aYvV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x82\x01 \x90\x91P_`\xFF\x89\x16`\x01`\x01`@\x1B\x03\x81\x11\x15a<$Wa<$aI\xEFV[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a<NW` \x82\x01\x81\x806\x837\x01\x90P[P\x90P_`\x05a<b`\x1F`\xFF\x8D\x16aV3V[\x90\x1C\x90P`\x01[\x81\x81\x10\x15a<\xC8W\x85\x84\x18a<\x7F\x82`\x01aV3V[\x8E\x8B`@Q` \x01a<\x94\x94\x93\x92\x91\x90aYvV[`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x91\x90R` _\x19\x83\x01\x81\x02\x85\x01\x81\x01\x95\x90\x95R\x80Q\x94\x81\x01\x94\x90\x94 \x93\x94P`\x01\x01a<iV[P_\x19\x01` \x90\x81\x02\x82\x01\x01\x91\x90\x91R\x95PPPPPP\x93\x92PPPV[__a<\xF4\x84\x84`0a;QV[`\x18\x81\x01Q`0\x82\x01Q\x91\x92P`\x01`\x01`\xC0\x1B\x03\x91\x82\x16\x91\x16_\x7F0dNr\xE11\xA0)\xB8PE\xB6\x81\x81X]\x97\x81j\x91hq\xCA\x8D< \x8C\x16\xD8|\xFDG\x83\x81`\x01`\xC0\x1B\x85\t\x08\x97\x96PPPPPPPV[`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01Ra=`aH\xDFV[`\x01\x81R`\x02` \x82\x01R`@\x81\x01\x83\x90R_``\x83`\x80\x84`\x07a\x07\xD0Z\x03\xFA\x90P\x80a=\xD0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FG1 scalar multiplication failed\0`D\x82\x01R`d\x01a\x0C V[PP\x91\x90PV[___`@Q\x80a\x01\x80\x01`@R\x80\x86_\x01Q\x81R` \x01\x86` \x01Q\x81R` \x01\x7F\x19\x8E\x93\x93\x92\rH:r`\xBF\xB71\xFB]%\xF1\xAAI35\xA9\xE7\x12\x97\xE4\x85\xB7\xAE\xF3\x12\xC2\x81R` \x01\x7F\x18\0\xDE\xEF\x12\x1F\x1EvBj\0f^\\DygC\"\xD4\xF7^\xDA\xDDF\xDE\xBD\\\xD9\x92\xF6\xED\x81R` \x01\x7F']\xC4\xA2\x88\xD1\xAF\xB3\xCB\xB1\xAC\t\x18u$\xC7\xDB69]\xF7\xBE;\x99\xE6s\xB1:\x07Ze\xEC\x81R` \x01\x7F\x1D\x9B\xEF\xCD\x05\xA52>m\xA4\xD45\xF3\xB6\x17\xCD\xB3\xAF\x83(\\-\xF7\x11\xEF9\xC0\x15q\x82\x7F\x9D\x81R` \x01`\x01\x81R` \x01`\x02\x81R` \x01\x85_\x01Q`\x01`\x02\x81\x10a>\xB5Wa>\xB5aT\xCAV[` \x02\x01Q\x81R` \x01\x85_\x01Q_`\x02\x81\x10a>\xD4Wa>\xD4aT\xCAV[` \x02\x01Q\x81R` \x01\x85` \x01Q`\x01`\x02\x81\x10a>\xF5Wa>\xF5aT\xCAV[` \x02\x01Q\x81R` \x01\x85` \x01Q_`\x02\x81\x10a?\x15Wa?\x15aT\xCAV[` \x02\x01Q\x90R\x90Pa?&aH\xFDV[` \x81a\x01\x80\x84`\x08a\x07\xD0Z\x03\xFA\x90Q\x15\x15\x93P\x91PP[\x92P\x92\x90PV[_\x81\x81R`\x03` \x90\x81R`@\x80\x83 `\x04\x90\x92R\x82 T`\x02\x90\x91\x01\x80T`\x01`\x01``\x1B\x03\x90\x92\x16\x92\x90\x91\x90[\x81\x81\x10\x15a?\xE0W`\x02_\x84\x83\x81T\x81\x10a?\x92Wa?\x92aT\xCAV[_\x91\x82R` \x80\x83 \x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16\x83R\x82\x81\x01\x93\x90\x93R`@\x91\x82\x01\x81 \x88\x82R\x90\x92R\x90 \x80Tp\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90U`\x01\x01a?uV[P_\x84\x81R`\x03` R`@\x81 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16\x82U`\x01\x82\x01\x80T\x90\x91\x16\x90U\x90a@\x17`\x02\x83\x01\x82aI\x1BV[PP_\x84\x81R`\x04` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90Ua@?`\x06\x85aD\x94V[P`\x01`\x01``\x1B\x03\x83\x16\x15a=\xD0W`\x08\x80T\x84\x91\x90_\x90a@l\x90\x84\x90`\x01`\x01``\x1B\x03\x16aVxV[\x92Pa\x01\0\n\x81T\x81`\x01`\x01``\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01``\x1B\x03\x16\x02\x17\x90UPPP\x91\x90PV[a@\xA1\x82\x82a\x1C\x8FV[a\x16kW`@Qc\xE2Q}?`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x81\x01\x83\x90R`D\x01a\x0C V[__Q` aZu_9_Q\x90_Ra@\xE9\x84\x84a\x1C\x8FV[aAhW_\x84\x81R` \x82\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90UaA\x1E3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x85\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4`\x01\x91PPa\x0B\xCAV[_\x91PPa\x0B\xCAV[_a\x10\xF3\x83`\x01`\x01`\xA0\x1B\x03\x84\x16aC\xEFV[_aA\x91`?\x83aY\xB9V[a\x0B\xCA\x90`\x01aY\xECV[__Q` aZu_9_Q\x90_RaA\xB5\x84\x84a\x1C\x8FV[\x15aAhW_\x84\x81R` \x82\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x87\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4`\x01\x91PPa\x0B\xCAV[_a\x10\xF3\x83`\x01`\x01`\xA0\x1B\x03\x84\x16aD\x9BV[aB1aEuV[a5QW`@Qc\x1A\xFC\xD7\x9F`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aBW\x82aE\x8EV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2\x80Q\x15aB\x9BWa\x0Fa\x82\x82aE\xF1V[a\x16kaFcV[__Z\x83\x81\x10aB\xD0W\x83\x90\x03`@\x81\x04\x81\x03\x85\x10\x15aB\xD0W__\x88Q` \x8A\x01_\x8A\x8A\xF1\x92P`\x01\x91P[P\x94P\x94\x92PPPV[_aB\xE4\x83a#\x9BV[\x80Q\x90\x91P\x15aC\xB8W\x80Q_\x90\x81R`\x04` R`@\x90 \x80T`\x0C\x90aC\x1B\x90`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16aW:V[\x82T`\x01`\x01`@\x1B\x03\x91\x82\x16a\x01\0\x93\x84\n\x90\x81\x02\x90\x83\x02\x19\x90\x91\x16\x17\x90\x92U\x82\x01Q`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x02` \x90\x81R`@\x80\x83 \x85Q\x84R\x90\x91R\x90 \x80T\x90\x91`\t\x91aCz\x91`\x01`H\x1B\x90\x91\x04\x16aZ\x08V[\x91\x90a\x01\0\n\x81T\x81`\x01`\x01`@\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`@\x1B\x03\x16\x02\x17\x90UP_aC\xA9\x83:aF\x82V[\x90Pa\x10\xDC\x81\x83_\x01QaF\xDAV[a\x0Fa\x81` \x01Q\x82_\x01QaF\xDAV[_\x82_\x01\x82\x81T\x81\x10aC\xDEWaC\xDEaT\xCAV[\x90_R` _ \x01T\x90P\x92\x91PPV[_\x81\x81R`\x01\x83\x01` R`@\x81 TaD4WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x0B\xCAV[P_a\x0B\xCAV[``\x81_\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15aD\x88W` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11aDtW[PPPPP\x90P\x91\x90PV[_a\x10\xF3\x83\x83[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15aAhW_aD\xBD`\x01\x83aVFV[\x85T\x90\x91P_\x90aD\xD0\x90`\x01\x90aVFV[\x90P\x80\x82\x14aE/W_\x86_\x01\x82\x81T\x81\x10aD\xEEWaD\xEEaT\xCAV[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10aE\x0EWaE\x0EaT\xCAV[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80aE@WaE@aW\x07V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\x0B\xCAV[_aE~a5!V[T`\x01`@\x1B\x90\x04`\xFF\x16\x91\x90PV[\x80`\x01`\x01`\xA0\x1B\x03\x16;_\x03aE\xC3W`@QcL\x9C\x8C\xE3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x01a\x0C V[_Q` aZU_9_Q\x90_R\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[``__\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@QaF\r\x91\x90aZ)V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aFEW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aFJV[``\x91P[P\x91P\x91PaFZ\x85\x83\x83aGwV[\x95\x94PPPPPV[4\x15a5QW`@Qc\xB3\x98\x97\x9F`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[__Z`\nTd\x01\0\0\0\0\x90\x04c\xFF\xFF\xFF\xFF\x16\x85\x01\x03\x90P\x82\x81\x02_`\nT`d\x91\x90\x92\x01`\xFF`\x01`\xA0\x1B\x84\x04\x16\x82\x01\x02\x04d\xE8\xD4\xA5\x10\0c\xFF\xFF\xFF\xFF`\x01`@\x1B\x90\x93\x04\x92\x90\x92\x16\x91\x90\x91\x02\x01\x94\x93PPPPV[\x80\x15aG@W_\x81\x81R`\x04` R`@\x90 \x80T`\x01`\x01``\x1B\x03\x90\x81\x16\x90aG\t\x90\x85\x16\x82\x10\x15a8\xD9V[\x81T`\x01`\x01``\x1B\x03\x91\x85\x90\x03\x82\x16`\x01`\x01``\x1B\x03\x19\x91\x82\x16\x17\x90\x92U`\t\x80T\x80\x83\x16\x86\x01\x90\x92\x16\x91\x90\x92\x16\x17\x90UPPV[`\x08\x80T`\x01`\x01``\x1B\x03`\x01``\x1B\x80\x83\x04\x82\x16\x86\x01\x90\x91\x16\x02k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x1B\x19\x90\x91\x16\x17\x90UPPV[``\x82aG\x8CWaG\x87\x82aG\xD3V[a\x10\xF3V[\x81Q\x15\x80\x15aG\xA3WP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15aG\xCCW`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\x0C V[P\x80a\x10\xF3V[\x80Q\x15aG\xE3W\x80Q\x80\x82` \x01\xFD[`@Qc\xD6\xBD\xA2u`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82`\x02\x81\x01\x92\x82\x15aH*W\x91` \x02\x82\x01[\x82\x81\x11\x15aH*W\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90aH\x0FV[PaH6\x92\x91PaI2V[P\x90V[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15aH*W\x91` \x02\x82\x01[\x82\x81\x11\x15aH*W\x82Q\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x17\x82U` \x90\x92\x01\x91`\x01\x90\x91\x01\x90aHXV[`@Q\x80a\x01 \x01`@R\x80_\x81R` \x01_\x81R` \x01_c\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81R` \x01``\x81R` \x01aH\xC6aIFV[\x81R``` \x82\x01\x81\x90R`@\x82\x01\x81\x90R_\x91\x01R\x90V[`@Q\x80``\x01`@R\x80`\x03\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80` \x01`@R\x80`\x01\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x16\xFC\x91\x90[[\x80\x82\x11\x15aH6W_\x81U`\x01\x01aI3V[`@Q\x80``\x01`@R\x80aIYaImV[\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Q\x80`@\x01`@R\x80aI\x80aI\x92V[\x81R` \x01aI\x8DaI\x92V[\x90R\x90V[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[_` \x82\x84\x03\x12\x15aI\xC0W__\xFD[\x815`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\x10\xF3W__\xFD[\x805c\xFF\xFF\xFF\xFF\x81\x16\x81\x14aI\xEAW__\xFD[\x91\x90PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@\x80Q\x90\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15aJ%WaJ%aI\xEFV[`@R\x90V[_\x82`\x1F\x83\x01\x12aJ:W__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15aJSWaJSaI\xEFV[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15aJ\x81WaJ\x81aI\xEFV[`@R\x81\x81R\x83\x82\x01` \x01\x85\x10\x15aJ\x98W__\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[_`\xC0\x82\x84\x03\x12\x15aJ\xC4W__\xFD[P\x91\x90PV[____`\x80\x85\x87\x03\x12\x15aJ\xDDW__\xFD[aJ\xE6\x85aI\xD7V[\x93P` \x85\x015\x92P`@\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aK\x07W__\xFD[aK\x13\x87\x82\x88\x01aJ+V[\x92PP``\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aK.W__\xFD[aK:\x87\x82\x88\x01aJ\xB4V[\x91PP\x92\x95\x91\x94P\x92PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x16\xFCW__\xFD[__`@\x83\x85\x03\x12\x15aKkW__\xFD[\x825\x91P` \x83\x015aK}\x81aKFV[\x80\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15aK\x98W__\xFD[\x815a\x10\xF3\x81aKFV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x10\xF3` \x83\x01\x84aK\xA3V[_` \x82\x84\x03\x12\x15aK\xF3W__\xFD[P5\x91\x90PV[__`@\x83\x85\x03\x12\x15aL\x0BW__\xFD[aL\x14\x83aI\xD7V[\x94` \x93\x90\x93\x015\x93PPPV[_______`\xE0\x88\x8A\x03\x12\x15aL8W__\xFD[aLA\x88aI\xD7V[\x96PaLO` \x89\x01aI\xD7V[\x95PaL]`@\x89\x01aI\xD7V[\x94PaLk``\x89\x01aI\xD7V[\x93PaLy`\x80\x89\x01aI\xD7V[\x92P`\xA0\x88\x015`\xFF\x81\x16\x81\x14aL\x8EW__\xFD[\x91PaL\x9C`\xC0\x89\x01aI\xD7V[\x90P\x92\x95\x98\x91\x94\x97P\x92\x95PV[__`@\x83\x85\x03\x12\x15aL\xBBW__\xFD[\x825aL\xC6\x81aKFV[\x91P` \x83\x015aK}\x81aKFV[_` \x82\x84\x03\x12\x15aL\xE6W__\xFD[a\x10\xF3\x82aI\xD7V[__`@\x83\x85\x03\x12\x15aM\0W__\xFD[\x825aM\x0B\x81aKFV[\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aM%W__\xFD[aM1\x85\x82\x86\x01aJ+V[\x91PP\x92P\x92\x90PV[__\x83`\x1F\x84\x01\x12aMKW__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15aMaW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a??W__\xFD[_____``\x86\x88\x03\x12\x15aM\x8CW__\xFD[\x855\x94P` \x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aM\xA8W__\xFD[aM\xB4\x88\x82\x89\x01aM;V[\x90\x95P\x93PP`@\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aM\xD2W__\xFD[aM\xDE\x88\x82\x89\x01aM;V[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[\x80_[`\x02\x81\x10\x15a\x10\xDCW\x81Q\x84R` \x93\x84\x01\x93\x90\x91\x01\x90`\x01\x01aM\xF2V[_\x81QaN\x1F\x84\x82QaM\xEFV[` \x01QaN0`@\x85\x01\x82aM\xEFV[P` \x82\x01Q`\xC0`\x80\x85\x01RaNJ`\xC0\x85\x01\x82aK\xA3V[\x90P`@\x83\x01Q\x84\x82\x03`\xA0\x86\x01RaFZ\x82\x82aK\xA3V[\x89\x81R\x88` \x82\x01Rc\xFF\xFF\xFF\xFF\x88\x16`@\x82\x01R\x86``\x82\x01Ra\x01 `\x80\x82\x01R_aN\x95a\x01 \x83\x01\x88aK\xA3V[\x82\x81\x03`\xA0\x84\x01RaN\xA7\x81\x88aN\x11V[\x90P\x82\x81\x03`\xC0\x84\x01RaN\xBB\x81\x87aK\xA3V[\x90P\x82\x81\x03`\xE0\x84\x01RaN\xCF\x81\x86aK\xA3V[\x91PP`\x01\x80`\xA0\x1B\x03\x83\x16a\x01\0\x83\x01R\x9A\x99PPPPPPPPPPV[____``\x85\x87\x03\x12\x15aO\x02W__\xFD[aO\x0B\x85aI\xD7V[\x93P` \x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aO%W__\xFD[aO1\x87\x82\x88\x01aM;V[\x90\x94P\x92PP`@\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aK.W__\xFD[__`@\x83\x85\x03\x12\x15aO`W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15aO\xA8W\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01aO\x81V[P\x93\x94\x93PPPPV[` \x81R_a\x10\xF3` \x83\x01\x84aOoV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15aO\xFBW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01aO\xDDV[P\x90\x95\x94PPPPPV[` \x81R\x81Q` \x82\x01R` \x82\x01Q`@\x82\x01R_`@\x83\x01QaP3``\x84\x01\x82c\xFF\xFF\xFF\xFF\x16\x90RV[P``\x83\x01Q`\x80\x83\x01R`\x80\x83\x01Qa\x01 `\xA0\x84\x01RaPYa\x01@\x84\x01\x82aK\xA3V[\x90P`\xA0\x84\x01Q`\x1F\x19\x84\x83\x03\x01`\xC0\x85\x01RaPv\x82\x82aN\x11V[\x91PP`\xC0\x84\x01Q`\x1F\x19\x84\x83\x03\x01`\xE0\x85\x01RaP\x94\x82\x82aK\xA3V[\x91PP`\xE0\x84\x01Q`\x1F\x19\x84\x83\x03\x01a\x01\0\x85\x01RaP\xB3\x82\x82aK\xA3V[\x91PPa\x01\0\x84\x01Qa7\x12a\x01 \x85\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[___`@\x84\x86\x03\x12\x15aP\xE4W__\xFD[\x835`\x01`\x01`@\x1B\x03\x81\x11\x15aP\xF9W__\xFD[aQ\x05\x86\x82\x87\x01aJ\xB4V[\x93PP` \x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aQ W__\xFD[aQ,\x86\x82\x87\x01aM;V[\x94\x97\x90\x96P\x93\x94PPPPV[`\x01`\x01``\x1B\x03\x85\x16\x81R`\x01`\x01`@\x1B\x03\x84\x16` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16`@\x82\x01R`\x80``\x82\x01\x81\x90R_\x90a\x1CX\x90\x83\x01\x84aOoV[__\x835`\x1E\x19\x846\x03\x01\x81\x12aQ\x8FW__\xFD[\x83\x01` \x81\x01\x92P5\x90P`\x01`\x01`@\x1B\x03\x81\x11\x15aQ\xADW__\xFD[\x806\x03\x82\x13\x15a??W__\xFD[\x81\x83R\x81\x81` \x85\x017P_\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1F\x90\x91\x01`\x1F\x19\x16\x90\x91\x01\x01\x90V[`@\x81\x837`@\x80\x82\x01`@\x84\x017_aR\0`\x80\x83\x01\x83aQzV[`\xC0`\x80\x86\x01RaR\x15`\xC0\x86\x01\x82\x84aQ\xBBV[\x91PPaR%`\xA0\x84\x01\x84aQzV[\x85\x83\x03`\xA0\x87\x01Ra\x1CX\x83\x82\x84aQ\xBBV[` \x81R_a\x10\xF3` \x83\x01\x84aQ\xE3V[_\x82`\x1F\x83\x01\x12aRYW__\xFD[aRaaJ\x03V[\x80`@\x84\x01\x85\x81\x11\x15aRrW__\xFD[\x84[\x81\x81\x10\x15aO\xFBW\x805\x84R` \x93\x84\x01\x93\x01aRtV[_`\x80\x82\x84\x03\x12\x15aR\x9CW__\xFD[aR\xA4aJ\x03V[\x90PaR\xB0\x83\x83aRJV[\x81RaR\xBF\x83`@\x84\x01aRJV[` \x82\x01R\x92\x91PPV[_`\xC0\x826\x03\x12\x15aR\xDAW__\xFD[`@Q``\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15aR\xFCWaR\xFCaI\xEFV[`@RaS\t6\x84aR\x8CV[\x81R`\x80\x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aS#W__\xFD[aS/6\x82\x86\x01aJ+V[` \x83\x01RP`\xA0\x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aSMW__\xFD[aSY6\x82\x86\x01aJ+V[`@\x83\x01RP\x92\x91PPV[`\x01\x81\x81\x1C\x90\x82\x16\x80aSyW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03aJ\xC4WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[`\x1F\x82\x11\x15a\x0FaW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15aS\xBCWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x17\xCBW_\x81U`\x01\x01aS\xC8V[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15aS\xF4WaS\xF4aI\xEFV[aT\x08\x81aT\x02\x84TaSeV[\x84aS\x97V[` `\x1F\x82\x11`\x01\x81\x14aT:W_\x83\x15aT#WP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x17\xCBV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15aTiW\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01aTIV[P\x84\x82\x10\x15aT\x86W\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[``\x81R_aT\xA7``\x83\x01\x86aK\xA3V[\x82\x81\x03` \x84\x01RaT\xB9\x81\x86aQ\xE3V[\x91PP\x82`@\x83\x01R\x94\x93PPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x7FBLOCKLOCK_BN254G1_XMD:KECCAK-256\x81Rk_SVDW_RO_H1_`\xA0\x1B` \x82\x01R_aU;`,\x83\x01\x84aT\xDEV[`_`\xF8\x1B\x81R`\x01\x01\x93\x92PPPV[\x7FBLOCKLOCK_BN254_XMD:KECCAK-256_H\x81Ra2_`\xF0\x1B` \x82\x01R_aU;`\"\x83\x01\x84aT\xDEV[\x7FBLOCKLOCK_BN254_XMD:KECCAK-256_H\x81Ra3_`\xF0\x1B` \x82\x01R_aU;`\"\x83\x01\x84aT\xDEV[\x7FBLOCKLOCK_BN254_XMD:KECCAK-256_H\x81Ra4_`\xF0\x1B` \x82\x01R_aU;`\"\x83\x01\x84aT\xDEV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[`\x01`\x01``\x1B\x03\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[\x80\x82\x01\x80\x82\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[\x81\x81\x03\x81\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[`\x01`\x01`@\x1B\x03\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[`\x01`\x01``\x1B\x03\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[__\x835`\x1E\x19\x846\x03\x01\x81\x12aV\xACW__\xFD[\x83\x01\x805\x91P`\x01`\x01`@\x1B\x03\x82\x11\x15aV\xC5W__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15a??W__\xFD[_a\x1C\x87aV\xE7\x83\x86aT\xDEV[\x84aT\xDEV[_`\x80\x82\x84\x03\x12\x15aV\xFDW__\xFD[a\x10\xF3\x83\x83aR\x8CV[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15aW+W__\xFD[\x81Q\x80\x15\x15\x81\x14a\x10\xF3W__\xFD[_`\x01`\x01`@\x1B\x03\x82\x16`\x01`\x01`@\x1B\x03\x81\x03aW[WaW[aV\0V[`\x01\x01\x92\x91PPV[``\x81R_aWv``\x83\x01\x86aK\xA3V[\x82\x81\x03` \x84\x01RaW\x88\x81\x86aK\xA3V[\x90P\x82\x81\x03`@\x84\x01Ra\x1CX\x81\x85aK\xA3V[_` \x82\x84\x03\x12\x15aW\xACW__\xFD[PQ\x91\x90PV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x0B\xCAWa\x0B\xCAaV\0V[\x82\x81R`@` \x82\x01R_a\x1C\x87`@\x83\x01\x84aK\xA3V[_\x81TaX\x02\x81aSeV[\x80\x85R`\x01\x82\x16\x80\x15aX\x1CW`\x01\x81\x14aX8WaXlV[`\xFF\x19\x83\x16` \x87\x01R` \x82\x15\x15`\x05\x1B\x87\x01\x01\x93PaXlV[\x84_R` _ _[\x83\x81\x10\x15aXcW\x81T` \x82\x8A\x01\x01R`\x01\x82\x01\x91P` \x81\x01\x90PaXAV[\x87\x01` \x01\x94PP[PPP\x92\x91PPV[\x80_[`\x02\x81\x10\x15a\x10\xDCW\x81T\x84R` \x90\x93\x01\x92`\x01\x91\x82\x01\x91\x01aXxV[``\x81R_aX\xA9``\x83\x01\x86aW\xF6V[\x82\x81\x03` \x84\x01RaX\xBB\x81\x86aXuV[aX\xCB`@\x82\x01`\x02\x87\x01aXuV[`\xC0`\x80\x82\x01RaX\xE2`\xC0\x82\x01`\x04\x87\x01aW\xF6V[\x81\x81\x03`\xA0\x83\x01RaX\xF7\x81`\x05\x88\x01aW\xF6V[\x91PP\x82\x81\x03`@\x84\x01Ra\x1CX\x81\x85aW\xF6V[_aY aY\x1A\x83\x8BaT\xDEV[\x89aT\xDEV[`\x01`\x01`\xF8\x1B\x03\x19`\xF8\x89\x81\x1B\x82\x16\x83R\x88\x81\x1B\x82\x16`\x01\x84\x01R\x87\x90\x1B\x16`\x02\x82\x01RaYR`\x03\x82\x01\x86aT\xDEV[`\xF8\x94\x90\x94\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x84RPP`\x01\x90\x91\x01\x97\x96PPPPPPPV[\x84\x81R`\xF8\x84\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x82\x01R_aY\x9B`!\x83\x01\x85aT\xDEV[`\xF8\x93\x90\x93\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x83RPP`\x01\x01\x93\x92PPPV[_c\xFF\xFF\xFF\xFF\x83\x16\x80aY\xDAWcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[\x80c\xFF\xFF\xFF\xFF\x84\x16\x04\x91PP\x92\x91PPV[c\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[_`\x01`\x01`@\x1B\x03\x82\x16\x80aZ WaZ aV\0V[_\x19\x01\x92\x91PPV[_a\x10\xF3\x82\x84aT\xDEV\xFE\xC1\xF6\xFE$b\x1C\xE8\x1E\xC5\x82|\xAF\x02S\xCA\xDBtp\x9B\x06\x160\xE6\xB5^\x827\x17\x05\x93 \x006\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610371575f3560e01c80637350f456116101c8578063aa433aff116100fd578063c58343ef1161009d578063cd802c911161006d578063cd802c9114610b1a578063d547741f14610b39578063dac83d2914610b58578063dc311dd314610b77575f5ffd5b8063c58343ef14610a91578063c9bc18c414610abd578063ca15c87314610adc578063cb63179714610afb575f5ffd5b8063b2a7cac5116100d8578063b2a7cac5146109da578063bd18636b146109f9578063bec4c08c14610a18578063c3f909d414610a37575f5ffd5b8063aa433aff1461095f578063ad3cb1cc1461097e578063aefb212f146109ae575f5ffd5b8063995cb36e11610168578063a21a23e411610143578063a21a23e4146108ed578063a3246ad314610901578063a3907d711461092d578063a608a1e114610941575f5ffd5b8063995cb36e146108845780639d40a6fd146108a3578063a217fddf146108da575f5ffd5b80638a1f165a116101a35780638a1f165a146107f55780639010d07c1461083357806391d148541461085257806395b55cfc14610871575f5ffd5b80637350f456146107ae57806375b238fc146107c25780637909dc7b146107e2575f5ffd5b806338c27d12116102a957806352d1902d116102495780635d3be001116102195780635d3be001146107205780635f7bda9f1461073f57806364d51a2a1461077357806367b276af1461079a575f5ffd5b806352d1902d146106a757806354236fb3146106bb57806354fd4d50146106da57806357a8070a14610707575f5ffd5b806345fa43541161028457806345fa435414610637578063485cc955146106565780634b160935146106755780634f1ef28614610694575f5ffd5b806338c27d12146105de5780633bc32c75146105f257806341af6c8714610618575f5ffd5b8063235296f7116103145780632f2ff15d116102ef5780632f2ff15d1461056f5780633255c4561461058e5780633408e470146105ad57806336568abe146105bf575f5ffd5b8063235296f71461051b578063248a9ca31461053c5780632f2770db1461055b575f5ffd5b80630ae095401161034f5780630ae095401461046d578063133c40c71461048e57806318e3dd27146104c55780631e6ba15b146104fc575f5ffd5b806301ffc9a714610375578063062b1d90146103a9578063088070f5146103ca575b5f5ffd5b348015610380575f5ffd5b5061039461038f3660046149b0565b610ba6565b60405190151581526020015b60405180910390f35b6103bc6103b7366004614aca565b610bd0565b6040519081526020016103a0565b3480156103d5575f5ffd5b50600a546104269063ffffffff808216916401000000008104821691600160401b8204811691600160601b8104821691600160801b820481169160ff600160a01b82041691600160a81b9091041687565b6040805163ffffffff988916815296881660208801529487169486019490945291851660608501528416608084015260ff1660a083015290911660c082015260e0016103a0565b348015610478575f5ffd5b5061048c610487366004614b5a565b610f15565b005b348015610499575f5ffd5b506001546104ad906001600160a01b031681565b6040516001600160a01b0390911681526020016103a0565b3480156104d0575f5ffd5b506008546104e4906001600160601b031681565b6040516001600160601b0390911681526020016103a0565b348015610507575f5ffd5b5061048c610516366004614b88565b610f66565b348015610526575f5ffd5b5061052f610fc5565b6040516103a09190614bd1565b348015610547575f5ffd5b506103bc610556366004614be3565b611051565b348015610566575f5ffd5b5061048c611071565b34801561057a575f5ffd5b5061048c610589366004614b5a565b6110c0565b348015610599575f5ffd5b506103bc6105a8366004614bfa565b6110e2565b3480156105b8575f5ffd5b50466103bc565b3480156105ca575f5ffd5b5061048c6105d9366004614b5a565b6110fa565b3480156105e9575f5ffd5b5061052f61112d565b3480156105fd575f5ffd5b506008546104e490600160601b90046001600160601b031681565b348015610623575f5ffd5b50610394610632366004614be3565b61113a565b348015610642575f5ffd5b5061048c610651366004614c22565b6111cf565b348015610661575f5ffd5b5061048c610670366004614caa565b6113ac565b348015610680575f5ffd5b506103bc61068f366004614cd6565b61163f565b61048c6106a2366004614cef565b611650565b3480156106b2575f5ffd5b506103bc61166f565b3480156106c6575f5ffd5b5061048c6106d5366004614b88565b61168b565b3480156106e5575f5ffd5b50604080518082019091526005815264302e302e3160d81b602082015261052f565b348015610712575f5ffd5b50600b546103949060ff1681565b34801561072b575f5ffd5b5061048c61073a366004614d78565b6116ff565b34801561074a575f5ffd5b5061075e610759366004614be3565b6117d2565b6040516103a099989796959493929190614e63565b34801561077e575f5ffd5b50610787606481565b60405161ffff90911681526020016103a0565b3480156107a5575f5ffd5b5061052f611b58565b3480156107b9575f5ffd5b5061052f611b65565b3480156107cd575f5ffd5b506103bc5f516020615a955f395f51905f5281565b6103bc6107f0366004614eef565b611b72565b348015610800575f5ffd5b5061052f60405180604001604052806013815260200172424e3235342d424c532d424c4f434b4c4f434b60681b81525081565b34801561083e575f5ffd5b506104ad61084d366004614f4f565b611c62565b34801561085d575f5ffd5b5061039461086c366004614b5a565b611c8f565b61048c61087f366004614be3565b611cc5565b34801561088f575f5ffd5b506009546104e4906001600160601b031681565b3480156108ae575f5ffd5b506005546108c2906001600160401b031681565b6040516001600160401b0390911681526020016103a0565b3480156108e5575f5ffd5b506103bc5f81565b3480156108f8575f5ffd5b506103bc611dd0565b34801561090c575f5ffd5b5061092061091b366004614be3565b611f7a565b6040516103a09190614fb2565b348015610938575f5ffd5b5061048c611fa3565b34801561094c575f5ffd5b50600b5461039490610100900460ff1681565b34801561096a575f5ffd5b5061048c610979366004614be3565b611fee565b348015610989575f5ffd5b5061052f604051806040016040528060058152602001640352e302e360dc1b81525081565b3480156109b9575f5ffd5b506109cd6109c8366004614f4f565b61202e565b6040516103a09190614fc4565b3480156109e5575f5ffd5b5061048c6109f4366004614be3565b612123565b348015610a04575f5ffd5b5061048c610a13366004614b88565b61220e565b348015610a23575f5ffd5b5061048c610a32366004614b5a565b6122a7565b348015610a42575f5ffd5b50600a5463ffffffff808216916401000000008104821691600160401b8204811691600160601b8104821691600160801b820481169160ff600160a01b82041691600160a81b90910416610426565b348015610a9c575f5ffd5b50610ab0610aab366004614be3565b61239b565b6040516103a09190615006565b348015610ac8575f5ffd5b5061052f610ad73660046150d2565b6127a0565b348015610ae7575f5ffd5b506103bc610af6366004614be3565b612bbe565b348015610b06575f5ffd5b5061048c610b15366004614b5a565b612be2565b348015610b25575f5ffd5b50610394610b34366004614be3565b612dce565b348015610b44575f5ffd5b5061048c610b53366004614b5a565b612e59565b348015610b63575f5ffd5b5061048c610b72366004614b5a565b612e75565b348015610b82575f5ffd5b50610b96610b91366004614be3565b612f12565b6040516103a09493929190615139565b5f6001600160e01b03198216635a05180f60e01b1480610bca5750610bca82612fd1565b92915050565b600b545f9060ff16610c295760405162461bcd60e51b815260206004820152601a60248201527f436f6e7472616374206973206e6f7420636f6e6669677572656400000000000060448201526064015b60405180910390fd5b600b54610100900460ff1615610c785760405162461bcd60e51b815260206004820152601460248201527310dbdb9d1c9858dd081a5cc8191a5cd8589b195960621b6044820152606401610c20565b83151580610c8557505f34115b610cf75760405162461bcd60e51b815260206004820152603860248201527f4469726563742066756e64696e6720726571756972656420666f72207265717560448201527f6573742066756c66696c6c6d656e742063616c6c6261636b00000000000000006064820152608401610c20565b610d018585613005565b5f610d5760405180604001604052806013815260200172424e3235342d424c532d424c4f434b4c4f434b60681b81525084604051602001610d429190615238565b6040516020818303038152906040528661322f565b90506040518061012001604052808681526020013481526020018763ffffffff16815260200182815260200185815260200184610d93906152ca565b815260408051602080820183525f808352818501929092528251808201845282815283850152336060948501528582526010815290829020845181559084015160018201559083015160028201805463ffffffff191663ffffffff90921691909117905590820151600382015560808201516004820190610e1490826153db565b5060a0820151805180516005840191908290610e3390829060026147fc565b506020820151610e4990600280840191906147fc565b50505060208201516004820190610e6090826153db565b5060408201516005820190610e7590826153db565b50505060c0820151600b820190610e8c90826153db565b5060e0820151600c820190610ea190826153db565b506101009190910151600d90910180546001600160a01b0319166001600160a01b03909216919091179055604051339082907fa7cf57609b4abed689b408db0b0c3dc6309786b6c07d5efbbd1d5b150e6d2c0690610f0490889088904290615495565b60405180910390a395945050505050565b81610f1f816132a3565b610f276132f7565b610f308361113a565b15610f4e57604051631685ecdd60e31b815260040160405180910390fd5b610f58838361331f565b610f6160015f55565b505050565b610f7c5f516020615a955f395f51905f5261338f565b600180546001600160a01b0319166001600160a01b0383169081179091556040517f0dae1d002e96c238ebe140ca1799f77093ae09e0bde40f79bb29ed78d09e652d905f90a250565b600c8054610fd290615365565b80601f0160208091040260200160405190810160405280929190818152602001828054610ffe90615365565b80156110495780601f1061102057610100808354040283529160200191611049565b820191905f5260205f20905b81548152906001019060200180831161102c57829003601f168201915b505050505081565b5f9081525f516020615a755f395f51905f52602052604090206001015490565b6110875f516020615a955f395f51905f5261338f565b600b805461ff0019166101001790556040517f75884cdadc4a89e8b545db800057f06ec7f5338a08183c7ba515f2bfdd9fe1e1905f90a1565b6110c982611051565b6110d28161338f565b6110dc8383613399565b50505050565b5f6110f38363ffffffff16836133db565b9392505050565b6001600160a01b03811633146111235760405163334bd91960e11b815260040160405180910390fd5b610f6182826134e8565b600d8054610fd290615365565b5f8181526003602052604081206002018054825b818110156111c5575f60025f85848154811061116c5761116c6154ca565b5f9182526020808320909101546001600160a01b0316835282810193909352604091820181208982529092529020546001600160401b03600160481b9091041611156111bd57506001949350505050565b60010161114e565b505f949350505050565b6111e55f516020615a955f395f51905f5261338f565b60ff8216609b116112385760405162461bcd60e51b815260206004820152601a60248201527f496e76616c6964205072656d69756d2050657263656e746167650000000000006044820152606401610c20565b6040805160e08101825263ffffffff89811680835289821660208401819052898316848601819052898416606086018190528985166080870181905260ff8a1660a0880181905295891660c0909701879052600a805467ffffffffffffffff1916909517640100000000909402939093176fffffffffffffffff00000000000000001916600160401b90920263ffffffff60601b191691909117600160601b9091021764ffffffffff60801b1916600160801b90910260ff60a01b191617600160a01b9092029190911763ffffffff60a81b1916600160a81b909202919091179055600b805460ff19166001179055517f55a28fde295f482c9f32d670c116103bca15724bcef4f18b35542e0553c35ad59061139b90899089908990899089908990899063ffffffff97881681529587166020870152938616604086015291851660608501528416608084015260ff1660a083015290911660c082015260e00190565b60405180910390a150505050505050565b5f6113b5613521565b805490915060ff600160401b82041615906001600160401b03165f811580156113db5750825b90505f826001600160401b031660011480156113f65750303b155b905081158015611404575080155b156114225760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561144c57845460ff60401b1916600160401b1785555b611454613549565b61145c613549565b6114735f516020615a955f395f51905f5288613399565b6114b35760405162461bcd60e51b815260206004820152601160248201527011dc985b9d081c9bdb194819985a5b1959607a1b6044820152606401610c20565b6114bd5f88613399565b6114fd5760405162461bcd60e51b815260206004820152601160248201527011dc985b9d081c9bdb194819985a5b1959607a1b6044820152606401610c20565b600180546001600160a01b0319166001600160a01b03881617905561152146613553565b60405160200161153191906154f5565b604051602081830303815290604052600c908161154e91906153db565b5061155846613553565b604051602001611568919061554c565b604051602081830303815290604052600d908161158591906153db565b5061158f46613553565b60405160200161159f9190615588565b604051602081830303815290604052600e90816115bc91906153db565b506115c646613553565b6040516020016115d691906155c4565b604051602081830303815290604052600f90816115f391906153db565b50831561163657845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200161139b565b50505050505050565b5f610bca8263ffffffff163a6133db565b61165861371a565b611661826137be565b61166b82826137d4565b5050565b5f611678613890565b505f516020615a555f395f51905f525b90565b6116936132f7565b6116a95f516020615a955f395f51905f5261338f565b600854600160601b90046001600160601b03166116c78115156138d9565b600880546bffffffffffffffffffffffff60601b191690556116f2826001600160601b0383166138f7565b506116fc60015f55565b50565b6001546001600160a01b031633146117595760405162461bcd60e51b815260206004820152601e60248201527f4f6e6c792044656372797074696f6e53656e6465722063616e2063616c6c00006044820152606401610c20565b6117cb8585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525050604080516020601f890181900481028201810190925287815292508791508690819084018382808284375f9201919091525061396792505050565b5050505050565b60106020525f9081526040902080546001820154600283015460038401546004850180549495939463ffffffff90931693919261180e90615365565b80601f016020809104026020016040519081016040528092919081815260200182805461183a90615365565b80156118855780601f1061185c57610100808354040283529160200191611885565b820191905f5260205f20905b81548152906001019060200180831161186857829003601f168201915b50506040805160e081019091529394939250506005830190508160608101828160a084018260028282826020028201915b8154815260200190600101908083116118b657505050918352505060408051808201918290526020909201919060028481019182845b8154815260200190600101908083116118ec57505050505081525050815260200160048201805461191c90615365565b80601f016020809104026020016040519081016040528092919081815260200182805461194890615365565b80156119935780601f1061196a57610100808354040283529160200191611993565b820191905f5260205f20905b81548152906001019060200180831161197657829003601f168201915b505050505081526020016005820180546119ac90615365565b80601f01602080910402602001604051908101604052809291908181526020018280546119d890615365565b8015611a235780601f106119fa57610100808354040283529160200191611a23565b820191905f5260205f20905b815481529060010190602001808311611a0657829003601f168201915b5050505050815250509080600b018054611a3c90615365565b80601f0160208091040260200160405190810160405280929190818152602001828054611a6890615365565b8015611ab35780601f10611a8a57610100808354040283529160200191611ab3565b820191905f5260205f20905b815481529060010190602001808311611a9657829003601f168201915b50505050509080600c018054611ac890615365565b80601f0160208091040260200160405190810160405280929190818152602001828054611af490615365565b8015611b3f5780601f10611b1657610100808354040283529160200191611b3f565b820191905f5260205f20905b815481529060010190602001808311611b2257829003601f168201915b505050600d90930154919250506001600160a01b031689565b600f8054610fd290615365565b600e8054610fd290615365565b600b545f9060ff16611bc65760405162461bcd60e51b815260206004820152601a60248201527f436f6e7472616374206973206e6f7420636f6e666967757265640000000000006044820152606401610c20565b600b54610100900460ff1615611c155760405162461bcd60e51b815260206004820152601460248201527310dbdb9d1c9858dd081a5cc8191a5cd8589b195960621b6044820152606401610c20565b5f611c58865f87878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250899250610bd0915050565b9695505050505050565b5f8281525f516020615a355f395f51905f52602081905260408220611c879084613aff565b949350505050565b5f9182525f516020615a755f395f51905f52602090815260408084206001600160a01b0393909316845291905290205460ff1690565b611ccd6132f7565b5f81815260036020526040902054611ced906001600160a01b0316613b0a565b5f81815260046020526040812080546001600160601b031691349190611d138385615614565b92506101000a8154816001600160601b0302191690836001600160601b031602179055503460085f8282829054906101000a90046001600160601b0316611d5a9190615614565b92506101000a8154816001600160601b0302191690836001600160601b03160217905550817f7603b205d03651ee812f803fccde89f1012e545a9c99f0abfea9cedd0fd8e902823484611dad9190615633565b604080519283526020830191909152015b60405180910390a2506116fc60015f55565b5f611dd96132f7565b6005546001600160401b031633611df1600143615646565b6040516001600160601b0319606093841b81166020830152914060348201523090921b1660548201526001600160c01b031960c083901b16606882015260700160408051601f1981840301815291905280516020909101209150611e56816001615659565b6005805467ffffffffffffffff19166001600160401b03928316179055604080515f808252606080830184526020808401838152848601848152898552600483528685209151825491516001600160601b039091166001600160a01b031992831617600160601b91909916029790971790558451918201855233825281810183815282860185815289855260038352959093208251815488166001600160a01b0391821617825593516001820180549098169416939093179095559251805192949192611f29926002850192019061483a565b50611f3991506006905084613b31565b5060405133815283907f1d3015d7ba850fa198dc7b1a3f5d42779313a681035f77c8c03764c61005518d9060200160405180910390a2505061168860015f55565b5f8181525f516020615a355f395f51905f5260208190526040909120606091906110f390613b3c565b611fb95f516020615a955f395f51905f5261338f565b600b805461ff00191690556040517fc0f961051f97b04c496472d11cb6170d844e4b2c9dfd3b602a4fa0139712d484905f90a1565b6120045f516020615a955f395f51905f5261338f565b5f818152600360205260409020546001600160a01b031661202481613b0a565b61166b828261331f565b60605f61203b6006613b48565b905080841061205d57604051631390f2a160e01b815260040160405180910390fd5b5f6120688486615633565b905081811180612076575083155b6120805780612082565b815b90505f61208f8683615646565b9050806001600160401b038111156120a9576120a96149ef565b6040519080825280602002602001820160405280156120d2578160200160208202803683370190505b5093505f5b81811015612119576120f46120ec8883615633565b600690613aff565b858281518110612106576121066154ca565b60209081029190910101526001016120d7565b5050505092915050565b61212b6132f7565b5f818152600360205260409020546001600160a01b031661214b81613b0a565b5f828152600360205260409020600101546001600160a01b031633146121a2575f828152600360205260409081902060010154905163d084e97560e01b81526001600160a01b039091166004820152602401610c20565b5f828152600360209081526040918290208054336001600160a01b03199182168117835560019092018054909116905582516001600160a01b03851681529182015283917fd4114ab6e9af9f597c52041f32d62dc57c5c4e4c0d4427006069635e216c93869101611dbe565b6122166132f7565b61222c5f516020615a955f395f51905f5261338f565b6009546001600160601b03166122438115156138d9565b600980546001600160601b0319169055600880548291905f906122709084906001600160601b0316615678565b92506101000a8154816001600160601b0302191690836001600160601b031602179055506116f282826001600160601b03166138f7565b816122b1816132a3565b6122b96132f7565b6001600160a01b0382165f9081526002602090815260408083208684529091529020805460ff16156122eb5750610f58565b5f84815260036020526040902060020180546063190161231e576040516305a48e0f60e01b815260040160405180910390fd5b8154600160ff1990911681178355815490810182555f82815260209081902090910180546001600160a01b0319166001600160a01b03871690811790915560405190815286917f1e980d04aa7648e205713e5e8ea3808672ac163d10936d36f91b2c88ac1575e191015b60405180910390a25050610f6160015f55565b6123a361488d565b5f82815260106020908152604080832081516101208101835281548152600182015493810193909352600281015463ffffffff1691830191909152600381015460608301526004810180546080840191906123fd90615365565b80601f016020809104026020016040519081016040528092919081815260200182805461242990615365565b80156124745780601f1061244b57610100808354040283529160200191612474565b820191905f5260205f20905b81548152906001019060200180831161245757829003601f168201915b50505091835250506040805160e08101909152602090910190600583018160608101828160a084018260028282826020028201915b8154815260200190600101908083116124a957505050918352505060408051808201918290526020909201919060028481019182845b8154815260200190600101908083116124df57505050505081525050815260200160048201805461250f90615365565b80601f016020809104026020016040519081016040528092919081815260200182805461253b90615365565b80156125865780601f1061255d57610100808354040283529160200191612586565b820191905f5260205f20905b81548152906001019060200180831161256957829003601f168201915b5050505050815260200160058201805461259f90615365565b80601f01602080910402602001604051908101604052809291908181526020018280546125cb90615365565b80156126165780601f106125ed57610100808354040283529160200191612616565b820191905f5260205f20905b8154815290600101906020018083116125f957829003601f168201915b5050505050815250508152602001600b8201805461263390615365565b80601f016020809104026020016040519081016040528092919081815260200182805461265f90615365565b80156126aa5780601f10612681576101008083540402835291602001916126aa565b820191905f5260205f20905b81548152906001019060200180831161268d57829003601f168201915b50505050508152602001600c820180546126c390615365565b80601f01602080910402602001604051908101604052809291908181526020018280546126ef90615365565b801561273a5780601f106127115761010080835404028352916020019161273a565b820191905f5260205f20905b81548152906001019060200180831161271d57829003601f168201915b5050509183525050600d91909101546001600160a01b03166020909101526060810151909150610bca5760405162461bcd60e51b81526020600482015260116024820152701a5b9d985b1a59081c995c5d595cdd1259607a1b6044820152606401610c20565b60606127af6080850185615697565b9050610100036128015760405162461bcd60e51b815260206004820152601d60248201527f696e76616c69642064656372797074696f6e206b6579206c656e6774680000006044820152606401610c20565b61010061281160a0860186615697565b9050106128605760405162461bcd60e51b815260206004820152601d60248201527f6d657373616765206f6620756e737570706f72746564206c656e6774680000006044820152606401610c20565b5f61286e6080860186615697565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509394505050505b83811015612902578484828181106128be576128be6154ca565b9050013560f81c60f81b8282815181106128da576128da6154ca565b0160200180516001600160f81b0319908116909218909116905f82901a9053506001016128a4565b505f61291160a0870187615697565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920182905250600f805495965090946129ef945090925061295b9150615365565b80601f016020809104026020016040519081016040528092919081815260200182805461298790615365565b80156129d25780601f106129a9576101008083540402835291602001916129d2565b820191905f5260205f20905b8154815290600101906020018083116129b557829003601f168201915b505050505084898060a001906129e89190615697565b9050613b51565b90505f5b612a0060a0890189615697565b9050811015612a6057818181518110612a1b57612a1b6154ca565b602001015160f81c60f81b838281518110612a3857612a386154ca565b0160200180516001600160f81b0319908116909218909116905f82901a9053506001016129f3565b505f612b15600e8054612a7290615365565b80601f0160208091040260200160405190810160405280929190818152602001828054612a9e90615365565b8015612ae95780601f10612ac057610100808354040283529160200191612ae9565b820191905f5260205f20905b815481529060010190602001808311612acc57829003601f168201915b50505050508585604051602001612b019291906156d9565b604051602081830303815290604052613ce6565b90505f612b2182613d45565b90505f80612b3d83612b38368e90038e018e6156ed565b613dd7565b909250905060018215158215151414612baf5760405162461bcd60e51b815260206004820152602e60248201527f696e76616c69642064656372797074696f6e206b6579202f206369706865727460448201526d195e1d081c9959da5cdd195c995960921b6064820152608401610c20565b50939998505050505050505050565b5f8181525f516020615a355f395f51905f526020819052604082206110f390613b48565b81612bec816132a3565b612bf46132f7565b612bfd8361113a565b15612c1b57604051631685ecdd60e31b815260040160405180910390fd5b6001600160a01b0382165f90815260026020908152604080832086845290915290205460ff16612c70576040516379bfd40160e01b8152600481018490526001600160a01b0383166024820152604401610c20565b5f838152600360205260408120600201805490915b81811015612d7357846001600160a01b0316838281548110612ca957612ca96154ca565b5f918252602090912001546001600160a01b031603612d6b5782612cce600184615646565b81548110612cde57612cde6154ca565b905f5260205f20015f9054906101000a90046001600160a01b0316838281548110612d0b57612d0b6154ca565b905f5260205f20015f6101000a8154816001600160a01b0302191690836001600160a01b0316021790555082805480612d4657612d46615707565b5f8281526020902081015f1990810180546001600160a01b0319169055019055612d73565b600101612c85565b506001600160a01b0384165f818152600260209081526040808320898452825291829020805460ff19169055905191825286917f32158c6058347c1601b2d12bc696ac6901d8a9a9aa3ba10c27ab0a983e8425a79101612388565b5f5f612dd98361239b565b606001519050805f03612dee57505f92915050565b60015460405163cd802c9160e01b8152600481018390526001600160a01b039091169063cd802c9190602401602060405180830381865afa158015612e35573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110f3919061571b565b612e6282611051565b612e6b8161338f565b6110dc83836134e8565b81612e7f816132a3565b612e876132f7565b5f83815260036020526040902060018101546001600160a01b03848116911614612f08576001810180546001600160a01b0319166001600160a01b03851690811790915560408051338152602081019290925285917f21a4dad170a6bf476c31bbcf4a16628295b0e450672eec25d7c93308e05344a1910160405180910390a25b50610f6160015f55565b5f8181526003602052604081205481906001600160a01b03166060612f3682613b0a565b5f85815260046020908152604080832054600383529281902060020180548251818502810185019093528083526001600160601b03851694600160601b90046001600160401b0316938793918391830182828015612fbb57602002820191905f5260205f20905b81546001600160a01b03168152600190910190602001808311612f9d575b5050505050905093509350935093509193509193565b5f6001600160e01b03198216637965db0b60e01b1480610bca57506301ffc9a760e01b6001600160e01b0319831614610bca565b600a5463ffffffff90811690831611156130615760405162461bcd60e51b815260206004820152601a60248201527f43616c6c6261636b206761734c696d697420746f6f20686967680000000000006044820152606401610c20565b80156131de575f818152600360205260409020546001600160a01b031661308781613b0a565b335f908152600260209081526040808320858452808352928190208151606081018352905460ff811615158083526001600160401b036101008304811695840195909552600160481b90910490931691810191909152906131345760405162461bcd60e51b815260206004820152602160248201527f4e6f2061637469766520737562736372697074696f6e20666f722063616c6c656044820152603960f91b6064820152608401610c20565b8060200180516131439061573a565b6001600160401b0316905260408101805161315d9061573a565b6001600160401b039081169091525f8581526020938452604090819020835181549585015192909401518316600160481b0270ffffffffffffffff00000000000000000019929093166101000268ffffffffffffffff00199415159490941668ffffffffffffffffff19909516949094179290921791909116179055505050565b5f6131ef8363ffffffff163a6133db565b905080341015610f615760405162461bcd60e51b815260206004820152600b60248201526a46656520746f6f206c6f7760a81b6044820152606401610c20565b60015460405163f87f0e6160e01b81525f916001600160a01b03169063f87f0e619061326390879087908790600401615764565b6020604051808303815f875af115801561327f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611c87919061579c565b5f818152600360205260409020546001600160a01b03166132c381613b0a565b336001600160a01b0382161461166b57604051636c51fda960e11b81526001600160a01b0382166004820152602401610c20565b60025f540361331957604051633ee5aeb560e01b815260040160405180910390fd5b60025f55565b5f61332983613f46565b905061333e82826001600160601b03166138f7565b604080516001600160a01b03841681526001600160601b038316602082015284917f3784f77e8e883de95b5d47cd713ced01229fa74d118c0a462224bcb0516d43f1910160405180910390a2505050565b6116fc8133614097565b5f5f516020615a355f395f51905f52816133b385856140d0565b90508015611c87575f8581526020839052604090206133d29085614171565b50949350505050565b6040805160e081018252600a5463ffffffff8082168352640100000000820481166020840152600160401b8204811693830193909352600160601b810483166060830152600160801b81048316608083015260ff600160a01b82041660a0830152600160a81b900490911660c08201525f90818361346357816060015163ffffffff16613465565b835b90505f61347186614185565b63ffffffff16836080015163ffffffff1687856020015163ffffffff16010101820290505f61349d5f90565b90505f8460a0015160640160ff1690505f856040015163ffffffff1664e8d4a510000290505f8160648487870102816134d8576134d86157b3565b04019a9950505050505050505050565b5f5f516020615a355f395f51905f5281613502858561419c565b90508015611c87575f8581526020839052604090206133d29085614215565b5f807ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00610bca565b613551614229565b565b604080518082018252601081526f181899199a1a9b1b9c1cb0b131b232b360811b602082015281516042808252608082019093526060925f9190602082018180368337019050509050600360fc1b815f815181106135b3576135b36154ca565b60200101906001600160f81b03191690815f1a905350600f60fb1b816001815181106135e1576135e16154ca565b60200101906001600160f81b03191690815f1a9053505f5b602081101561371257826004868360208110613617576136176154ca565b1a60f81b6001600160f81b031916901c60f81c60ff168151811061363d5761363d6154ca565b01602001516001600160f81b031916826136588360026157c7565b613663906002615633565b81518110613673576136736154ca565b60200101906001600160f81b03191690815f1a9053508285826020811061369c5761369c6154ca565b825191901a600f169081106136b3576136b36154ca565b01602001516001600160f81b031916826136ce8360026157c7565b6136d9906002615633565b6136e4906001615633565b815181106136f4576136f46154ca565b60200101906001600160f81b03191690815f1a9053506001016135f9565b509392505050565b306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614806137a057507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166137945f516020615a555f395f51905f52546001600160a01b031690565b6001600160a01b031614155b156135515760405163703e46dd60e11b815260040160405180910390fd5b6116fc5f516020615a955f395f51905f5261338f565b816001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561382e575060408051601f3d908101601f1916820190925261382b9181019061579c565b60015b61385657604051634c9c8ce360e01b81526001600160a01b0383166004820152602401610c20565b5f516020615a555f395f51905f52811461388657604051632a87526960e21b815260048101829052602401610c20565b610f61838361424e565b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146135515760405163703e46dd60e11b815260040160405180910390fd5b806116fc57604051631e9acf1760e31b815260040160405180910390fd5b5f826001600160a01b0316826040515f6040518083038185875af1925050503d805f8114613940576040519150601f19603f3d011682016040523d82523d5f602084013e613945565b606091505b5050905080610f615760405163950b247960e01b815260040160405180910390fd5b5f5a5f85815260106020526040812060038101549293509190036139cd5760405162461bcd60e51b815260206004820152601960248201527f4e6f207265717565737420666f722072657175657374206964000000000000006044820152606401610c20565b5f635d94180260e01b86866040516024016139e99291906157de565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152600d8301546002840154600a549293505f92613a599285926001600160a01b039091169163ffffffff91821691600160a81b9091048116906142a316565b5090508015613aca57600c8301613a7087826153db565b50600b8301613a7f86826153db565b50867f99fd15974cbf00f0f208baae5a2825fa736397eac7e2ba3003c827438ca093f7846004018560050186600c01604051613abd93929190615897565b60405180910390a2613af5565b60405187907f15083536507666802cbd84fcc1e37ed89879bad2345aaa38d48d91a5071d0f5d905f90a25b61163687856142da565b5f6110f383836143c9565b6001600160a01b0381166116fc57604051630fb532db60e11b815260040160405180910390fd5b5f6110f383836143ef565b60605f6110f38361443b565b5f610bca825490565b825160609060ff811115613b7a57846040516313727cdd60e11b8152600401610c209190614bd1565b60408051608880825260c082019092525f916020820181803683370190505090505f81865f875f8b88604051602001613bb9979695949392919061590c565b60405160208183030381529060405290505f818051906020012090505f8160018a87604051602001613bee9493929190615976565b60408051601f19818403018152919052805160208201209091505f60ff89166001600160401b03811115613c2457613c246149ef565b6040519080825280601f01601f191660200182016040528015613c4e576020820181803683370190505b5090505f6005613c62601f60ff8d16615633565b901c905060015b81811015613cc857858418613c7f826001615633565b8e8b604051602001613c949493929190615976565b60408051808303601f1901815291905260205f19830181028501810195909552805194810194909420939450600101613c69565b505f1901602090810282010191909152955050505050509392505050565b5f5f613cf484846030613b51565b601881015160308201519192506001600160c01b0391821691165f7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478381600160c01b850908979650505050505050565b604080518082019091525f8082526020820152613d606148df565b6001815260026020820152604081018390525f60608360808460076107d05a03fa905080613dd05760405162461bcd60e51b815260206004820152601f60248201527f4731207363616c6172206d756c7469706c69636174696f6e206661696c6564006044820152606401610c20565b5050919050565b5f5f5f604051806101800160405280865f01518152602001866020015181526020017f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec81526020017f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d81526020016001815260200160028152602001855f0151600160028110613eb557613eb56154ca565b60200201518152602001855f01515f60028110613ed457613ed46154ca565b602002015181526020018560200151600160028110613ef557613ef56154ca565b6020020151815260200185602001515f60028110613f1557613f156154ca565b602002015190529050613f266148fd565b6020816101808460086107d05a03fa9051151593509150505b9250929050565b5f8181526003602090815260408083206004909252822054600290910180546001600160601b03909216929091905b81811015613fe05760025f848381548110613f9257613f926154ca565b5f9182526020808320909101546001600160a01b0316835282810193909352604091820181208882529092529020805470ffffffffffffffffffffffffffffffffff19169055600101613f75565b505f84815260036020526040812080546001600160a01b03199081168255600182018054909116905590614017600283018261491b565b50505f84815260046020526040902080546001600160a01b031916905561403f600685614494565b506001600160601b03831615613dd057600880548491905f9061406c9084906001600160601b0316615678565b92506101000a8154816001600160601b0302191690836001600160601b031602179055505050919050565b6140a18282611c8f565b61166b5760405163e2517d3f60e01b81526001600160a01b038216600482015260248101839052604401610c20565b5f5f516020615a755f395f51905f526140e98484611c8f565b614168575f848152602082815260408083206001600160a01b03871684529091529020805460ff1916600117905561411e3390565b6001600160a01b0316836001600160a01b0316857f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a46001915050610bca565b5f915050610bca565b5f6110f3836001600160a01b0384166143ef565b5f614191603f836159b9565b610bca9060016159ec565b5f5f516020615a755f395f51905f526141b58484611c8f565b15614168575f848152602082815260408083206001600160a01b0387168085529252808320805460ff1916905551339287917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a46001915050610bca565b5f6110f3836001600160a01b03841661449b565b614231614575565b61355157604051631afcd79f60e31b815260040160405180910390fd5b6142578261458e565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a280511561429b57610f6182826145f1565b61166b614663565b5f5f5a8381106142d0578390036040810481038510156142d0575f5f885160208a015f8a8af19250600191505b5094509492505050565b5f6142e48361239b565b8051909150156143b85780515f9081526004602052604090208054600c9061431b90600160601b90046001600160401b031661573a565b82546001600160401b0391821661010093840a90810290830219909116179092558201516001600160a01b03165f9081526002602090815260408083208551845290915290208054909160099161437a91600160481b90910416615a08565b91906101000a8154816001600160401b0302191690836001600160401b031602179055505f6143a9833a614682565b90506110dc81835f01516146da565b610f618160200151825f01516146da565b5f825f0182815481106143de576143de6154ca565b905f5260205f200154905092915050565b5f81815260018301602052604081205461443457508154600181810184555f848152602080822090930184905584548482528286019093526040902091909155610bca565b505f610bca565b6060815f0180548060200260200160405190810160405280929190818152602001828054801561448857602002820191905f5260205f20905b815481526020019060010190808311614474575b50505050509050919050565b5f6110f383835b5f8181526001830160205260408120548015614168575f6144bd600183615646565b85549091505f906144d090600190615646565b905080821461452f575f865f0182815481106144ee576144ee6154ca565b905f5260205f200154905080875f01848154811061450e5761450e6154ca565b5f918252602080832090910192909255918252600188019052604090208390555b855486908061454057614540615707565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f905560019350505050610bca565b5f61457e613521565b54600160401b900460ff16919050565b806001600160a01b03163b5f036145c357604051634c9c8ce360e01b81526001600160a01b0382166004820152602401610c20565b5f516020615a555f395f51905f5280546001600160a01b0319166001600160a01b0392909216919091179055565b60605f5f846001600160a01b03168460405161460d9190615a29565b5f60405180830381855af49150503d805f8114614645576040519150601f19603f3d011682016040523d82523d5f602084013e61464a565b606091505b509150915061465a858383614777565b95945050505050565b34156135515760405163b398979f60e01b815260040160405180910390fd5b5f5f5a600a54640100000000900463ffffffff1685010390508281025f600a5460649190920160ff600160a01b8404168201020464e8d4a5100063ffffffff600160401b909304929092169190910201949350505050565b8015614740575f81815260046020526040902080546001600160601b03908116906147099085168210156138d9565b81546001600160601b039185900382166001600160601b031991821617909255600980548083168601909216919092161790555050565b600880546001600160601b03600160601b80830482168601909116026bffffffffffffffffffffffff60601b199091161790555050565b60608261478c57614787826147d3565b6110f3565b81511580156147a357506001600160a01b0384163b155b156147cc57604051639996b31560e01b81526001600160a01b0385166004820152602401610c20565b50806110f3565b8051156147e35780518082602001fd5b60405163d6bda27560e01b815260040160405180910390fd5b826002810192821561482a579160200282015b8281111561482a57825182559160200191906001019061480f565b50614836929150614932565b5090565b828054828255905f5260205f2090810192821561482a579160200282015b8281111561482a57825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190614858565b6040518061012001604052805f81526020015f81526020015f63ffffffff1681526020015f8152602001606081526020016148c6614946565b8152606060208201819052604082018190525f91015290565b60405180606001604052806003906020820280368337509192915050565b60405180602001604052806001906020820280368337509192915050565b5080545f8255905f5260205f20908101906116fc91905b5b80821115614836575f8155600101614933565b604051806060016040528061495961496d565b815260200160608152602001606081525090565b6040518060400160405280614980614992565b815260200161498d614992565b905290565b60405180604001604052806002906020820280368337509192915050565b5f602082840312156149c0575f5ffd5b81356001600160e01b0319811681146110f3575f5ffd5b803563ffffffff811681146149ea575f5ffd5b919050565b634e487b7160e01b5f52604160045260245ffd5b604080519081016001600160401b0381118282101715614a2557614a256149ef565b60405290565b5f82601f830112614a3a575f5ffd5b81356001600160401b03811115614a5357614a536149ef565b604051601f8201601f19908116603f011681016001600160401b0381118282101715614a8157614a816149ef565b604052818152838201602001851015614a98575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60c08284031215614ac4575f5ffd5b50919050565b5f5f5f5f60808587031215614add575f5ffd5b614ae6856149d7565b93506020850135925060408501356001600160401b03811115614b07575f5ffd5b614b1387828801614a2b565b92505060608501356001600160401b03811115614b2e575f5ffd5b614b3a87828801614ab4565b91505092959194509250565b6001600160a01b03811681146116fc575f5ffd5b5f5f60408385031215614b6b575f5ffd5b823591506020830135614b7d81614b46565b809150509250929050565b5f60208284031215614b98575f5ffd5b81356110f381614b46565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6110f36020830184614ba3565b5f60208284031215614bf3575f5ffd5b5035919050565b5f5f60408385031215614c0b575f5ffd5b614c14836149d7565b946020939093013593505050565b5f5f5f5f5f5f5f60e0888a031215614c38575f5ffd5b614c41886149d7565b9650614c4f602089016149d7565b9550614c5d604089016149d7565b9450614c6b606089016149d7565b9350614c79608089016149d7565b925060a088013560ff81168114614c8e575f5ffd5b9150614c9c60c089016149d7565b905092959891949750929550565b5f5f60408385031215614cbb575f5ffd5b8235614cc681614b46565b91506020830135614b7d81614b46565b5f60208284031215614ce6575f5ffd5b6110f3826149d7565b5f5f60408385031215614d00575f5ffd5b8235614d0b81614b46565b915060208301356001600160401b03811115614d25575f5ffd5b614d3185828601614a2b565b9150509250929050565b5f5f83601f840112614d4b575f5ffd5b5081356001600160401b03811115614d61575f5ffd5b602083019150836020828501011115613f3f575f5ffd5b5f5f5f5f5f60608688031215614d8c575f5ffd5b8535945060208601356001600160401b03811115614da8575f5ffd5b614db488828901614d3b565b90955093505060408601356001600160401b03811115614dd2575f5ffd5b614dde88828901614d3b565b969995985093965092949392505050565b805f5b60028110156110dc578151845260209384019390910190600101614df2565b5f8151614e1f848251614def565b60200151614e306040850182614def565b50602082015160c06080850152614e4a60c0850182614ba3565b9050604083015184820360a086015261465a8282614ba3565b89815288602082015263ffffffff8816604082015286606082015261012060808201525f614e95610120830188614ba3565b82810360a0840152614ea78188614e11565b905082810360c0840152614ebb8187614ba3565b905082810360e0840152614ecf8186614ba3565b91505060018060a01b0383166101008301529a9950505050505050505050565b5f5f5f5f60608587031215614f02575f5ffd5b614f0b856149d7565b935060208501356001600160401b03811115614f25575f5ffd5b614f3187828801614d3b565b90945092505060408501356001600160401b03811115614b2e575f5ffd5b5f5f60408385031215614f60575f5ffd5b50508035926020909101359150565b5f8151808452602084019350602083015f5b82811015614fa85781516001600160a01b0316865260209586019590910190600101614f81565b5093949350505050565b602081525f6110f36020830184614f6f565b602080825282518282018190525f918401906040840190835b81811015614ffb578351835260209384019390920191600101614fdd565b509095945050505050565b6020815281516020820152602082015160408201525f6040830151615033606084018263ffffffff169052565b5060608301516080830152608083015161012060a0840152615059610140840182614ba3565b905060a0840151601f198483030160c08501526150768282614e11565b91505060c0840151601f198483030160e08501526150948282614ba3565b91505060e0840151601f19848303016101008501526150b38282614ba3565b9150506101008401516137126101208501826001600160a01b03169052565b5f5f5f604084860312156150e4575f5ffd5b83356001600160401b038111156150f9575f5ffd5b61510586828701614ab4565b93505060208401356001600160401b03811115615120575f5ffd5b61512c86828701614d3b565b9497909650939450505050565b6001600160601b03851681526001600160401b03841660208201526001600160a01b03831660408201526080606082018190525f90611c5890830184614f6f565b5f5f8335601e1984360301811261518f575f5ffd5b83016020810192503590506001600160401b038111156151ad575f5ffd5b803603821315613f3f575f5ffd5b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b6040818337604080820160408401375f615200608083018361517a565b60c0608086015261521560c0860182846151bb565b91505061522560a084018461517a565b85830360a0870152611c588382846151bb565b602081525f6110f360208301846151e3565b5f82601f830112615259575f5ffd5b615261614a03565b806040840185811115615272575f5ffd5b845b81811015614ffb578035845260209384019301615274565b5f6080828403121561529c575f5ffd5b6152a4614a03565b90506152b0838361524a565b81526152bf836040840161524a565b602082015292915050565b5f60c082360312156152da575f5ffd5b604051606081016001600160401b03811182821017156152fc576152fc6149ef565b604052615309368461528c565b815260808301356001600160401b03811115615323575f5ffd5b61532f36828601614a2b565b60208301525060a08301356001600160401b0381111561534d575f5ffd5b61535936828601614a2b565b60408301525092915050565b600181811c9082168061537957607f821691505b602082108103614ac457634e487b7160e01b5f52602260045260245ffd5b601f821115610f6157805f5260205f20601f840160051c810160208510156153bc5750805b601f840160051c820191505b818110156117cb575f81556001016153c8565b81516001600160401b038111156153f4576153f46149ef565b615408816154028454615365565b84615397565b6020601f82116001811461543a575f83156154235750848201515b5f19600385901b1c1916600184901b1784556117cb565b5f84815260208120601f198516915b828110156154695787850151825560209485019460019092019101615449565b508482101561548657868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b606081525f6154a76060830186614ba3565b82810360208401526154b981866151e3565b915050826040830152949350505050565b634e487b7160e01b5f52603260045260245ffd5b5f81518060208401855e5f93019283525090919050565b7f424c4f434b4c4f434b5f424e32353447315f584d443a4b454343414b2d32353681526b5f535644575f524f5f48315f60a01b60208201525f61553b602c8301846154de565b605f60f81b81526001019392505050565b7f424c4f434b4c4f434b5f424e3235345f584d443a4b454343414b2d3235365f48815261325f60f01b60208201525f61553b60228301846154de565b7f424c4f434b4c4f434b5f424e3235345f584d443a4b454343414b2d3235365f48815261335f60f01b60208201525f61553b60228301846154de565b7f424c4f434b4c4f434b5f424e3235345f584d443a4b454343414b2d3235365f48815261345f60f01b60208201525f61553b60228301846154de565b634e487b7160e01b5f52601160045260245ffd5b6001600160601b038181168382160190811115610bca57610bca615600565b80820180821115610bca57610bca615600565b81810381811115610bca57610bca615600565b6001600160401b038181168382160190811115610bca57610bca615600565b6001600160601b038281168282160390811115610bca57610bca615600565b5f5f8335601e198436030181126156ac575f5ffd5b8301803591506001600160401b038211156156c5575f5ffd5b602001915036819003821315613f3f575f5ffd5b5f611c876156e783866154de565b846154de565b5f608082840312156156fd575f5ffd5b6110f3838361528c565b634e487b7160e01b5f52603160045260245ffd5b5f6020828403121561572b575f5ffd5b815180151581146110f3575f5ffd5b5f6001600160401b0382166001600160401b03810361575b5761575b615600565b60010192915050565b606081525f6157766060830186614ba3565b82810360208401526157888186614ba3565b90508281036040840152611c588185614ba3565b5f602082840312156157ac575f5ffd5b5051919050565b634e487b7160e01b5f52601260045260245ffd5b8082028115828204841417610bca57610bca615600565b828152604060208201525f611c876040830184614ba3565b5f815461580281615365565b80855260018216801561581c57600181146158385761586c565b60ff1983166020870152602082151560051b870101935061586c565b845f5260205f205f5b838110156158635781546020828a010152600182019150602081019050615841565b87016020019450505b50505092915050565b805f5b60028110156110dc578154845260209093019260019182019101615878565b606081525f6158a960608301866157f6565b82810360208401526158bb8186615875565b6158cb6040820160028701615875565b60c060808201526158e260c08201600487016157f6565b81810360a08301526158f781600588016157f6565b9150508281036040840152611c5881856157f6565b5f61592061591a838b6154de565b896154de565b6001600160f81b031960f889811b8216835288811b8216600184015287901b16600282015261595260038201866154de565b60f89490941b6001600160f81b031916845250506001909101979650505050505050565b84815260f884901b6001600160f81b03191660208201525f61599b60218301856154de565b60f89390931b6001600160f81b031916835250506001019392505050565b5f63ffffffff8316806159da57634e487b7160e01b5f52601260045260245ffd5b8063ffffffff84160491505092915050565b63ffffffff8181168382160190811115610bca57610bca615600565b5f6001600160401b03821680615a2057615a20615600565b5f190192915050565b5f6110f382846154de56fec1f6fe24621ce81ec5827caf0253cadb74709b061630e6b55e82371705932000360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800a49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x03qW_5`\xE0\x1C\x80csP\xF4V\x11a\x01\xC8W\x80c\xAAC:\xFF\x11a\0\xFDW\x80c\xC5\x83C\xEF\x11a\0\x9DW\x80c\xCD\x80,\x91\x11a\0mW\x80c\xCD\x80,\x91\x14a\x0B\x1AW\x80c\xD5Gt\x1F\x14a\x0B9W\x80c\xDA\xC8=)\x14a\x0BXW\x80c\xDC1\x1D\xD3\x14a\x0BwW__\xFD[\x80c\xC5\x83C\xEF\x14a\n\x91W\x80c\xC9\xBC\x18\xC4\x14a\n\xBDW\x80c\xCA\x15\xC8s\x14a\n\xDCW\x80c\xCBc\x17\x97\x14a\n\xFBW__\xFD[\x80c\xB2\xA7\xCA\xC5\x11a\0\xD8W\x80c\xB2\xA7\xCA\xC5\x14a\t\xDAW\x80c\xBD\x18ck\x14a\t\xF9W\x80c\xBE\xC4\xC0\x8C\x14a\n\x18W\x80c\xC3\xF9\t\xD4\x14a\n7W__\xFD[\x80c\xAAC:\xFF\x14a\t_W\x80c\xAD<\xB1\xCC\x14a\t~W\x80c\xAE\xFB!/\x14a\t\xAEW__\xFD[\x80c\x99\\\xB3n\x11a\x01hW\x80c\xA2\x1A#\xE4\x11a\x01CW\x80c\xA2\x1A#\xE4\x14a\x08\xEDW\x80c\xA3$j\xD3\x14a\t\x01W\x80c\xA3\x90}q\x14a\t-W\x80c\xA6\x08\xA1\xE1\x14a\tAW__\xFD[\x80c\x99\\\xB3n\x14a\x08\x84W\x80c\x9D@\xA6\xFD\x14a\x08\xA3W\x80c\xA2\x17\xFD\xDF\x14a\x08\xDAW__\xFD[\x80c\x8A\x1F\x16Z\x11a\x01\xA3W\x80c\x8A\x1F\x16Z\x14a\x07\xF5W\x80c\x90\x10\xD0|\x14a\x083W\x80c\x91\xD1HT\x14a\x08RW\x80c\x95\xB5\\\xFC\x14a\x08qW__\xFD[\x80csP\xF4V\x14a\x07\xAEW\x80cu\xB28\xFC\x14a\x07\xC2W\x80cy\t\xDC{\x14a\x07\xE2W__\xFD[\x80c8\xC2}\x12\x11a\x02\xA9W\x80cR\xD1\x90-\x11a\x02IW\x80c];\xE0\x01\x11a\x02\x19W\x80c];\xE0\x01\x14a\x07 W\x80c_{\xDA\x9F\x14a\x07?W\x80cd\xD5\x1A*\x14a\x07sW\x80cg\xB2v\xAF\x14a\x07\x9AW__\xFD[\x80cR\xD1\x90-\x14a\x06\xA7W\x80cT#o\xB3\x14a\x06\xBBW\x80cT\xFDMP\x14a\x06\xDAW\x80cW\xA8\x07\n\x14a\x07\x07W__\xFD[\x80cE\xFACT\x11a\x02\x84W\x80cE\xFACT\x14a\x067W\x80cH\\\xC9U\x14a\x06VW\x80cK\x16\t5\x14a\x06uW\x80cO\x1E\xF2\x86\x14a\x06\x94W__\xFD[\x80c8\xC2}\x12\x14a\x05\xDEW\x80c;\xC3,u\x14a\x05\xF2W\x80cA\xAFl\x87\x14a\x06\x18W__\xFD[\x80c#R\x96\xF7\x11a\x03\x14W\x80c//\xF1]\x11a\x02\xEFW\x80c//\xF1]\x14a\x05oW\x80c2U\xC4V\x14a\x05\x8EW\x80c4\x08\xE4p\x14a\x05\xADW\x80c6V\x8A\xBE\x14a\x05\xBFW__\xFD[\x80c#R\x96\xF7\x14a\x05\x1BW\x80c$\x8A\x9C\xA3\x14a\x05<W\x80c/'p\xDB\x14a\x05[W__\xFD[\x80c\n\xE0\x95@\x11a\x03OW\x80c\n\xE0\x95@\x14a\x04mW\x80c\x13<@\xC7\x14a\x04\x8EW\x80c\x18\xE3\xDD'\x14a\x04\xC5W\x80c\x1Ek\xA1[\x14a\x04\xFCW__\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x03uW\x80c\x06+\x1D\x90\x14a\x03\xA9W\x80c\x08\x80p\xF5\x14a\x03\xCAW[__\xFD[4\x80\x15a\x03\x80W__\xFD[Pa\x03\x94a\x03\x8F6`\x04aI\xB0V[a\x0B\xA6V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x03\xBCa\x03\xB76`\x04aJ\xCAV[a\x0B\xD0V[`@Q\x90\x81R` \x01a\x03\xA0V[4\x80\x15a\x03\xD5W__\xFD[P`\nTa\x04&\x90c\xFF\xFF\xFF\xFF\x80\x82\x16\x91d\x01\0\0\0\0\x81\x04\x82\x16\x91`\x01`@\x1B\x82\x04\x81\x16\x91`\x01``\x1B\x81\x04\x82\x16\x91`\x01`\x80\x1B\x82\x04\x81\x16\x91`\xFF`\x01`\xA0\x1B\x82\x04\x16\x91`\x01`\xA8\x1B\x90\x91\x04\x16\x87V[`@\x80Qc\xFF\xFF\xFF\xFF\x98\x89\x16\x81R\x96\x88\x16` \x88\x01R\x94\x87\x16\x94\x86\x01\x94\x90\x94R\x91\x85\x16``\x85\x01R\x84\x16`\x80\x84\x01R`\xFF\x16`\xA0\x83\x01R\x90\x91\x16`\xC0\x82\x01R`\xE0\x01a\x03\xA0V[4\x80\x15a\x04xW__\xFD[Pa\x04\x8Ca\x04\x876`\x04aKZV[a\x0F\x15V[\0[4\x80\x15a\x04\x99W__\xFD[P`\x01Ta\x04\xAD\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x03\xA0V[4\x80\x15a\x04\xD0W__\xFD[P`\x08Ta\x04\xE4\x90`\x01`\x01``\x1B\x03\x16\x81V[`@Q`\x01`\x01``\x1B\x03\x90\x91\x16\x81R` \x01a\x03\xA0V[4\x80\x15a\x05\x07W__\xFD[Pa\x04\x8Ca\x05\x166`\x04aK\x88V[a\x0FfV[4\x80\x15a\x05&W__\xFD[Pa\x05/a\x0F\xC5V[`@Qa\x03\xA0\x91\x90aK\xD1V[4\x80\x15a\x05GW__\xFD[Pa\x03\xBCa\x05V6`\x04aK\xE3V[a\x10QV[4\x80\x15a\x05fW__\xFD[Pa\x04\x8Ca\x10qV[4\x80\x15a\x05zW__\xFD[Pa\x04\x8Ca\x05\x896`\x04aKZV[a\x10\xC0V[4\x80\x15a\x05\x99W__\xFD[Pa\x03\xBCa\x05\xA86`\x04aK\xFAV[a\x10\xE2V[4\x80\x15a\x05\xB8W__\xFD[PFa\x03\xBCV[4\x80\x15a\x05\xCAW__\xFD[Pa\x04\x8Ca\x05\xD96`\x04aKZV[a\x10\xFAV[4\x80\x15a\x05\xE9W__\xFD[Pa\x05/a\x11-V[4\x80\x15a\x05\xFDW__\xFD[P`\x08Ta\x04\xE4\x90`\x01``\x1B\x90\x04`\x01`\x01``\x1B\x03\x16\x81V[4\x80\x15a\x06#W__\xFD[Pa\x03\x94a\x0626`\x04aK\xE3V[a\x11:V[4\x80\x15a\x06BW__\xFD[Pa\x04\x8Ca\x06Q6`\x04aL\"V[a\x11\xCFV[4\x80\x15a\x06aW__\xFD[Pa\x04\x8Ca\x06p6`\x04aL\xAAV[a\x13\xACV[4\x80\x15a\x06\x80W__\xFD[Pa\x03\xBCa\x06\x8F6`\x04aL\xD6V[a\x16?V[a\x04\x8Ca\x06\xA26`\x04aL\xEFV[a\x16PV[4\x80\x15a\x06\xB2W__\xFD[Pa\x03\xBCa\x16oV[4\x80\x15a\x06\xC6W__\xFD[Pa\x04\x8Ca\x06\xD56`\x04aK\x88V[a\x16\x8BV[4\x80\x15a\x06\xE5W__\xFD[P`@\x80Q\x80\x82\x01\x90\x91R`\x05\x81Rd0.0.1`\xD8\x1B` \x82\x01Ra\x05/V[4\x80\x15a\x07\x12W__\xFD[P`\x0BTa\x03\x94\x90`\xFF\x16\x81V[4\x80\x15a\x07+W__\xFD[Pa\x04\x8Ca\x07:6`\x04aMxV[a\x16\xFFV[4\x80\x15a\x07JW__\xFD[Pa\x07^a\x07Y6`\x04aK\xE3V[a\x17\xD2V[`@Qa\x03\xA0\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90aNcV[4\x80\x15a\x07~W__\xFD[Pa\x07\x87`d\x81V[`@Qa\xFF\xFF\x90\x91\x16\x81R` \x01a\x03\xA0V[4\x80\x15a\x07\xA5W__\xFD[Pa\x05/a\x1BXV[4\x80\x15a\x07\xB9W__\xFD[Pa\x05/a\x1BeV[4\x80\x15a\x07\xCDW__\xFD[Pa\x03\xBC_Q` aZ\x95_9_Q\x90_R\x81V[a\x03\xBCa\x07\xF06`\x04aN\xEFV[a\x1BrV[4\x80\x15a\x08\0W__\xFD[Pa\x05/`@Q\x80`@\x01`@R\x80`\x13\x81R` \x01rBN254-BLS-BLOCKLOCK`h\x1B\x81RP\x81V[4\x80\x15a\x08>W__\xFD[Pa\x04\xADa\x08M6`\x04aOOV[a\x1CbV[4\x80\x15a\x08]W__\xFD[Pa\x03\x94a\x08l6`\x04aKZV[a\x1C\x8FV[a\x04\x8Ca\x08\x7F6`\x04aK\xE3V[a\x1C\xC5V[4\x80\x15a\x08\x8FW__\xFD[P`\tTa\x04\xE4\x90`\x01`\x01``\x1B\x03\x16\x81V[4\x80\x15a\x08\xAEW__\xFD[P`\x05Ta\x08\xC2\x90`\x01`\x01`@\x1B\x03\x16\x81V[`@Q`\x01`\x01`@\x1B\x03\x90\x91\x16\x81R` \x01a\x03\xA0V[4\x80\x15a\x08\xE5W__\xFD[Pa\x03\xBC_\x81V[4\x80\x15a\x08\xF8W__\xFD[Pa\x03\xBCa\x1D\xD0V[4\x80\x15a\t\x0CW__\xFD[Pa\t a\t\x1B6`\x04aK\xE3V[a\x1FzV[`@Qa\x03\xA0\x91\x90aO\xB2V[4\x80\x15a\t8W__\xFD[Pa\x04\x8Ca\x1F\xA3V[4\x80\x15a\tLW__\xFD[P`\x0BTa\x03\x94\x90a\x01\0\x90\x04`\xFF\x16\x81V[4\x80\x15a\tjW__\xFD[Pa\x04\x8Ca\ty6`\x04aK\xE3V[a\x1F\xEEV[4\x80\x15a\t\x89W__\xFD[Pa\x05/`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01d\x03R\xE3\x02\xE3`\xDC\x1B\x81RP\x81V[4\x80\x15a\t\xB9W__\xFD[Pa\t\xCDa\t\xC86`\x04aOOV[a .V[`@Qa\x03\xA0\x91\x90aO\xC4V[4\x80\x15a\t\xE5W__\xFD[Pa\x04\x8Ca\t\xF46`\x04aK\xE3V[a!#V[4\x80\x15a\n\x04W__\xFD[Pa\x04\x8Ca\n\x136`\x04aK\x88V[a\"\x0EV[4\x80\x15a\n#W__\xFD[Pa\x04\x8Ca\n26`\x04aKZV[a\"\xA7V[4\x80\x15a\nBW__\xFD[P`\nTc\xFF\xFF\xFF\xFF\x80\x82\x16\x91d\x01\0\0\0\0\x81\x04\x82\x16\x91`\x01`@\x1B\x82\x04\x81\x16\x91`\x01``\x1B\x81\x04\x82\x16\x91`\x01`\x80\x1B\x82\x04\x81\x16\x91`\xFF`\x01`\xA0\x1B\x82\x04\x16\x91`\x01`\xA8\x1B\x90\x91\x04\x16a\x04&V[4\x80\x15a\n\x9CW__\xFD[Pa\n\xB0a\n\xAB6`\x04aK\xE3V[a#\x9BV[`@Qa\x03\xA0\x91\x90aP\x06V[4\x80\x15a\n\xC8W__\xFD[Pa\x05/a\n\xD76`\x04aP\xD2V[a'\xA0V[4\x80\x15a\n\xE7W__\xFD[Pa\x03\xBCa\n\xF66`\x04aK\xE3V[a+\xBEV[4\x80\x15a\x0B\x06W__\xFD[Pa\x04\x8Ca\x0B\x156`\x04aKZV[a+\xE2V[4\x80\x15a\x0B%W__\xFD[Pa\x03\x94a\x0B46`\x04aK\xE3V[a-\xCEV[4\x80\x15a\x0BDW__\xFD[Pa\x04\x8Ca\x0BS6`\x04aKZV[a.YV[4\x80\x15a\x0BcW__\xFD[Pa\x04\x8Ca\x0Br6`\x04aKZV[a.uV[4\x80\x15a\x0B\x82W__\xFD[Pa\x0B\x96a\x0B\x916`\x04aK\xE3V[a/\x12V[`@Qa\x03\xA0\x94\x93\x92\x91\x90aQ9V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x0B\xCAWPa\x0B\xCA\x82a/\xD1V[\x92\x91PPV[`\x0BT_\x90`\xFF\x16a\x0C)W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FContract is not configured\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`\x0BTa\x01\0\x90\x04`\xFF\x16\x15a\x0CxW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01Rs\x10\xDB\xDB\x9D\x1C\x98X\xDD\x08\x1A\\\xC8\x19\x1A\\\xD8X\x9B\x19Y`b\x1B`D\x82\x01R`d\x01a\x0C V[\x83\x15\x15\x80a\x0C\x85WP_4\x11[a\x0C\xF7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7FDirect funding required for requ`D\x82\x01R\x7Fest fulfillment callback\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x0C V[a\r\x01\x85\x85a0\x05V[_a\rW`@Q\x80`@\x01`@R\x80`\x13\x81R` \x01rBN254-BLS-BLOCKLOCK`h\x1B\x81RP\x84`@Q` \x01a\rB\x91\x90aR8V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x86a2/V[\x90P`@Q\x80a\x01 \x01`@R\x80\x86\x81R` \x014\x81R` \x01\x87c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81R` \x01\x85\x81R` \x01\x84a\r\x93\x90aR\xCAV[\x81R`@\x80Q` \x80\x82\x01\x83R_\x80\x83R\x81\x85\x01\x92\x90\x92R\x82Q\x80\x82\x01\x84R\x82\x81R\x83\x85\x01R3``\x94\x85\x01R\x85\x82R`\x10\x81R\x90\x82\x90 \x84Q\x81U\x90\x84\x01Q`\x01\x82\x01U\x90\x83\x01Q`\x02\x82\x01\x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90U\x90\x82\x01Q`\x03\x82\x01U`\x80\x82\x01Q`\x04\x82\x01\x90a\x0E\x14\x90\x82aS\xDBV[P`\xA0\x82\x01Q\x80Q\x80Q`\x05\x84\x01\x91\x90\x82\x90a\x0E3\x90\x82\x90`\x02aG\xFCV[P` \x82\x01Qa\x0EI\x90`\x02\x80\x84\x01\x91\x90aG\xFCV[PPP` \x82\x01Q`\x04\x82\x01\x90a\x0E`\x90\x82aS\xDBV[P`@\x82\x01Q`\x05\x82\x01\x90a\x0Eu\x90\x82aS\xDBV[PPP`\xC0\x82\x01Q`\x0B\x82\x01\x90a\x0E\x8C\x90\x82aS\xDBV[P`\xE0\x82\x01Q`\x0C\x82\x01\x90a\x0E\xA1\x90\x82aS\xDBV[Pa\x01\0\x91\x90\x91\x01Q`\r\x90\x91\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90\x91\x17\x90U`@Q3\x90\x82\x90\x7F\xA7\xCFW`\x9BJ\xBE\xD6\x89\xB4\x08\xDB\x0B\x0C=\xC60\x97\x86\xB6\xC0}^\xFB\xBD\x1D[\x15\x0Em,\x06\x90a\x0F\x04\x90\x88\x90\x88\x90B\x90aT\x95V[`@Q\x80\x91\x03\x90\xA3\x95\x94PPPPPV[\x81a\x0F\x1F\x81a2\xA3V[a\x0F'a2\xF7V[a\x0F0\x83a\x11:V[\x15a\x0FNW`@Qc\x16\x85\xEC\xDD`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0FX\x83\x83a3\x1FV[a\x0Fa`\x01_UV[PPPV[a\x0F|_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x81\x17\x90\x91U`@Q\x7F\r\xAE\x1D\0.\x96\xC28\xEB\xE1@\xCA\x17\x99\xF7p\x93\xAE\t\xE0\xBD\xE4\x0Fy\xBB)\xEDx\xD0\x9Ee-\x90_\x90\xA2PV[`\x0C\x80Ta\x0F\xD2\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0F\xFE\x90aSeV[\x80\x15a\x10IW\x80`\x1F\x10a\x10 Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10IV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10,W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[_\x90\x81R_Q` aZu_9_Q\x90_R` R`@\x90 `\x01\x01T\x90V[a\x10\x87_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\x0B\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U`@Q\x7Fu\x88L\xDA\xDCJ\x89\xE8\xB5E\xDB\x80\0W\xF0n\xC7\xF53\x8A\x08\x18<{\xA5\x15\xF2\xBF\xDD\x9F\xE1\xE1\x90_\x90\xA1V[a\x10\xC9\x82a\x10QV[a\x10\xD2\x81a3\x8FV[a\x10\xDC\x83\x83a3\x99V[PPPPV[_a\x10\xF3\x83c\xFF\xFF\xFF\xFF\x16\x83a3\xDBV[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x11#W`@Qc3K\xD9\x19`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0Fa\x82\x82a4\xE8V[`\r\x80Ta\x0F\xD2\x90aSeV[_\x81\x81R`\x03` R`@\x81 `\x02\x01\x80T\x82[\x81\x81\x10\x15a\x11\xC5W_`\x02_\x85\x84\x81T\x81\x10a\x11lWa\x11laT\xCAV[_\x91\x82R` \x80\x83 \x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16\x83R\x82\x81\x01\x93\x90\x93R`@\x91\x82\x01\x81 \x89\x82R\x90\x92R\x90 T`\x01`\x01`@\x1B\x03`\x01`H\x1B\x90\x91\x04\x16\x11\x15a\x11\xBDWP`\x01\x94\x93PPPPV[`\x01\x01a\x11NV[P_\x94\x93PPPPV[a\x11\xE5_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\xFF\x82\x16`\x9B\x11a\x128W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FInvalid Premium Percentage\0\0\0\0\0\0`D\x82\x01R`d\x01a\x0C V[`@\x80Q`\xE0\x81\x01\x82Rc\xFF\xFF\xFF\xFF\x89\x81\x16\x80\x83R\x89\x82\x16` \x84\x01\x81\x90R\x89\x83\x16\x84\x86\x01\x81\x90R\x89\x84\x16``\x86\x01\x81\x90R\x89\x85\x16`\x80\x87\x01\x81\x90R`\xFF\x8A\x16`\xA0\x88\x01\x81\x90R\x95\x89\x16`\xC0\x90\x97\x01\x87\x90R`\n\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x95\x17d\x01\0\0\0\0\x90\x94\x02\x93\x90\x93\x17o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x19\x16`\x01`@\x1B\x90\x92\x02c\xFF\xFF\xFF\xFF``\x1B\x19\x16\x91\x90\x91\x17`\x01``\x1B\x90\x91\x02\x17d\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x01`\x80\x1B\x90\x91\x02`\xFF`\xA0\x1B\x19\x16\x17`\x01`\xA0\x1B\x90\x92\x02\x91\x90\x91\x17c\xFF\xFF\xFF\xFF`\xA8\x1B\x19\x16`\x01`\xA8\x1B\x90\x92\x02\x91\x90\x91\x17\x90U`\x0B\x80T`\xFF\x19\x16`\x01\x17\x90UQ\x7FU\xA2\x8F\xDE)_H,\x9F2\xD6p\xC1\x16\x10;\xCA\x15rK\xCE\xF4\xF1\x8B5T.\x05S\xC3Z\xD5\x90a\x13\x9B\x90\x89\x90\x89\x90\x89\x90\x89\x90\x89\x90\x89\x90\x89\x90c\xFF\xFF\xFF\xFF\x97\x88\x16\x81R\x95\x87\x16` \x87\x01R\x93\x86\x16`@\x86\x01R\x91\x85\x16``\x85\x01R\x84\x16`\x80\x84\x01R`\xFF\x16`\xA0\x83\x01R\x90\x91\x16`\xC0\x82\x01R`\xE0\x01\x90V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[_a\x13\xB5a5!V[\x80T\x90\x91P`\xFF`\x01`@\x1B\x82\x04\x16\x15\x90`\x01`\x01`@\x1B\x03\x16_\x81\x15\x80\x15a\x13\xDBWP\x82[\x90P_\x82`\x01`\x01`@\x1B\x03\x16`\x01\x14\x80\x15a\x13\xF6WP0;\x15[\x90P\x81\x15\x80\x15a\x14\x04WP\x80\x15[\x15a\x14\"W`@Qc\xF9.\xE8\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01\x17\x85U\x83\x15a\x14LW\x84T`\xFF`@\x1B\x19\x16`\x01`@\x1B\x17\x85U[a\x14Ta5IV[a\x14\\a5IV[a\x14s_Q` aZ\x95_9_Q\x90_R\x88a3\x99V[a\x14\xB3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x11\xDC\x98[\x9D\x08\x1C\x9B\xDB\x19H\x19\x98Z[\x19Y`z\x1B`D\x82\x01R`d\x01a\x0C V[a\x14\xBD_\x88a3\x99V[a\x14\xFDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x11\xDC\x98[\x9D\x08\x1C\x9B\xDB\x19H\x19\x98Z[\x19Y`z\x1B`D\x82\x01R`d\x01a\x0C V[`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x88\x16\x17\x90Ua\x15!Fa5SV[`@Q` \x01a\x151\x91\x90aT\xF5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\x0C\x90\x81a\x15N\x91\x90aS\xDBV[Pa\x15XFa5SV[`@Q` \x01a\x15h\x91\x90aULV[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\r\x90\x81a\x15\x85\x91\x90aS\xDBV[Pa\x15\x8FFa5SV[`@Q` \x01a\x15\x9F\x91\x90aU\x88V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\x0E\x90\x81a\x15\xBC\x91\x90aS\xDBV[Pa\x15\xC6Fa5SV[`@Q` \x01a\x15\xD6\x91\x90aU\xC4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\x0F\x90\x81a\x15\xF3\x91\x90aS\xDBV[P\x83\x15a\x166W\x84T`\xFF`@\x1B\x19\x16\x85U`@Q`\x01\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x01a\x13\x9BV[PPPPPPPV[_a\x0B\xCA\x82c\xFF\xFF\xFF\xFF\x16:a3\xDBV[a\x16Xa7\x1AV[a\x16a\x82a7\xBEV[a\x16k\x82\x82a7\xD4V[PPV[_a\x16xa8\x90V[P_Q` aZU_9_Q\x90_R[\x90V[a\x16\x93a2\xF7V[a\x16\xA9_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\x08T`\x01``\x1B\x90\x04`\x01`\x01``\x1B\x03\x16a\x16\xC7\x81\x15\x15a8\xD9V[`\x08\x80Tk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x1B\x19\x16\x90Ua\x16\xF2\x82`\x01`\x01``\x1B\x03\x83\x16a8\xF7V[Pa\x16\xFC`\x01_UV[PV[`\x01T`\x01`\x01`\xA0\x1B\x03\x163\x14a\x17YW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FOnly DecryptionSender can call\0\0`D\x82\x01R`d\x01a\x0C V[a\x17\xCB\x85\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPP`@\x80Q` `\x1F\x89\x01\x81\x90\x04\x81\x02\x82\x01\x81\x01\x90\x92R\x87\x81R\x92P\x87\x91P\x86\x90\x81\x90\x84\x01\x83\x82\x80\x82\x847_\x92\x01\x91\x90\x91RPa9g\x92PPPV[PPPPPV[`\x10` R_\x90\x81R`@\x90 \x80T`\x01\x82\x01T`\x02\x83\x01T`\x03\x84\x01T`\x04\x85\x01\x80T\x94\x95\x93\x94c\xFF\xFF\xFF\xFF\x90\x93\x16\x93\x91\x92a\x18\x0E\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x18:\x90aSeV[\x80\x15a\x18\x85W\x80`\x1F\x10a\x18\\Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x18\x85V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x18hW\x82\x90\x03`\x1F\x16\x82\x01\x91[PP`@\x80Q`\xE0\x81\x01\x90\x91R\x93\x94\x93\x92PP`\x05\x83\x01\x90P\x81``\x81\x01\x82\x81`\xA0\x84\x01\x82`\x02\x82\x82\x82` \x02\x82\x01\x91[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x18\xB6WPPP\x91\x83RPP`@\x80Q\x80\x82\x01\x91\x82\x90R` \x90\x92\x01\x91\x90`\x02\x84\x81\x01\x91\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x18\xECWPPPPP\x81RPP\x81R` \x01`\x04\x82\x01\x80Ta\x19\x1C\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x19H\x90aSeV[\x80\x15a\x19\x93W\x80`\x1F\x10a\x19jWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x19\x93V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x19vW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x19\xAC\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x19\xD8\x90aSeV[\x80\x15a\x1A#W\x80`\x1F\x10a\x19\xFAWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1A#V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1A\x06W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x90\x80`\x0B\x01\x80Ta\x1A<\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1Ah\x90aSeV[\x80\x15a\x1A\xB3W\x80`\x1F\x10a\x1A\x8AWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1A\xB3V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1A\x96W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90\x80`\x0C\x01\x80Ta\x1A\xC8\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1A\xF4\x90aSeV[\x80\x15a\x1B?W\x80`\x1F\x10a\x1B\x16Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1B?V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1B\"W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP`\r\x90\x93\x01T\x91\x92PP`\x01`\x01`\xA0\x1B\x03\x16\x89V[`\x0F\x80Ta\x0F\xD2\x90aSeV[`\x0E\x80Ta\x0F\xD2\x90aSeV[`\x0BT_\x90`\xFF\x16a\x1B\xC6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FContract is not configured\0\0\0\0\0\0`D\x82\x01R`d\x01a\x0C V[`\x0BTa\x01\0\x90\x04`\xFF\x16\x15a\x1C\x15W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01Rs\x10\xDB\xDB\x9D\x1C\x98X\xDD\x08\x1A\\\xC8\x19\x1A\\\xD8X\x9B\x19Y`b\x1B`D\x82\x01R`d\x01a\x0C V[_a\x1CX\x86_\x87\x87\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP\x89\x92Pa\x0B\xD0\x91PPV[\x96\x95PPPPPPV[_\x82\x81R_Q` aZ5_9_Q\x90_R` \x81\x90R`@\x82 a\x1C\x87\x90\x84a:\xFFV[\x94\x93PPPPV[_\x91\x82R_Q` aZu_9_Q\x90_R` \x90\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[a\x1C\xCDa2\xF7V[_\x81\x81R`\x03` R`@\x90 Ta\x1C\xED\x90`\x01`\x01`\xA0\x1B\x03\x16a;\nV[_\x81\x81R`\x04` R`@\x81 \x80T`\x01`\x01``\x1B\x03\x16\x914\x91\x90a\x1D\x13\x83\x85aV\x14V[\x92Pa\x01\0\n\x81T\x81`\x01`\x01``\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01``\x1B\x03\x16\x02\x17\x90UP4`\x08_\x82\x82\x82\x90T\x90a\x01\0\n\x90\x04`\x01`\x01``\x1B\x03\x16a\x1DZ\x91\x90aV\x14V[\x92Pa\x01\0\n\x81T\x81`\x01`\x01``\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01``\x1B\x03\x16\x02\x17\x90UP\x81\x7Fv\x03\xB2\x05\xD06Q\xEE\x81/\x80?\xCC\xDE\x89\xF1\x01.TZ\x9C\x99\xF0\xAB\xFE\xA9\xCE\xDD\x0F\xD8\xE9\x02\x824\x84a\x1D\xAD\x91\x90aV3V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01[`@Q\x80\x91\x03\x90\xA2Pa\x16\xFC`\x01_UV[_a\x1D\xD9a2\xF7V[`\x05T`\x01`\x01`@\x1B\x03\x163a\x1D\xF1`\x01CaVFV[`@Q`\x01`\x01``\x1B\x03\x19``\x93\x84\x1B\x81\x16` \x83\x01R\x91@`4\x82\x01R0\x90\x92\x1B\x16`T\x82\x01R`\x01`\x01`\xC0\x1B\x03\x19`\xC0\x83\x90\x1B\x16`h\x82\x01R`p\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x91Pa\x1EV\x81`\x01aVYV[`\x05\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x92\x83\x16\x17\x90U`@\x80Q_\x80\x82R``\x80\x83\x01\x84R` \x80\x84\x01\x83\x81R\x84\x86\x01\x84\x81R\x89\x85R`\x04\x83R\x86\x85 \x91Q\x82T\x91Q`\x01`\x01``\x1B\x03\x90\x91\x16`\x01`\x01`\xA0\x1B\x03\x19\x92\x83\x16\x17`\x01``\x1B\x91\x90\x99\x16\x02\x97\x90\x97\x17\x90U\x84Q\x91\x82\x01\x85R3\x82R\x81\x81\x01\x83\x81R\x82\x86\x01\x85\x81R\x89\x85R`\x03\x83R\x95\x90\x93 \x82Q\x81T\x88\x16`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x17\x82U\x93Q`\x01\x82\x01\x80T\x90\x98\x16\x94\x16\x93\x90\x93\x17\x90\x95U\x92Q\x80Q\x92\x94\x91\x92a\x1F)\x92`\x02\x85\x01\x92\x01\x90aH:V[Pa\x1F9\x91P`\x06\x90P\x84a;1V[P`@Q3\x81R\x83\x90\x7F\x1D0\x15\xD7\xBA\x85\x0F\xA1\x98\xDC{\x1A?]Bw\x93\x13\xA6\x81\x03_w\xC8\xC07d\xC6\x10\x05Q\x8D\x90` \x01`@Q\x80\x91\x03\x90\xA2PPa\x16\x88`\x01_UV[_\x81\x81R_Q` aZ5_9_Q\x90_R` \x81\x90R`@\x90\x91 ``\x91\x90a\x10\xF3\x90a;<V[a\x1F\xB9_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\x0B\x80Ta\xFF\0\x19\x16\x90U`@Q\x7F\xC0\xF9a\x05\x1F\x97\xB0LIdr\xD1\x1C\xB6\x17\r\x84NK,\x9D\xFD;`*O\xA0\x13\x97\x12\xD4\x84\x90_\x90\xA1V[a \x04_Q` aZ\x95_9_Q\x90_Ra3\x8FV[_\x81\x81R`\x03` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a $\x81a;\nV[a\x16k\x82\x82a3\x1FV[``_a ;`\x06a;HV[\x90P\x80\x84\x10a ]W`@Qc\x13\x90\xF2\xA1`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a h\x84\x86aV3V[\x90P\x81\x81\x11\x80a vWP\x83\x15[a \x80W\x80a \x82V[\x81[\x90P_a \x8F\x86\x83aVFV[\x90P\x80`\x01`\x01`@\x1B\x03\x81\x11\x15a \xA9Wa \xA9aI\xEFV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a \xD2W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x93P_[\x81\x81\x10\x15a!\x19Wa \xF4a \xEC\x88\x83aV3V[`\x06\x90a:\xFFV[\x85\x82\x81Q\x81\x10a!\x06Wa!\x06aT\xCAV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a \xD7V[PPPP\x92\x91PPV[a!+a2\xF7V[_\x81\x81R`\x03` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a!K\x81a;\nV[_\x82\x81R`\x03` R`@\x90 `\x01\x01T`\x01`\x01`\xA0\x1B\x03\x163\x14a!\xA2W_\x82\x81R`\x03` R`@\x90\x81\x90 `\x01\x01T\x90Qc\xD0\x84\xE9u`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04\x82\x01R`$\x01a\x0C V[_\x82\x81R`\x03` \x90\x81R`@\x91\x82\x90 \x80T3`\x01`\x01`\xA0\x1B\x03\x19\x91\x82\x16\x81\x17\x83U`\x01\x90\x92\x01\x80T\x90\x91\x16\x90U\x82Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R\x91\x82\x01R\x83\x91\x7F\xD4\x11J\xB6\xE9\xAF\x9FY|R\x04\x1F2\xD6-\xC5|\\NL\rD'\0`ic^!l\x93\x86\x91\x01a\x1D\xBEV[a\"\x16a2\xF7V[a\",_Q` aZ\x95_9_Q\x90_Ra3\x8FV[`\tT`\x01`\x01``\x1B\x03\x16a\"C\x81\x15\x15a8\xD9V[`\t\x80T`\x01`\x01``\x1B\x03\x19\x16\x90U`\x08\x80T\x82\x91\x90_\x90a\"p\x90\x84\x90`\x01`\x01``\x1B\x03\x16aVxV[\x92Pa\x01\0\n\x81T\x81`\x01`\x01``\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01``\x1B\x03\x16\x02\x17\x90UPa\x16\xF2\x82\x82`\x01`\x01``\x1B\x03\x16a8\xF7V[\x81a\"\xB1\x81a2\xA3V[a\"\xB9a2\xF7V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x02` \x90\x81R`@\x80\x83 \x86\x84R\x90\x91R\x90 \x80T`\xFF\x16\x15a\"\xEBWPa\x0FXV[_\x84\x81R`\x03` R`@\x90 `\x02\x01\x80T`c\x19\x01a#\x1EW`@Qc\x05\xA4\x8E\x0F`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81T`\x01`\xFF\x19\x90\x91\x16\x81\x17\x83U\x81T\x90\x81\x01\x82U_\x82\x81R` \x90\x81\x90 \x90\x91\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x16\x90\x81\x17\x90\x91U`@Q\x90\x81R\x86\x91\x7F\x1E\x98\r\x04\xAAvH\xE2\x05q>^\x8E\xA3\x80\x86r\xAC\x16=\x10\x93m6\xF9\x1B,\x88\xAC\x15u\xE1\x91\x01[`@Q\x80\x91\x03\x90\xA2PPa\x0Fa`\x01_UV[a#\xA3aH\x8DV[_\x82\x81R`\x10` \x90\x81R`@\x80\x83 \x81Qa\x01 \x81\x01\x83R\x81T\x81R`\x01\x82\x01T\x93\x81\x01\x93\x90\x93R`\x02\x81\x01Tc\xFF\xFF\xFF\xFF\x16\x91\x83\x01\x91\x90\x91R`\x03\x81\x01T``\x83\x01R`\x04\x81\x01\x80T`\x80\x84\x01\x91\x90a#\xFD\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta$)\x90aSeV[\x80\x15a$tW\x80`\x1F\x10a$KWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a$tV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a$WW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`@\x80Q`\xE0\x81\x01\x90\x91R` \x90\x91\x01\x90`\x05\x83\x01\x81``\x81\x01\x82\x81`\xA0\x84\x01\x82`\x02\x82\x82\x82` \x02\x82\x01\x91[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a$\xA9WPPP\x91\x83RPP`@\x80Q\x80\x82\x01\x91\x82\x90R` \x90\x92\x01\x91\x90`\x02\x84\x81\x01\x91\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a$\xDFWPPPPP\x81RPP\x81R` \x01`\x04\x82\x01\x80Ta%\x0F\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%;\x90aSeV[\x80\x15a%\x86W\x80`\x1F\x10a%]Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a%\x86V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%iW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta%\x9F\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%\xCB\x90aSeV[\x80\x15a&\x16W\x80`\x1F\x10a%\xEDWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\x16V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%\xF9W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01`\x0B\x82\x01\x80Ta&3\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&_\x90aSeV[\x80\x15a&\xAAW\x80`\x1F\x10a&\x81Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\xAAV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&\x8DW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x0C\x82\x01\x80Ta&\xC3\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&\xEF\x90aSeV[\x80\x15a':W\x80`\x1F\x10a'\x11Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a':V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a'\x1DW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\r\x91\x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16` \x90\x91\x01R``\x81\x01Q\x90\x91Pa\x0B\xCAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x1A[\x9D\x98[\x1AY\x08\x1C\x99\\]Y\\\xDD\x12Y`z\x1B`D\x82\x01R`d\x01a\x0C V[``a'\xAF`\x80\x85\x01\x85aV\x97V[\x90Pa\x01\0\x03a(\x01W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7Finvalid decryption key length\0\0\0`D\x82\x01R`d\x01a\x0C V[a\x01\0a(\x11`\xA0\x86\x01\x86aV\x97V[\x90P\x10a(`W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7Fmessage of unsupported length\0\0\0`D\x82\x01R`d\x01a\x0C V[_a(n`\x80\x86\x01\x86aV\x97V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP\x93\x94PPPP[\x83\x81\x10\x15a)\x02W\x84\x84\x82\x81\x81\x10a(\xBEWa(\xBEaT\xCAV[\x90P\x015`\xF8\x1C`\xF8\x1B\x82\x82\x81Q\x81\x10a(\xDAWa(\xDAaT\xCAV[\x01` \x01\x80Q`\x01`\x01`\xF8\x1B\x03\x19\x90\x81\x16\x90\x92\x18\x90\x91\x16\x90_\x82\x90\x1A\x90SP`\x01\x01a(\xA4V[P_a)\x11`\xA0\x87\x01\x87aV\x97V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP`\x0F\x80T\x95\x96P\x90\x94a)\xEF\x94P\x90\x92Pa)[\x91PaSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta)\x87\x90aSeV[\x80\x15a)\xD2W\x80`\x1F\x10a)\xA9Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a)\xD2V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a)\xB5W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x84\x89\x80`\xA0\x01\x90a)\xE8\x91\x90aV\x97V[\x90Pa;QV[\x90P_[a*\0`\xA0\x89\x01\x89aV\x97V[\x90P\x81\x10\x15a*`W\x81\x81\x81Q\x81\x10a*\x1BWa*\x1BaT\xCAV[` \x01\x01Q`\xF8\x1C`\xF8\x1B\x83\x82\x81Q\x81\x10a*8Wa*8aT\xCAV[\x01` \x01\x80Q`\x01`\x01`\xF8\x1B\x03\x19\x90\x81\x16\x90\x92\x18\x90\x91\x16\x90_\x82\x90\x1A\x90SP`\x01\x01a)\xF3V[P_a+\x15`\x0E\x80Ta*r\x90aSeV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta*\x9E\x90aSeV[\x80\x15a*\xE9W\x80`\x1F\x10a*\xC0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a*\xE9V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a*\xCCW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x85\x85`@Q` \x01a+\x01\x92\x91\x90aV\xD9V[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra<\xE6V[\x90P_a+!\x82a=EV[\x90P_\x80a+=\x83a+86\x8E\x90\x03\x8E\x01\x8EaV\xEDV[a=\xD7V[\x90\x92P\x90P`\x01\x82\x15\x15\x82\x15\x15\x14\x14a+\xAFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7Finvalid decryption key / ciphert`D\x82\x01Rm\x19^\x1D\x08\x1C\x99Y\xDA\\\xDD\x19\\\x99Y`\x92\x1B`d\x82\x01R`\x84\x01a\x0C V[P\x93\x99\x98PPPPPPPPPV[_\x81\x81R_Q` aZ5_9_Q\x90_R` \x81\x90R`@\x82 a\x10\xF3\x90a;HV[\x81a+\xEC\x81a2\xA3V[a+\xF4a2\xF7V[a+\xFD\x83a\x11:V[\x15a,\x1BW`@Qc\x16\x85\xEC\xDD`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x02` \x90\x81R`@\x80\x83 \x86\x84R\x90\x91R\x90 T`\xFF\x16a,pW`@Qcy\xBF\xD4\x01`\xE0\x1B\x81R`\x04\x81\x01\x84\x90R`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x01a\x0C V[_\x83\x81R`\x03` R`@\x81 `\x02\x01\x80T\x90\x91[\x81\x81\x10\x15a-sW\x84`\x01`\x01`\xA0\x1B\x03\x16\x83\x82\x81T\x81\x10a,\xA9Wa,\xA9aT\xCAV[_\x91\x82R` \x90\x91 \x01T`\x01`\x01`\xA0\x1B\x03\x16\x03a-kW\x82a,\xCE`\x01\x84aVFV[\x81T\x81\x10a,\xDEWa,\xDEaT\xCAV[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x83\x82\x81T\x81\x10a-\x0BWa-\x0BaT\xCAV[\x90_R` _ \x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP\x82\x80T\x80a-FWa-FaW\x07V[_\x82\x81R` \x90 \x81\x01_\x19\x90\x81\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90U\x01\x90Ua-sV[`\x01\x01a,\x85V[P`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x89\x84R\x82R\x91\x82\x90 \x80T`\xFF\x19\x16\x90U\x90Q\x91\x82R\x86\x91\x7F2\x15\x8C`X4|\x16\x01\xB2\xD1+\xC6\x96\xACi\x01\xD8\xA9\xA9\xAA;\xA1\x0C'\xAB\n\x98>\x84%\xA7\x91\x01a#\x88V[__a-\xD9\x83a#\x9BV[``\x01Q\x90P\x80_\x03a-\xEEWP_\x92\x91PPV[`\x01T`@Qc\xCD\x80,\x91`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\xCD\x80,\x91\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a.5W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xF3\x91\x90aW\x1BV[a.b\x82a\x10QV[a.k\x81a3\x8FV[a\x10\xDC\x83\x83a4\xE8V[\x81a.\x7F\x81a2\xA3V[a.\x87a2\xF7V[_\x83\x81R`\x03` R`@\x90 `\x01\x81\x01T`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x14a/\x08W`\x01\x81\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x85\x16\x90\x81\x17\x90\x91U`@\x80Q3\x81R` \x81\x01\x92\x90\x92R\x85\x91\x7F!\xA4\xDA\xD1p\xA6\xBFGl1\xBB\xCFJ\x16b\x82\x95\xB0\xE4Pg.\xEC%\xD7\xC93\x08\xE0SD\xA1\x91\x01`@Q\x80\x91\x03\x90\xA2[Pa\x0Fa`\x01_UV[_\x81\x81R`\x03` R`@\x81 T\x81\x90`\x01`\x01`\xA0\x1B\x03\x16``a/6\x82a;\nV[_\x85\x81R`\x04` \x90\x81R`@\x80\x83 T`\x03\x83R\x92\x81\x90 `\x02\x01\x80T\x82Q\x81\x85\x02\x81\x01\x85\x01\x90\x93R\x80\x83R`\x01`\x01``\x1B\x03\x85\x16\x94`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16\x93\x87\x93\x91\x83\x91\x83\x01\x82\x82\x80\x15a/\xBBW` \x02\x82\x01\x91\x90_R` _ \x90[\x81T`\x01`\x01`\xA0\x1B\x03\x16\x81R`\x01\x90\x91\x01\x90` \x01\x80\x83\x11a/\x9DW[PPPPP\x90P\x93P\x93P\x93P\x93P\x91\x93P\x91\x93V[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x0B\xCAWPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x0B\xCAV[`\nTc\xFF\xFF\xFF\xFF\x90\x81\x16\x90\x83\x16\x11\x15a0aW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FCallback gasLimit too high\0\0\0\0\0\0`D\x82\x01R`d\x01a\x0C V[\x80\x15a1\xDEW_\x81\x81R`\x03` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a0\x87\x81a;\nV[3_\x90\x81R`\x02` \x90\x81R`@\x80\x83 \x85\x84R\x80\x83R\x92\x81\x90 \x81Q``\x81\x01\x83R\x90T`\xFF\x81\x16\x15\x15\x80\x83R`\x01`\x01`@\x1B\x03a\x01\0\x83\x04\x81\x16\x95\x84\x01\x95\x90\x95R`\x01`H\x1B\x90\x91\x04\x90\x93\x16\x91\x81\x01\x91\x90\x91R\x90a14W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FNo active subscription for calle`D\x82\x01R`9`\xF9\x1B`d\x82\x01R`\x84\x01a\x0C V[\x80` \x01\x80Qa1C\x90aW:V[`\x01`\x01`@\x1B\x03\x16\x90R`@\x81\x01\x80Qa1]\x90aW:V[`\x01`\x01`@\x1B\x03\x90\x81\x16\x90\x91R_\x85\x81R` \x93\x84R`@\x90\x81\x90 \x83Q\x81T\x95\x85\x01Q\x92\x90\x94\x01Q\x83\x16`\x01`H\x1B\x02p\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\x19\x92\x90\x93\x16a\x01\0\x02h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x19\x94\x15\x15\x94\x90\x94\x16h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x95\x16\x94\x90\x94\x17\x92\x90\x92\x17\x91\x90\x91\x16\x17\x90UPPPV[_a1\xEF\x83c\xFF\xFF\xFF\xFF\x16:a3\xDBV[\x90P\x804\x10\x15a\x0FaW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01RjFee too low`\xA8\x1B`D\x82\x01R`d\x01a\x0C V[`\x01T`@Qc\xF8\x7F\x0Ea`\xE0\x1B\x81R_\x91`\x01`\x01`\xA0\x1B\x03\x16\x90c\xF8\x7F\x0Ea\x90a2c\x90\x87\x90\x87\x90\x87\x90`\x04\x01aWdV[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a2\x7FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1C\x87\x91\x90aW\x9CV[_\x81\x81R`\x03` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a2\xC3\x81a;\nV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x16kW`@QclQ\xFD\xA9`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x01a\x0C V[`\x02_T\x03a3\x19W`@Qc>\xE5\xAE\xB5`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_UV[_a3)\x83a?FV[\x90Pa3>\x82\x82`\x01`\x01``\x1B\x03\x16a8\xF7V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R`\x01`\x01``\x1B\x03\x83\x16` \x82\x01R\x84\x91\x7F7\x84\xF7~\x8E\x88=\xE9[]G\xCDq<\xED\x01\"\x9F\xA7M\x11\x8C\nF\"$\xBC\xB0QmC\xF1\x91\x01`@Q\x80\x91\x03\x90\xA2PPPV[a\x16\xFC\x813a@\x97V[__Q` aZ5_9_Q\x90_R\x81a3\xB3\x85\x85a@\xD0V[\x90P\x80\x15a\x1C\x87W_\x85\x81R` \x83\x90R`@\x90 a3\xD2\x90\x85aAqV[P\x94\x93PPPPV[`@\x80Q`\xE0\x81\x01\x82R`\nTc\xFF\xFF\xFF\xFF\x80\x82\x16\x83Rd\x01\0\0\0\0\x82\x04\x81\x16` \x84\x01R`\x01`@\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01``\x1B\x81\x04\x83\x16``\x83\x01R`\x01`\x80\x1B\x81\x04\x83\x16`\x80\x83\x01R`\xFF`\x01`\xA0\x1B\x82\x04\x16`\xA0\x83\x01R`\x01`\xA8\x1B\x90\x04\x90\x91\x16`\xC0\x82\x01R_\x90\x81\x83a4cW\x81``\x01Qc\xFF\xFF\xFF\xFF\x16a4eV[\x83[\x90P_a4q\x86aA\x85V[c\xFF\xFF\xFF\xFF\x16\x83`\x80\x01Qc\xFF\xFF\xFF\xFF\x16\x87\x85` \x01Qc\xFF\xFF\xFF\xFF\x16\x01\x01\x01\x82\x02\x90P_a4\x9D_\x90V[\x90P_\x84`\xA0\x01Q`d\x01`\xFF\x16\x90P_\x85`@\x01Qc\xFF\xFF\xFF\xFF\x16d\xE8\xD4\xA5\x10\0\x02\x90P_\x81`d\x84\x87\x87\x01\x02\x81a4\xD8Wa4\xD8aW\xB3V[\x04\x01\x9A\x99PPPPPPPPPPV[__Q` aZ5_9_Q\x90_R\x81a5\x02\x85\x85aA\x9CV[\x90P\x80\x15a\x1C\x87W_\x85\x81R` \x83\x90R`@\x90 a3\xD2\x90\x85aB\x15V[_\x80\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0a\x0B\xCAV[a5QaB)V[V[`@\x80Q\x80\x82\x01\x82R`\x10\x81Ro\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B` \x82\x01R\x81Q`B\x80\x82R`\x80\x82\x01\x90\x93R``\x92_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P`\x03`\xFC\x1B\x81_\x81Q\x81\x10a5\xB3Wa5\xB3aT\xCAV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a5\xE1Wa5\xE1aT\xCAV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP_[` \x81\x10\x15a7\x12W\x82`\x04\x86\x83` \x81\x10a6\x17Wa6\x17aT\xCAV[\x1A`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x1C`\xF8\x1C`\xFF\x16\x81Q\x81\x10a6=Wa6=aT\xCAV[\x01` \x01Q`\x01`\x01`\xF8\x1B\x03\x19\x16\x82a6X\x83`\x02aW\xC7V[a6c\x90`\x02aV3V[\x81Q\x81\x10a6sWa6saT\xCAV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP\x82\x85\x82` \x81\x10a6\x9CWa6\x9CaT\xCAV[\x82Q\x91\x90\x1A`\x0F\x16\x90\x81\x10a6\xB3Wa6\xB3aT\xCAV[\x01` \x01Q`\x01`\x01`\xF8\x1B\x03\x19\x16\x82a6\xCE\x83`\x02aW\xC7V[a6\xD9\x90`\x02aV3V[a6\xE4\x90`\x01aV3V[\x81Q\x81\x10a6\xF4Wa6\xF4aT\xCAV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x01\x01a5\xF9V[P\x93\x92PPPV[0`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14\x80a7\xA0WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16a7\x94_Q` aZU_9_Q\x90_RT`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x14\x15[\x15a5QW`@Qcp>F\xDD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x16\xFC_Q` aZ\x95_9_Q\x90_Ra3\x8FV[\x81`\x01`\x01`\xA0\x1B\x03\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a8.WP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra8+\x91\x81\x01\x90aW\x9CV[`\x01[a8VW`@QcL\x9C\x8C\xE3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x0C V[_Q` aZU_9_Q\x90_R\x81\x14a8\x86W`@Qc*\x87Ri`\xE2\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x0C V[a\x0Fa\x83\x83aBNV[0`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a5QW`@Qcp>F\xDD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80a\x16\xFCW`@Qc\x1E\x9A\xCF\x17`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82`\x01`\x01`\xA0\x1B\x03\x16\x82`@Q_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a9@W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a9EV[``\x91P[PP\x90P\x80a\x0FaW`@Qc\x95\x0B$y`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_Z_\x85\x81R`\x10` R`@\x81 `\x03\x81\x01T\x92\x93P\x91\x90\x03a9\xCDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FNo request for request id\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x0C V[_c]\x94\x18\x02`\xE0\x1B\x86\x86`@Q`$\x01a9\xE9\x92\x91\x90aW\xDEV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16`\x01`\x01`\xE0\x1B\x03\x19\x90\x93\x16\x92\x90\x92\x17\x90\x91R`\r\x83\x01T`\x02\x84\x01T`\nT\x92\x93P_\x92a:Y\x92\x85\x92`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x91c\xFF\xFF\xFF\xFF\x91\x82\x16\x91`\x01`\xA8\x1B\x90\x91\x04\x81\x16\x90aB\xA3\x16V[P\x90P\x80\x15a:\xCAW`\x0C\x83\x01a:p\x87\x82aS\xDBV[P`\x0B\x83\x01a:\x7F\x86\x82aS\xDBV[P\x86\x7F\x99\xFD\x15\x97L\xBF\0\xF0\xF2\x08\xBA\xAEZ(%\xFAsc\x97\xEA\xC7\xE2\xBA0\x03\xC8'C\x8C\xA0\x93\xF7\x84`\x04\x01\x85`\x05\x01\x86`\x0C\x01`@Qa:\xBD\x93\x92\x91\x90aX\x97V[`@Q\x80\x91\x03\x90\xA2a:\xF5V[`@Q\x87\x90\x7F\x15\x0856Pvf\x80,\xBD\x84\xFC\xC1\xE3~\xD8\x98y\xBA\xD24Z\xAA8\xD4\x8D\x91\xA5\x07\x1D\x0F]\x90_\x90\xA2[a\x166\x87\x85aB\xDAV[_a\x10\xF3\x83\x83aC\xC9V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x16\xFCW`@Qc\x0F\xB52\xDB`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x10\xF3\x83\x83aC\xEFV[``_a\x10\xF3\x83aD;V[_a\x0B\xCA\x82T\x90V[\x82Q``\x90`\xFF\x81\x11\x15a;zW\x84`@Qc\x13r|\xDD`\xE1\x1B\x81R`\x04\x01a\x0C \x91\x90aK\xD1V[`@\x80Q`\x88\x80\x82R`\xC0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_\x81\x86_\x87_\x8B\x88`@Q` \x01a;\xB9\x97\x96\x95\x94\x93\x92\x91\x90aY\x0CV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P_\x81\x80Q\x90` \x01 \x90P_\x81`\x01\x8A\x87`@Q` \x01a;\xEE\x94\x93\x92\x91\x90aYvV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x82\x01 \x90\x91P_`\xFF\x89\x16`\x01`\x01`@\x1B\x03\x81\x11\x15a<$Wa<$aI\xEFV[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a<NW` \x82\x01\x81\x806\x837\x01\x90P[P\x90P_`\x05a<b`\x1F`\xFF\x8D\x16aV3V[\x90\x1C\x90P`\x01[\x81\x81\x10\x15a<\xC8W\x85\x84\x18a<\x7F\x82`\x01aV3V[\x8E\x8B`@Q` \x01a<\x94\x94\x93\x92\x91\x90aYvV[`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x91\x90R` _\x19\x83\x01\x81\x02\x85\x01\x81\x01\x95\x90\x95R\x80Q\x94\x81\x01\x94\x90\x94 \x93\x94P`\x01\x01a<iV[P_\x19\x01` \x90\x81\x02\x82\x01\x01\x91\x90\x91R\x95PPPPPP\x93\x92PPPV[__a<\xF4\x84\x84`0a;QV[`\x18\x81\x01Q`0\x82\x01Q\x91\x92P`\x01`\x01`\xC0\x1B\x03\x91\x82\x16\x91\x16_\x7F0dNr\xE11\xA0)\xB8PE\xB6\x81\x81X]\x97\x81j\x91hq\xCA\x8D< \x8C\x16\xD8|\xFDG\x83\x81`\x01`\xC0\x1B\x85\t\x08\x97\x96PPPPPPPV[`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01Ra=`aH\xDFV[`\x01\x81R`\x02` \x82\x01R`@\x81\x01\x83\x90R_``\x83`\x80\x84`\x07a\x07\xD0Z\x03\xFA\x90P\x80a=\xD0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FG1 scalar multiplication failed\0`D\x82\x01R`d\x01a\x0C V[PP\x91\x90PV[___`@Q\x80a\x01\x80\x01`@R\x80\x86_\x01Q\x81R` \x01\x86` \x01Q\x81R` \x01\x7F\x19\x8E\x93\x93\x92\rH:r`\xBF\xB71\xFB]%\xF1\xAAI35\xA9\xE7\x12\x97\xE4\x85\xB7\xAE\xF3\x12\xC2\x81R` \x01\x7F\x18\0\xDE\xEF\x12\x1F\x1EvBj\0f^\\DygC\"\xD4\xF7^\xDA\xDDF\xDE\xBD\\\xD9\x92\xF6\xED\x81R` \x01\x7F']\xC4\xA2\x88\xD1\xAF\xB3\xCB\xB1\xAC\t\x18u$\xC7\xDB69]\xF7\xBE;\x99\xE6s\xB1:\x07Ze\xEC\x81R` \x01\x7F\x1D\x9B\xEF\xCD\x05\xA52>m\xA4\xD45\xF3\xB6\x17\xCD\xB3\xAF\x83(\\-\xF7\x11\xEF9\xC0\x15q\x82\x7F\x9D\x81R` \x01`\x01\x81R` \x01`\x02\x81R` \x01\x85_\x01Q`\x01`\x02\x81\x10a>\xB5Wa>\xB5aT\xCAV[` \x02\x01Q\x81R` \x01\x85_\x01Q_`\x02\x81\x10a>\xD4Wa>\xD4aT\xCAV[` \x02\x01Q\x81R` \x01\x85` \x01Q`\x01`\x02\x81\x10a>\xF5Wa>\xF5aT\xCAV[` \x02\x01Q\x81R` \x01\x85` \x01Q_`\x02\x81\x10a?\x15Wa?\x15aT\xCAV[` \x02\x01Q\x90R\x90Pa?&aH\xFDV[` \x81a\x01\x80\x84`\x08a\x07\xD0Z\x03\xFA\x90Q\x15\x15\x93P\x91PP[\x92P\x92\x90PV[_\x81\x81R`\x03` \x90\x81R`@\x80\x83 `\x04\x90\x92R\x82 T`\x02\x90\x91\x01\x80T`\x01`\x01``\x1B\x03\x90\x92\x16\x92\x90\x91\x90[\x81\x81\x10\x15a?\xE0W`\x02_\x84\x83\x81T\x81\x10a?\x92Wa?\x92aT\xCAV[_\x91\x82R` \x80\x83 \x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x16\x83R\x82\x81\x01\x93\x90\x93R`@\x91\x82\x01\x81 \x88\x82R\x90\x92R\x90 \x80Tp\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90U`\x01\x01a?uV[P_\x84\x81R`\x03` R`@\x81 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16\x82U`\x01\x82\x01\x80T\x90\x91\x16\x90U\x90a@\x17`\x02\x83\x01\x82aI\x1BV[PP_\x84\x81R`\x04` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90Ua@?`\x06\x85aD\x94V[P`\x01`\x01``\x1B\x03\x83\x16\x15a=\xD0W`\x08\x80T\x84\x91\x90_\x90a@l\x90\x84\x90`\x01`\x01``\x1B\x03\x16aVxV[\x92Pa\x01\0\n\x81T\x81`\x01`\x01``\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01``\x1B\x03\x16\x02\x17\x90UPPP\x91\x90PV[a@\xA1\x82\x82a\x1C\x8FV[a\x16kW`@Qc\xE2Q}?`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x81\x01\x83\x90R`D\x01a\x0C V[__Q` aZu_9_Q\x90_Ra@\xE9\x84\x84a\x1C\x8FV[aAhW_\x84\x81R` \x82\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90UaA\x1E3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x85\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4`\x01\x91PPa\x0B\xCAV[_\x91PPa\x0B\xCAV[_a\x10\xF3\x83`\x01`\x01`\xA0\x1B\x03\x84\x16aC\xEFV[_aA\x91`?\x83aY\xB9V[a\x0B\xCA\x90`\x01aY\xECV[__Q` aZu_9_Q\x90_RaA\xB5\x84\x84a\x1C\x8FV[\x15aAhW_\x84\x81R` \x82\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x87\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4`\x01\x91PPa\x0B\xCAV[_a\x10\xF3\x83`\x01`\x01`\xA0\x1B\x03\x84\x16aD\x9BV[aB1aEuV[a5QW`@Qc\x1A\xFC\xD7\x9F`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aBW\x82aE\x8EV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2\x80Q\x15aB\x9BWa\x0Fa\x82\x82aE\xF1V[a\x16kaFcV[__Z\x83\x81\x10aB\xD0W\x83\x90\x03`@\x81\x04\x81\x03\x85\x10\x15aB\xD0W__\x88Q` \x8A\x01_\x8A\x8A\xF1\x92P`\x01\x91P[P\x94P\x94\x92PPPV[_aB\xE4\x83a#\x9BV[\x80Q\x90\x91P\x15aC\xB8W\x80Q_\x90\x81R`\x04` R`@\x90 \x80T`\x0C\x90aC\x1B\x90`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16aW:V[\x82T`\x01`\x01`@\x1B\x03\x91\x82\x16a\x01\0\x93\x84\n\x90\x81\x02\x90\x83\x02\x19\x90\x91\x16\x17\x90\x92U\x82\x01Q`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x02` \x90\x81R`@\x80\x83 \x85Q\x84R\x90\x91R\x90 \x80T\x90\x91`\t\x91aCz\x91`\x01`H\x1B\x90\x91\x04\x16aZ\x08V[\x91\x90a\x01\0\n\x81T\x81`\x01`\x01`@\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`@\x1B\x03\x16\x02\x17\x90UP_aC\xA9\x83:aF\x82V[\x90Pa\x10\xDC\x81\x83_\x01QaF\xDAV[a\x0Fa\x81` \x01Q\x82_\x01QaF\xDAV[_\x82_\x01\x82\x81T\x81\x10aC\xDEWaC\xDEaT\xCAV[\x90_R` _ \x01T\x90P\x92\x91PPV[_\x81\x81R`\x01\x83\x01` R`@\x81 TaD4WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x0B\xCAV[P_a\x0B\xCAV[``\x81_\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15aD\x88W` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11aDtW[PPPPP\x90P\x91\x90PV[_a\x10\xF3\x83\x83[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15aAhW_aD\xBD`\x01\x83aVFV[\x85T\x90\x91P_\x90aD\xD0\x90`\x01\x90aVFV[\x90P\x80\x82\x14aE/W_\x86_\x01\x82\x81T\x81\x10aD\xEEWaD\xEEaT\xCAV[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10aE\x0EWaE\x0EaT\xCAV[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80aE@WaE@aW\x07V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\x0B\xCAV[_aE~a5!V[T`\x01`@\x1B\x90\x04`\xFF\x16\x91\x90PV[\x80`\x01`\x01`\xA0\x1B\x03\x16;_\x03aE\xC3W`@QcL\x9C\x8C\xE3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R`$\x01a\x0C V[_Q` aZU_9_Q\x90_R\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[``__\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@QaF\r\x91\x90aZ)V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aFEW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aFJV[``\x91P[P\x91P\x91PaFZ\x85\x83\x83aGwV[\x95\x94PPPPPV[4\x15a5QW`@Qc\xB3\x98\x97\x9F`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[__Z`\nTd\x01\0\0\0\0\x90\x04c\xFF\xFF\xFF\xFF\x16\x85\x01\x03\x90P\x82\x81\x02_`\nT`d\x91\x90\x92\x01`\xFF`\x01`\xA0\x1B\x84\x04\x16\x82\x01\x02\x04d\xE8\xD4\xA5\x10\0c\xFF\xFF\xFF\xFF`\x01`@\x1B\x90\x93\x04\x92\x90\x92\x16\x91\x90\x91\x02\x01\x94\x93PPPPV[\x80\x15aG@W_\x81\x81R`\x04` R`@\x90 \x80T`\x01`\x01``\x1B\x03\x90\x81\x16\x90aG\t\x90\x85\x16\x82\x10\x15a8\xD9V[\x81T`\x01`\x01``\x1B\x03\x91\x85\x90\x03\x82\x16`\x01`\x01``\x1B\x03\x19\x91\x82\x16\x17\x90\x92U`\t\x80T\x80\x83\x16\x86\x01\x90\x92\x16\x91\x90\x92\x16\x17\x90UPPV[`\x08\x80T`\x01`\x01``\x1B\x03`\x01``\x1B\x80\x83\x04\x82\x16\x86\x01\x90\x91\x16\x02k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x1B\x19\x90\x91\x16\x17\x90UPPV[``\x82aG\x8CWaG\x87\x82aG\xD3V[a\x10\xF3V[\x81Q\x15\x80\x15aG\xA3WP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15aG\xCCW`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\x0C V[P\x80a\x10\xF3V[\x80Q\x15aG\xE3W\x80Q\x80\x82` \x01\xFD[`@Qc\xD6\xBD\xA2u`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82`\x02\x81\x01\x92\x82\x15aH*W\x91` \x02\x82\x01[\x82\x81\x11\x15aH*W\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90aH\x0FV[PaH6\x92\x91PaI2V[P\x90V[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15aH*W\x91` \x02\x82\x01[\x82\x81\x11\x15aH*W\x82Q\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x17\x82U` \x90\x92\x01\x91`\x01\x90\x91\x01\x90aHXV[`@Q\x80a\x01 \x01`@R\x80_\x81R` \x01_\x81R` \x01_c\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81R` \x01``\x81R` \x01aH\xC6aIFV[\x81R``` \x82\x01\x81\x90R`@\x82\x01\x81\x90R_\x91\x01R\x90V[`@Q\x80``\x01`@R\x80`\x03\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80` \x01`@R\x80`\x01\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x16\xFC\x91\x90[[\x80\x82\x11\x15aH6W_\x81U`\x01\x01aI3V[`@Q\x80``\x01`@R\x80aIYaImV[\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Q\x80`@\x01`@R\x80aI\x80aI\x92V[\x81R` \x01aI\x8DaI\x92V[\x90R\x90V[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[_` \x82\x84\x03\x12\x15aI\xC0W__\xFD[\x815`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\x10\xF3W__\xFD[\x805c\xFF\xFF\xFF\xFF\x81\x16\x81\x14aI\xEAW__\xFD[\x91\x90PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@\x80Q\x90\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15aJ%WaJ%aI\xEFV[`@R\x90V[_\x82`\x1F\x83\x01\x12aJ:W__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15aJSWaJSaI\xEFV[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15aJ\x81WaJ\x81aI\xEFV[`@R\x81\x81R\x83\x82\x01` \x01\x85\x10\x15aJ\x98W__\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[_`\xC0\x82\x84\x03\x12\x15aJ\xC4W__\xFD[P\x91\x90PV[____`\x80\x85\x87\x03\x12\x15aJ\xDDW__\xFD[aJ\xE6\x85aI\xD7V[\x93P` \x85\x015\x92P`@\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aK\x07W__\xFD[aK\x13\x87\x82\x88\x01aJ+V[\x92PP``\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aK.W__\xFD[aK:\x87\x82\x88\x01aJ\xB4V[\x91PP\x92\x95\x91\x94P\x92PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x16\xFCW__\xFD[__`@\x83\x85\x03\x12\x15aKkW__\xFD[\x825\x91P` \x83\x015aK}\x81aKFV[\x80\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15aK\x98W__\xFD[\x815a\x10\xF3\x81aKFV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x10\xF3` \x83\x01\x84aK\xA3V[_` \x82\x84\x03\x12\x15aK\xF3W__\xFD[P5\x91\x90PV[__`@\x83\x85\x03\x12\x15aL\x0BW__\xFD[aL\x14\x83aI\xD7V[\x94` \x93\x90\x93\x015\x93PPPV[_______`\xE0\x88\x8A\x03\x12\x15aL8W__\xFD[aLA\x88aI\xD7V[\x96PaLO` \x89\x01aI\xD7V[\x95PaL]`@\x89\x01aI\xD7V[\x94PaLk``\x89\x01aI\xD7V[\x93PaLy`\x80\x89\x01aI\xD7V[\x92P`\xA0\x88\x015`\xFF\x81\x16\x81\x14aL\x8EW__\xFD[\x91PaL\x9C`\xC0\x89\x01aI\xD7V[\x90P\x92\x95\x98\x91\x94\x97P\x92\x95PV[__`@\x83\x85\x03\x12\x15aL\xBBW__\xFD[\x825aL\xC6\x81aKFV[\x91P` \x83\x015aK}\x81aKFV[_` \x82\x84\x03\x12\x15aL\xE6W__\xFD[a\x10\xF3\x82aI\xD7V[__`@\x83\x85\x03\x12\x15aM\0W__\xFD[\x825aM\x0B\x81aKFV[\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aM%W__\xFD[aM1\x85\x82\x86\x01aJ+V[\x91PP\x92P\x92\x90PV[__\x83`\x1F\x84\x01\x12aMKW__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15aMaW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a??W__\xFD[_____``\x86\x88\x03\x12\x15aM\x8CW__\xFD[\x855\x94P` \x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aM\xA8W__\xFD[aM\xB4\x88\x82\x89\x01aM;V[\x90\x95P\x93PP`@\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aM\xD2W__\xFD[aM\xDE\x88\x82\x89\x01aM;V[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[\x80_[`\x02\x81\x10\x15a\x10\xDCW\x81Q\x84R` \x93\x84\x01\x93\x90\x91\x01\x90`\x01\x01aM\xF2V[_\x81QaN\x1F\x84\x82QaM\xEFV[` \x01QaN0`@\x85\x01\x82aM\xEFV[P` \x82\x01Q`\xC0`\x80\x85\x01RaNJ`\xC0\x85\x01\x82aK\xA3V[\x90P`@\x83\x01Q\x84\x82\x03`\xA0\x86\x01RaFZ\x82\x82aK\xA3V[\x89\x81R\x88` \x82\x01Rc\xFF\xFF\xFF\xFF\x88\x16`@\x82\x01R\x86``\x82\x01Ra\x01 `\x80\x82\x01R_aN\x95a\x01 \x83\x01\x88aK\xA3V[\x82\x81\x03`\xA0\x84\x01RaN\xA7\x81\x88aN\x11V[\x90P\x82\x81\x03`\xC0\x84\x01RaN\xBB\x81\x87aK\xA3V[\x90P\x82\x81\x03`\xE0\x84\x01RaN\xCF\x81\x86aK\xA3V[\x91PP`\x01\x80`\xA0\x1B\x03\x83\x16a\x01\0\x83\x01R\x9A\x99PPPPPPPPPPV[____``\x85\x87\x03\x12\x15aO\x02W__\xFD[aO\x0B\x85aI\xD7V[\x93P` \x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aO%W__\xFD[aO1\x87\x82\x88\x01aM;V[\x90\x94P\x92PP`@\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aK.W__\xFD[__`@\x83\x85\x03\x12\x15aO`W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15aO\xA8W\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01aO\x81V[P\x93\x94\x93PPPPV[` \x81R_a\x10\xF3` \x83\x01\x84aOoV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15aO\xFBW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01aO\xDDV[P\x90\x95\x94PPPPPV[` \x81R\x81Q` \x82\x01R` \x82\x01Q`@\x82\x01R_`@\x83\x01QaP3``\x84\x01\x82c\xFF\xFF\xFF\xFF\x16\x90RV[P``\x83\x01Q`\x80\x83\x01R`\x80\x83\x01Qa\x01 `\xA0\x84\x01RaPYa\x01@\x84\x01\x82aK\xA3V[\x90P`\xA0\x84\x01Q`\x1F\x19\x84\x83\x03\x01`\xC0\x85\x01RaPv\x82\x82aN\x11V[\x91PP`\xC0\x84\x01Q`\x1F\x19\x84\x83\x03\x01`\xE0\x85\x01RaP\x94\x82\x82aK\xA3V[\x91PP`\xE0\x84\x01Q`\x1F\x19\x84\x83\x03\x01a\x01\0\x85\x01RaP\xB3\x82\x82aK\xA3V[\x91PPa\x01\0\x84\x01Qa7\x12a\x01 \x85\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[___`@\x84\x86\x03\x12\x15aP\xE4W__\xFD[\x835`\x01`\x01`@\x1B\x03\x81\x11\x15aP\xF9W__\xFD[aQ\x05\x86\x82\x87\x01aJ\xB4V[\x93PP` \x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aQ W__\xFD[aQ,\x86\x82\x87\x01aM;V[\x94\x97\x90\x96P\x93\x94PPPPV[`\x01`\x01``\x1B\x03\x85\x16\x81R`\x01`\x01`@\x1B\x03\x84\x16` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16`@\x82\x01R`\x80``\x82\x01\x81\x90R_\x90a\x1CX\x90\x83\x01\x84aOoV[__\x835`\x1E\x19\x846\x03\x01\x81\x12aQ\x8FW__\xFD[\x83\x01` \x81\x01\x92P5\x90P`\x01`\x01`@\x1B\x03\x81\x11\x15aQ\xADW__\xFD[\x806\x03\x82\x13\x15a??W__\xFD[\x81\x83R\x81\x81` \x85\x017P_\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1F\x90\x91\x01`\x1F\x19\x16\x90\x91\x01\x01\x90V[`@\x81\x837`@\x80\x82\x01`@\x84\x017_aR\0`\x80\x83\x01\x83aQzV[`\xC0`\x80\x86\x01RaR\x15`\xC0\x86\x01\x82\x84aQ\xBBV[\x91PPaR%`\xA0\x84\x01\x84aQzV[\x85\x83\x03`\xA0\x87\x01Ra\x1CX\x83\x82\x84aQ\xBBV[` \x81R_a\x10\xF3` \x83\x01\x84aQ\xE3V[_\x82`\x1F\x83\x01\x12aRYW__\xFD[aRaaJ\x03V[\x80`@\x84\x01\x85\x81\x11\x15aRrW__\xFD[\x84[\x81\x81\x10\x15aO\xFBW\x805\x84R` \x93\x84\x01\x93\x01aRtV[_`\x80\x82\x84\x03\x12\x15aR\x9CW__\xFD[aR\xA4aJ\x03V[\x90PaR\xB0\x83\x83aRJV[\x81RaR\xBF\x83`@\x84\x01aRJV[` \x82\x01R\x92\x91PPV[_`\xC0\x826\x03\x12\x15aR\xDAW__\xFD[`@Q``\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15aR\xFCWaR\xFCaI\xEFV[`@RaS\t6\x84aR\x8CV[\x81R`\x80\x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aS#W__\xFD[aS/6\x82\x86\x01aJ+V[` \x83\x01RP`\xA0\x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15aSMW__\xFD[aSY6\x82\x86\x01aJ+V[`@\x83\x01RP\x92\x91PPV[`\x01\x81\x81\x1C\x90\x82\x16\x80aSyW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03aJ\xC4WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[`\x1F\x82\x11\x15a\x0FaW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15aS\xBCWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x17\xCBW_\x81U`\x01\x01aS\xC8V[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15aS\xF4WaS\xF4aI\xEFV[aT\x08\x81aT\x02\x84TaSeV[\x84aS\x97V[` `\x1F\x82\x11`\x01\x81\x14aT:W_\x83\x15aT#WP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x17\xCBV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15aTiW\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01aTIV[P\x84\x82\x10\x15aT\x86W\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[``\x81R_aT\xA7``\x83\x01\x86aK\xA3V[\x82\x81\x03` \x84\x01RaT\xB9\x81\x86aQ\xE3V[\x91PP\x82`@\x83\x01R\x94\x93PPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x7FBLOCKLOCK_BN254G1_XMD:KECCAK-256\x81Rk_SVDW_RO_H1_`\xA0\x1B` \x82\x01R_aU;`,\x83\x01\x84aT\xDEV[`_`\xF8\x1B\x81R`\x01\x01\x93\x92PPPV[\x7FBLOCKLOCK_BN254_XMD:KECCAK-256_H\x81Ra2_`\xF0\x1B` \x82\x01R_aU;`\"\x83\x01\x84aT\xDEV[\x7FBLOCKLOCK_BN254_XMD:KECCAK-256_H\x81Ra3_`\xF0\x1B` \x82\x01R_aU;`\"\x83\x01\x84aT\xDEV[\x7FBLOCKLOCK_BN254_XMD:KECCAK-256_H\x81Ra4_`\xF0\x1B` \x82\x01R_aU;`\"\x83\x01\x84aT\xDEV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[`\x01`\x01``\x1B\x03\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[\x80\x82\x01\x80\x82\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[\x81\x81\x03\x81\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[`\x01`\x01`@\x1B\x03\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[`\x01`\x01``\x1B\x03\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[__\x835`\x1E\x19\x846\x03\x01\x81\x12aV\xACW__\xFD[\x83\x01\x805\x91P`\x01`\x01`@\x1B\x03\x82\x11\x15aV\xC5W__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15a??W__\xFD[_a\x1C\x87aV\xE7\x83\x86aT\xDEV[\x84aT\xDEV[_`\x80\x82\x84\x03\x12\x15aV\xFDW__\xFD[a\x10\xF3\x83\x83aR\x8CV[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15aW+W__\xFD[\x81Q\x80\x15\x15\x81\x14a\x10\xF3W__\xFD[_`\x01`\x01`@\x1B\x03\x82\x16`\x01`\x01`@\x1B\x03\x81\x03aW[WaW[aV\0V[`\x01\x01\x92\x91PPV[``\x81R_aWv``\x83\x01\x86aK\xA3V[\x82\x81\x03` \x84\x01RaW\x88\x81\x86aK\xA3V[\x90P\x82\x81\x03`@\x84\x01Ra\x1CX\x81\x85aK\xA3V[_` \x82\x84\x03\x12\x15aW\xACW__\xFD[PQ\x91\x90PV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x0B\xCAWa\x0B\xCAaV\0V[\x82\x81R`@` \x82\x01R_a\x1C\x87`@\x83\x01\x84aK\xA3V[_\x81TaX\x02\x81aSeV[\x80\x85R`\x01\x82\x16\x80\x15aX\x1CW`\x01\x81\x14aX8WaXlV[`\xFF\x19\x83\x16` \x87\x01R` \x82\x15\x15`\x05\x1B\x87\x01\x01\x93PaXlV[\x84_R` _ _[\x83\x81\x10\x15aXcW\x81T` \x82\x8A\x01\x01R`\x01\x82\x01\x91P` \x81\x01\x90PaXAV[\x87\x01` \x01\x94PP[PPP\x92\x91PPV[\x80_[`\x02\x81\x10\x15a\x10\xDCW\x81T\x84R` \x90\x93\x01\x92`\x01\x91\x82\x01\x91\x01aXxV[``\x81R_aX\xA9``\x83\x01\x86aW\xF6V[\x82\x81\x03` \x84\x01RaX\xBB\x81\x86aXuV[aX\xCB`@\x82\x01`\x02\x87\x01aXuV[`\xC0`\x80\x82\x01RaX\xE2`\xC0\x82\x01`\x04\x87\x01aW\xF6V[\x81\x81\x03`\xA0\x83\x01RaX\xF7\x81`\x05\x88\x01aW\xF6V[\x91PP\x82\x81\x03`@\x84\x01Ra\x1CX\x81\x85aW\xF6V[_aY aY\x1A\x83\x8BaT\xDEV[\x89aT\xDEV[`\x01`\x01`\xF8\x1B\x03\x19`\xF8\x89\x81\x1B\x82\x16\x83R\x88\x81\x1B\x82\x16`\x01\x84\x01R\x87\x90\x1B\x16`\x02\x82\x01RaYR`\x03\x82\x01\x86aT\xDEV[`\xF8\x94\x90\x94\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x84RPP`\x01\x90\x91\x01\x97\x96PPPPPPPV[\x84\x81R`\xF8\x84\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x82\x01R_aY\x9B`!\x83\x01\x85aT\xDEV[`\xF8\x93\x90\x93\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x83RPP`\x01\x01\x93\x92PPPV[_c\xFF\xFF\xFF\xFF\x83\x16\x80aY\xDAWcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[\x80c\xFF\xFF\xFF\xFF\x84\x16\x04\x91PP\x92\x91PPV[c\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x0B\xCAWa\x0B\xCAaV\0V[_`\x01`\x01`@\x1B\x03\x82\x16\x80aZ WaZ aV\0V[_\x19\x01\x92\x91PPV[_a\x10\xF3\x82\x84aT\xDEV\xFE\xC1\xF6\xFE$b\x1C\xE8\x1E\xC5\x82|\xAF\x02S\xCA\xDBtp\x9B\x06\x160\xE6\xB5^\x827\x17\x05\x93 \x006\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BalanceInvariantViolated(uint256,uint256)` and selector `0xa99da302`.
```solidity
error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BalanceInvariantViolated {
        #[allow(missing_docs)]
        pub internalBalance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub externalBalance: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BalanceInvariantViolated>
        for UnderlyingRustTuple<'_> {
            fn from(value: BalanceInvariantViolated) -> Self {
                (value.internalBalance, value.externalBalance)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for BalanceInvariantViolated {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    internalBalance: tuple.0,
                    externalBalance: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BalanceInvariantViolated {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BalanceInvariantViolated(uint256,uint256)";
            const SELECTOR: [u8; 4] = [169u8, 157u8, 163u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.internalBalance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.externalBalance),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedToSendNative()` and selector `0x950b2479`.
```solidity
error FailedToSendNative();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedToSendNative;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedToSendNative> for UnderlyingRustTuple<'_> {
            fn from(value: FailedToSendNative) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedToSendNative {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedToSendNative {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedToSendNative()";
            const SELECTOR: [u8; 4] = [149u8, 11u8, 36u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IndexOutOfRange()` and selector `0x1390f2a1`.
```solidity
error IndexOutOfRange();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IndexOutOfRange;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IndexOutOfRange> for UnderlyingRustTuple<'_> {
            fn from(value: IndexOutOfRange) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IndexOutOfRange {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IndexOutOfRange {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IndexOutOfRange()";
            const SELECTOR: [u8; 4] = [19u8, 144u8, 242u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientBalance()` and selector `0xf4d678b8`.
```solidity
error InsufficientBalance();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance()";
            const SELECTOR: [u8; 4] = [244u8, 214u8, 120u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidCalldata()` and selector `0x8129bbcd`.
```solidity
error InvalidCalldata();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidCalldata;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidCalldata> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidCalldata) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidCalldata {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidCalldata {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidCalldata()";
            const SELECTOR: [u8; 4] = [129u8, 41u8, 187u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidConsumer(uint256,address)` and selector `0x79bfd401`.
```solidity
error InvalidConsumer(uint256 subId, address consumer);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidConsumer {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub consumer: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidConsumer> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidConsumer) -> Self {
                (value.subId, value.consumer)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidConsumer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    subId: tuple.0,
                    consumer: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidConsumer {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidConsumer(uint256,address)";
            const SELECTOR: [u8; 4] = [121u8, 191u8, 212u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.consumer,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidDSTLength(bytes)` and selector `0x26e4f9ba`.
```solidity
error InvalidDSTLength(bytes dst);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDSTLength {
        #[allow(missing_docs)]
        pub dst: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDSTLength> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDSTLength) -> Self {
                (value.dst,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidDSTLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { dst: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDSTLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDSTLength(bytes)";
            const SELECTOR: [u8; 4] = [38u8, 228u8, 249u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.dst,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidSubscription()` and selector `0x1f6a65b6`.
```solidity
error InvalidSubscription();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSubscription;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSubscription> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSubscription) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSubscription {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSubscription {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSubscription()";
            const SELECTOR: [u8; 4] = [31u8, 106u8, 101u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `MustBeRequestedOwner(address)` and selector `0xd084e975`.
```solidity
error MustBeRequestedOwner(address proposedOwner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MustBeRequestedOwner {
        #[allow(missing_docs)]
        pub proposedOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MustBeRequestedOwner> for UnderlyingRustTuple<'_> {
            fn from(value: MustBeRequestedOwner) -> Self {
                (value.proposedOwner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MustBeRequestedOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { proposedOwner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MustBeRequestedOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MustBeRequestedOwner(address)";
            const SELECTOR: [u8; 4] = [208u8, 132u8, 233u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.proposedOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `MustBeSubOwner(address)` and selector `0xd8a3fb52`.
```solidity
error MustBeSubOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MustBeSubOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MustBeSubOwner> for UnderlyingRustTuple<'_> {
            fn from(value: MustBeSubOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MustBeSubOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MustBeSubOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MustBeSubOwner(address)";
            const SELECTOR: [u8; 4] = [216u8, 163u8, 251u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `PendingRequestExists()` and selector `0xb42f66e8`.
```solidity
error PendingRequestExists();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PendingRequestExists;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PendingRequestExists> for UnderlyingRustTuple<'_> {
            fn from(value: PendingRequestExists) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PendingRequestExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PendingRequestExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PendingRequestExists()";
            const SELECTOR: [u8; 4] = [180u8, 47u8, 102u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TooManyConsumers()` and selector `0x05a48e0f`.
```solidity
error TooManyConsumers();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TooManyConsumers;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TooManyConsumers> for UnderlyingRustTuple<'_> {
            fn from(value: TooManyConsumers) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TooManyConsumers {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TooManyConsumers {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TooManyConsumers()";
            const SELECTOR: [u8; 4] = [5u8, 164u8, 142u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BlocklockCallbackFailed(uint256)` and selector `0x15083536507666802cbd84fcc1e37ed89879bad2345aaa38d48d91a5071d0f5d`.
```solidity
event BlocklockCallbackFailed(uint256 indexed requestId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlocklockCallbackFailed {
        #[allow(missing_docs)]
        pub requestId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlocklockCallbackFailed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "BlocklockCallbackFailed(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                21u8, 8u8, 53u8, 54u8, 80u8, 118u8, 102u8, 128u8, 44u8, 189u8, 132u8,
                252u8, 193u8, 227u8, 126u8, 216u8, 152u8, 121u8, 186u8, 210u8, 52u8,
                90u8, 170u8, 56u8, 212u8, 141u8, 145u8, 165u8, 7u8, 29u8, 15u8, 93u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { requestId: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.requestId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.requestId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlocklockCallbackFailed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlocklockCallbackFailed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &BlocklockCallbackFailed,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BlocklockCallbackSuccess(uint256,bytes,((uint256[2],uint256[2]),bytes,bytes),bytes)` and selector `0x99fd15974cbf00f0f208baae5a2825fa736397eac7e2ba3003c827438ca093f7`.
```solidity
event BlocklockCallbackSuccess(uint256 indexed requestId, bytes condition, TypesLib.Ciphertext ciphertext, bytes decryptionKey);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlocklockCallbackSuccess {
        #[allow(missing_docs)]
        pub requestId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub condition: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub decryptionKey: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlocklockCallbackSuccess {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                TypesLib::Ciphertext,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "BlocklockCallbackSuccess(uint256,bytes,((uint256[2],uint256[2]),bytes,bytes),bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                153u8, 253u8, 21u8, 151u8, 76u8, 191u8, 0u8, 240u8, 242u8, 8u8, 186u8,
                174u8, 90u8, 40u8, 37u8, 250u8, 115u8, 99u8, 151u8, 234u8, 199u8, 226u8,
                186u8, 48u8, 3u8, 200u8, 39u8, 67u8, 140u8, 160u8, 147u8, 247u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    requestId: topics.1,
                    condition: data.0,
                    ciphertext: data.1,
                    decryptionKey: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.condition,
                    ),
                    <TypesLib::Ciphertext as alloy_sol_types::SolType>::tokenize(
                        &self.ciphertext,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionKey,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.requestId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.requestId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlocklockCallbackSuccess {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlocklockCallbackSuccess> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &BlocklockCallbackSuccess,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BlocklockRequested(uint256,bytes,((uint256[2],uint256[2]),bytes,bytes),address,uint256)` and selector `0xa7cf57609b4abed689b408db0b0c3dc6309786b6c07d5efbbd1d5b150e6d2c06`.
```solidity
event BlocklockRequested(uint256 indexed requestId, bytes condition, TypesLib.Ciphertext ciphertext, address indexed requester, uint256 requestedAt);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlocklockRequested {
        #[allow(missing_docs)]
        pub requestId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub condition: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub requester: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub requestedAt: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlocklockRequested {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                TypesLib::Ciphertext,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BlocklockRequested(uint256,bytes,((uint256[2],uint256[2]),bytes,bytes),address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                167u8, 207u8, 87u8, 96u8, 155u8, 74u8, 190u8, 214u8, 137u8, 180u8, 8u8,
                219u8, 11u8, 12u8, 61u8, 198u8, 48u8, 151u8, 134u8, 182u8, 192u8, 125u8,
                94u8, 251u8, 189u8, 29u8, 91u8, 21u8, 14u8, 109u8, 44u8, 6u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    requestId: topics.1,
                    condition: data.0,
                    ciphertext: data.1,
                    requester: topics.2,
                    requestedAt: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.condition,
                    ),
                    <TypesLib::Ciphertext as alloy_sol_types::SolType>::tokenize(
                        &self.ciphertext,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestedAt),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.requestId.clone(),
                    self.requester.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.requestId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.requester,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlocklockRequested {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlocklockRequested> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BlocklockRequested) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ConfigSet(uint32,uint32,uint32,uint32,uint32,uint8,uint32)` and selector `0x55a28fde295f482c9f32d670c116103bca15724bcef4f18b35542e0553c35ad5`.
```solidity
event ConfigSet(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation, uint32 fulfillmentFlatFeeNativePPM, uint32 weiPerUnitGas, uint32 blsPairingCheckOverhead, uint8 nativePremiumPercentage, uint32 gasForCallExactCheck);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ConfigSet {
        #[allow(missing_docs)]
        pub maxGasLimit: u32,
        #[allow(missing_docs)]
        pub gasAfterPaymentCalculation: u32,
        #[allow(missing_docs)]
        pub fulfillmentFlatFeeNativePPM: u32,
        #[allow(missing_docs)]
        pub weiPerUnitGas: u32,
        #[allow(missing_docs)]
        pub blsPairingCheckOverhead: u32,
        #[allow(missing_docs)]
        pub nativePremiumPercentage: u8,
        #[allow(missing_docs)]
        pub gasForCallExactCheck: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ConfigSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ConfigSet(uint32,uint32,uint32,uint32,uint32,uint8,uint32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                85u8, 162u8, 143u8, 222u8, 41u8, 95u8, 72u8, 44u8, 159u8, 50u8, 214u8,
                112u8, 193u8, 22u8, 16u8, 59u8, 202u8, 21u8, 114u8, 75u8, 206u8, 244u8,
                241u8, 139u8, 53u8, 84u8, 46u8, 5u8, 83u8, 195u8, 90u8, 213u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    maxGasLimit: data.0,
                    gasAfterPaymentCalculation: data.1,
                    fulfillmentFlatFeeNativePPM: data.2,
                    weiPerUnitGas: data.3,
                    blsPairingCheckOverhead: data.4,
                    nativePremiumPercentage: data.5,
                    gasForCallExactCheck: data.6,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxGasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.gasAfterPaymentCalculation,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.fulfillmentFlatFeeNativePPM,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.weiPerUnitGas),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.blsPairingCheckOverhead,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.nativePremiumPercentage,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasForCallExactCheck),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ConfigSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ConfigSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ConfigSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DecryptionSenderUpdated(address)` and selector `0x0dae1d002e96c238ebe140ca1799f77093ae09e0bde40f79bb29ed78d09e652d`.
```solidity
event DecryptionSenderUpdated(address indexed decryptionSender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DecryptionSenderUpdated {
        #[allow(missing_docs)]
        pub decryptionSender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DecryptionSenderUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DecryptionSenderUpdated(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8, 174u8, 29u8, 0u8, 46u8, 150u8, 194u8, 56u8, 235u8, 225u8, 64u8,
                202u8, 23u8, 153u8, 247u8, 112u8, 147u8, 174u8, 9u8, 224u8, 189u8, 228u8,
                15u8, 121u8, 187u8, 41u8, 237u8, 120u8, 208u8, 158u8, 101u8, 45u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { decryptionSender: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.decryptionSender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.decryptionSender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DecryptionSenderUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DecryptionSenderUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &DecryptionSenderUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Disabled()` and selector `0x75884cdadc4a89e8b545db800057f06ec7f5338a08183c7ba515f2bfdd9fe1e1`.
```solidity
event Disabled();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Disabled;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Disabled {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Disabled()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                117u8, 136u8, 76u8, 218u8, 220u8, 74u8, 137u8, 232u8, 181u8, 69u8, 219u8,
                128u8, 0u8, 87u8, 240u8, 110u8, 199u8, 245u8, 51u8, 138u8, 8u8, 24u8,
                60u8, 123u8, 165u8, 21u8, 242u8, 191u8, 221u8, 159u8, 225u8, 225u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Disabled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Disabled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Disabled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Enabled()` and selector `0xc0f961051f97b04c496472d11cb6170d844e4b2c9dfd3b602a4fa0139712d484`.
```solidity
event Enabled();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Enabled;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Enabled {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Enabled()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                192u8, 249u8, 97u8, 5u8, 31u8, 151u8, 176u8, 76u8, 73u8, 100u8, 114u8,
                209u8, 28u8, 182u8, 23u8, 13u8, 132u8, 78u8, 75u8, 44u8, 157u8, 253u8,
                59u8, 96u8, 42u8, 79u8, 160u8, 19u8, 151u8, 18u8, 212u8, 132u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Enabled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Enabled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Enabled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `L1GasFee(uint256)` and selector `0x56296f7beae05a0db815737fdb4cd298897b1e517614d62468081531ae14d099`.
```solidity
event L1GasFee(uint256 fee);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct L1GasFee {
        #[allow(missing_docs)]
        pub fee: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for L1GasFee {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "L1GasFee(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                86u8, 41u8, 111u8, 123u8, 234u8, 224u8, 90u8, 13u8, 184u8, 21u8, 115u8,
                127u8, 219u8, 76u8, 210u8, 152u8, 137u8, 123u8, 30u8, 81u8, 118u8, 20u8,
                214u8, 36u8, 104u8, 8u8, 21u8, 49u8, 174u8, 20u8, 208u8, 153u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { fee: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fee),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for L1GasFee {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&L1GasFee> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &L1GasFee) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SubscriptionCanceled(uint256,address,uint256)` and selector `0x3784f77e8e883de95b5d47cd713ced01229fa74d118c0a462224bcb0516d43f1`.
```solidity
event SubscriptionCanceled(uint256 indexed subId, address to, uint256 amountNative);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubscriptionCanceled {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amountNative: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubscriptionCanceled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SubscriptionCanceled(uint256,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                55u8, 132u8, 247u8, 126u8, 142u8, 136u8, 61u8, 233u8, 91u8, 93u8, 71u8,
                205u8, 113u8, 60u8, 237u8, 1u8, 34u8, 159u8, 167u8, 77u8, 17u8, 140u8,
                10u8, 70u8, 34u8, 36u8, 188u8, 176u8, 81u8, 109u8, 67u8, 241u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    subId: topics.1,
                    to: data.0,
                    amountNative: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountNative),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.subId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.subId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubscriptionCanceled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubscriptionCanceled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SubscriptionCanceled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SubscriptionConsumerAdded(uint256,address)` and selector `0x1e980d04aa7648e205713e5e8ea3808672ac163d10936d36f91b2c88ac1575e1`.
```solidity
event SubscriptionConsumerAdded(uint256 indexed subId, address consumer);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubscriptionConsumerAdded {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub consumer: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubscriptionConsumerAdded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SubscriptionConsumerAdded(uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                30u8, 152u8, 13u8, 4u8, 170u8, 118u8, 72u8, 226u8, 5u8, 113u8, 62u8,
                94u8, 142u8, 163u8, 128u8, 134u8, 114u8, 172u8, 22u8, 61u8, 16u8, 147u8,
                109u8, 54u8, 249u8, 27u8, 44u8, 136u8, 172u8, 21u8, 117u8, 225u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    subId: topics.1,
                    consumer: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.consumer,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.subId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.subId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubscriptionConsumerAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubscriptionConsumerAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &SubscriptionConsumerAdded,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SubscriptionConsumerRemoved(uint256,address)` and selector `0x32158c6058347c1601b2d12bc696ac6901d8a9a9aa3ba10c27ab0a983e8425a7`.
```solidity
event SubscriptionConsumerRemoved(uint256 indexed subId, address consumer);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubscriptionConsumerRemoved {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub consumer: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubscriptionConsumerRemoved {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SubscriptionConsumerRemoved(uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                50u8, 21u8, 140u8, 96u8, 88u8, 52u8, 124u8, 22u8, 1u8, 178u8, 209u8,
                43u8, 198u8, 150u8, 172u8, 105u8, 1u8, 216u8, 169u8, 169u8, 170u8, 59u8,
                161u8, 12u8, 39u8, 171u8, 10u8, 152u8, 62u8, 132u8, 37u8, 167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    subId: topics.1,
                    consumer: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.consumer,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.subId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.subId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubscriptionConsumerRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubscriptionConsumerRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &SubscriptionConsumerRemoved,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SubscriptionCreated(uint256,address)` and selector `0x1d3015d7ba850fa198dc7b1a3f5d42779313a681035f77c8c03764c61005518d`.
```solidity
event SubscriptionCreated(uint256 indexed subId, address owner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubscriptionCreated {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubscriptionCreated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SubscriptionCreated(uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                29u8, 48u8, 21u8, 215u8, 186u8, 133u8, 15u8, 161u8, 152u8, 220u8, 123u8,
                26u8, 63u8, 93u8, 66u8, 119u8, 147u8, 19u8, 166u8, 129u8, 3u8, 95u8,
                119u8, 200u8, 192u8, 55u8, 100u8, 198u8, 16u8, 5u8, 81u8, 141u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    subId: topics.1,
                    owner: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.subId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.subId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubscriptionCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubscriptionCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SubscriptionCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SubscriptionFundedWithNative(uint256,uint256,uint256)` and selector `0x7603b205d03651ee812f803fccde89f1012e545a9c99f0abfea9cedd0fd8e902`.
```solidity
event SubscriptionFundedWithNative(uint256 indexed subId, uint256 oldNativeBalance, uint256 newNativeBalance);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubscriptionFundedWithNative {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub oldNativeBalance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newNativeBalance: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubscriptionFundedWithNative {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SubscriptionFundedWithNative(uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                118u8, 3u8, 178u8, 5u8, 208u8, 54u8, 81u8, 238u8, 129u8, 47u8, 128u8,
                63u8, 204u8, 222u8, 137u8, 241u8, 1u8, 46u8, 84u8, 90u8, 156u8, 153u8,
                240u8, 171u8, 254u8, 169u8, 206u8, 221u8, 15u8, 216u8, 233u8, 2u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    subId: topics.1,
                    oldNativeBalance: data.0,
                    newNativeBalance: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldNativeBalance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newNativeBalance),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.subId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.subId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubscriptionFundedWithNative {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubscriptionFundedWithNative> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &SubscriptionFundedWithNative,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SubscriptionOwnerTransferRequested(uint256,address,address)` and selector `0x21a4dad170a6bf476c31bbcf4a16628295b0e450672eec25d7c93308e05344a1`.
```solidity
event SubscriptionOwnerTransferRequested(uint256 indexed subId, address from, address to);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubscriptionOwnerTransferRequested {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubscriptionOwnerTransferRequested {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SubscriptionOwnerTransferRequested(uint256,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                33u8, 164u8, 218u8, 209u8, 112u8, 166u8, 191u8, 71u8, 108u8, 49u8, 187u8,
                207u8, 74u8, 22u8, 98u8, 130u8, 149u8, 176u8, 228u8, 80u8, 103u8, 46u8,
                236u8, 37u8, 215u8, 201u8, 51u8, 8u8, 224u8, 83u8, 68u8, 161u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    subId: topics.1,
                    from: data.0,
                    to: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.subId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.subId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData
        for SubscriptionOwnerTransferRequested {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubscriptionOwnerTransferRequested>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &SubscriptionOwnerTransferRequested,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SubscriptionOwnerTransferred(uint256,address,address)` and selector `0xd4114ab6e9af9f597c52041f32d62dc57c5c4e4c0d4427006069635e216c9386`.
```solidity
event SubscriptionOwnerTransferred(uint256 indexed subId, address from, address to);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubscriptionOwnerTransferred {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubscriptionOwnerTransferred {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SubscriptionOwnerTransferred(uint256,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                212u8, 17u8, 74u8, 182u8, 233u8, 175u8, 159u8, 89u8, 124u8, 82u8, 4u8,
                31u8, 50u8, 214u8, 45u8, 197u8, 124u8, 92u8, 78u8, 76u8, 13u8, 68u8,
                39u8, 0u8, 96u8, 105u8, 99u8, 94u8, 33u8, 108u8, 147u8, 134u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    subId: topics.1,
                    from: data.0,
                    to: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.subId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.subId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubscriptionOwnerTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubscriptionOwnerTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &SubscriptionOwnerTransferred,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ADMIN_ROLE()` and selector `0x75b238fc`.
```solidity
function ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ADMIN_ROLE()`](ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ADMIN_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ADMIN_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [117u8, 178u8, 56u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DST_H1_G1()` and selector `0x235296f7`.
```solidity
function DST_H1_G1() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DST_H1_G1Call;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DST_H1_G1()`](DST_H1_G1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DST_H1_G1Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DST_H1_G1Call> for UnderlyingRustTuple<'_> {
                fn from(value: DST_H1_G1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DST_H1_G1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DST_H1_G1Return> for UnderlyingRustTuple<'_> {
                fn from(value: DST_H1_G1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DST_H1_G1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DST_H1_G1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DST_H1_G1()";
            const SELECTOR: [u8; 4] = [35u8, 82u8, 150u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DST_H1_G1Return = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DST_H1_G1Return = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DST_H2()` and selector `0x38c27d12`.
```solidity
function DST_H2() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DST_H2Call;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DST_H2()`](DST_H2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DST_H2Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DST_H2Call> for UnderlyingRustTuple<'_> {
                fn from(value: DST_H2Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DST_H2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DST_H2Return> for UnderlyingRustTuple<'_> {
                fn from(value: DST_H2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DST_H2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DST_H2Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DST_H2()";
            const SELECTOR: [u8; 4] = [56u8, 194u8, 125u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DST_H2Return = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DST_H2Return = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DST_H3()` and selector `0x7350f456`.
```solidity
function DST_H3() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DST_H3Call;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DST_H3()`](DST_H3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DST_H3Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DST_H3Call> for UnderlyingRustTuple<'_> {
                fn from(value: DST_H3Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DST_H3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DST_H3Return> for UnderlyingRustTuple<'_> {
                fn from(value: DST_H3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DST_H3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DST_H3Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DST_H3()";
            const SELECTOR: [u8; 4] = [115u8, 80u8, 244u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DST_H3Return = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DST_H3Return = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DST_H4()` and selector `0x67b276af`.
```solidity
function DST_H4() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DST_H4Call;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DST_H4()`](DST_H4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DST_H4Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DST_H4Call> for UnderlyingRustTuple<'_> {
                fn from(value: DST_H4Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DST_H4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DST_H4Return> for UnderlyingRustTuple<'_> {
                fn from(value: DST_H4Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DST_H4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DST_H4Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DST_H4()";
            const SELECTOR: [u8; 4] = [103u8, 178u8, 118u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DST_H4Return = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DST_H4Return = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MAX_CONSUMERS()` and selector `0x64d51a2a`.
```solidity
function MAX_CONSUMERS() external view returns (uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_CONSUMERSCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MAX_CONSUMERS()`](MAX_CONSUMERSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_CONSUMERSReturn {
        #[allow(missing_docs)]
        pub _0: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_CONSUMERSCall> for UnderlyingRustTuple<'_> {
                fn from(value: MAX_CONSUMERSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAX_CONSUMERSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_CONSUMERSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MAX_CONSUMERSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAX_CONSUMERSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MAX_CONSUMERSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u16;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MAX_CONSUMERS()";
            const SELECTOR: [u8; 4] = [100u8, 213u8, 26u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MAX_CONSUMERSReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MAX_CONSUMERSReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `SCHEME_ID()` and selector `0x8a1f165a`.
```solidity
function SCHEME_ID() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SCHEME_IDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`SCHEME_ID()`](SCHEME_IDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SCHEME_IDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SCHEME_IDCall> for UnderlyingRustTuple<'_> {
                fn from(value: SCHEME_IDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SCHEME_IDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SCHEME_IDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SCHEME_IDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SCHEME_IDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SCHEME_IDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SCHEME_ID()";
            const SELECTOR: [u8; 4] = [138u8, 31u8, 22u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: SCHEME_IDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: SCHEME_IDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `acceptSubscriptionOwnerTransfer(uint256)` and selector `0xb2a7cac5`.
```solidity
function acceptSubscriptionOwnerTransfer(uint256 subId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptSubscriptionOwnerTransferCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`acceptSubscriptionOwnerTransfer(uint256)`](acceptSubscriptionOwnerTransferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptSubscriptionOwnerTransferReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptSubscriptionOwnerTransferCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptSubscriptionOwnerTransferCall) -> Self {
                    (value.subId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptSubscriptionOwnerTransferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { subId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptSubscriptionOwnerTransferReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptSubscriptionOwnerTransferReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptSubscriptionOwnerTransferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl acceptSubscriptionOwnerTransferReturn {
            fn _tokenize(
                &self,
            ) -> <acceptSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptSubscriptionOwnerTransferCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptSubscriptionOwnerTransferReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptSubscriptionOwnerTransfer(uint256)";
            const SELECTOR: [u8; 4] = [178u8, 167u8, 202u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                acceptSubscriptionOwnerTransferReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addConsumer(uint256,address)` and selector `0xbec4c08c`.
```solidity
function addConsumer(uint256 subId, address consumer) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addConsumerCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub consumer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`addConsumer(uint256,address)`](addConsumerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addConsumerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addConsumerCall> for UnderlyingRustTuple<'_> {
                fn from(value: addConsumerCall) -> Self {
                    (value.subId, value.consumer)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addConsumerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        subId: tuple.0,
                        consumer: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addConsumerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addConsumerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addConsumerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addConsumerReturn {
            fn _tokenize(
                &self,
            ) -> <addConsumerCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addConsumerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addConsumerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addConsumer(uint256,address)";
            const SELECTOR: [u8; 4] = [190u8, 196u8, 192u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.consumer,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addConsumerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `blocklockRequestsWithDecryptionKey(uint256)` and selector `0x5f7bda9f`.
```solidity
function blocklockRequestsWithDecryptionKey(uint256) external view returns (uint256 subId, uint256 directFundingFeePaid, uint32 callbackGasLimit, uint256 decryptionRequestId, bytes memory condition, TypesLib.Ciphertext memory ciphertext, bytes memory signature, bytes memory decryptionKey, address callback);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blocklockRequestsWithDecryptionKeyCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`blocklockRequestsWithDecryptionKey(uint256)`](blocklockRequestsWithDecryptionKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blocklockRequestsWithDecryptionKeyReturn {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub directFundingFeePaid: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub callbackGasLimit: u32,
        #[allow(missing_docs)]
        pub decryptionRequestId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub condition: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub decryptionKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub callback: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blocklockRequestsWithDecryptionKeyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: blocklockRequestsWithDecryptionKeyCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blocklockRequestsWithDecryptionKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                TypesLib::Ciphertext,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u32,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
                <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blocklockRequestsWithDecryptionKeyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: blocklockRequestsWithDecryptionKeyReturn) -> Self {
                    (
                        value.subId,
                        value.directFundingFeePaid,
                        value.callbackGasLimit,
                        value.decryptionRequestId,
                        value.condition,
                        value.ciphertext,
                        value.signature,
                        value.decryptionKey,
                        value.callback,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blocklockRequestsWithDecryptionKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        subId: tuple.0,
                        directFundingFeePaid: tuple.1,
                        callbackGasLimit: tuple.2,
                        decryptionRequestId: tuple.3,
                        condition: tuple.4,
                        ciphertext: tuple.5,
                        signature: tuple.6,
                        decryptionKey: tuple.7,
                        callback: tuple.8,
                    }
                }
            }
        }
        impl blocklockRequestsWithDecryptionKeyReturn {
            fn _tokenize(
                &self,
            ) -> <blocklockRequestsWithDecryptionKeyCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.directFundingFeePaid),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.callbackGasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.decryptionRequestId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.condition,
                    ),
                    <TypesLib::Ciphertext as alloy_sol_types::SolType>::tokenize(
                        &self.ciphertext,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionKey,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callback,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blocklockRequestsWithDecryptionKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = blocklockRequestsWithDecryptionKeyReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                TypesLib::Ciphertext,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blocklockRequestsWithDecryptionKey(uint256)";
            const SELECTOR: [u8; 4] = [95u8, 123u8, 218u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                blocklockRequestsWithDecryptionKeyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `calculateRequestPriceNative(uint32)` and selector `0x4b160935`.
```solidity
function calculateRequestPriceNative(uint32 _callbackGasLimit) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateRequestPriceNativeCall {
        #[allow(missing_docs)]
        pub _callbackGasLimit: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`calculateRequestPriceNative(uint32)`](calculateRequestPriceNativeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateRequestPriceNativeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateRequestPriceNativeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateRequestPriceNativeCall) -> Self {
                    (value._callbackGasLimit,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateRequestPriceNativeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _callbackGasLimit: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateRequestPriceNativeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateRequestPriceNativeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateRequestPriceNativeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateRequestPriceNativeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateRequestPriceNative(uint32)";
            const SELECTOR: [u8; 4] = [75u8, 22u8, 9u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._callbackGasLimit),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: calculateRequestPriceNativeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: calculateRequestPriceNativeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `cancelSubscription(uint256,address)` and selector `0x0ae09540`.
```solidity
function cancelSubscription(uint256 subId, address to) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cancelSubscriptionCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`cancelSubscription(uint256,address)`](cancelSubscriptionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cancelSubscriptionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cancelSubscriptionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: cancelSubscriptionCall) -> Self {
                    (value.subId, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for cancelSubscriptionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        subId: tuple.0,
                        to: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cancelSubscriptionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: cancelSubscriptionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for cancelSubscriptionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl cancelSubscriptionReturn {
            fn _tokenize(
                &self,
            ) -> <cancelSubscriptionCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for cancelSubscriptionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = cancelSubscriptionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "cancelSubscription(uint256,address)";
            const SELECTOR: [u8; 4] = [10u8, 224u8, 149u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                cancelSubscriptionReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `createSubscription()` and selector `0xa21a23e4`.
```solidity
function createSubscription() external returns (uint256 subId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSubscriptionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`createSubscription()`](createSubscriptionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSubscriptionReturn {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSubscriptionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createSubscriptionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSubscriptionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSubscriptionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createSubscriptionReturn) -> Self {
                    (value.subId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSubscriptionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { subId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createSubscriptionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createSubscription()";
            const SELECTOR: [u8; 4] = [162u8, 26u8, 35u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: createSubscriptionReturn = r.into();
                        r.subId
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: createSubscriptionReturn = r.into();
                        r.subId
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `decrypt(((uint256[2],uint256[2]),bytes,bytes),bytes)` and selector `0xc9bc18c4`.
```solidity
function decrypt(TypesLib.Ciphertext memory ciphertext, bytes memory decryptionKey) external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decryptCall {
        #[allow(missing_docs)]
        pub ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub decryptionKey: alloy::sol_types::private::Bytes,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`decrypt(((uint256[2],uint256[2]),bytes,bytes),bytes)`](decryptCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decryptReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                TypesLib::Ciphertext,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decryptCall> for UnderlyingRustTuple<'_> {
                fn from(value: decryptCall) -> Self {
                    (value.ciphertext, value.decryptionKey)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decryptCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ciphertext: tuple.0,
                        decryptionKey: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decryptReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decryptReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decryptReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decryptCall {
            type Parameters<'a> = (
                TypesLib::Ciphertext,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decrypt(((uint256[2],uint256[2]),bytes,bytes),bytes)";
            const SELECTOR: [u8; 4] = [201u8, 188u8, 24u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <TypesLib::Ciphertext as alloy_sol_types::SolType>::tokenize(
                        &self.ciphertext,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionKey,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: decryptReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: decryptReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `decryptionSender()` and selector `0x133c40c7`.
```solidity
function decryptionSender() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decryptionSenderCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`decryptionSender()`](decryptionSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decryptionSenderReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decryptionSenderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: decryptionSenderCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for decryptionSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decryptionSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: decryptionSenderReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for decryptionSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decryptionSenderCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decryptionSender()";
            const SELECTOR: [u8; 4] = [19u8, 60u8, 64u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: decryptionSenderReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: decryptionSenderReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `disable()` and selector `0x2f2770db`.
```solidity
function disable() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableCall;
    ///Container type for the return parameters of the [`disable()`](disableCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableCall> for UnderlyingRustTuple<'_> {
                fn from(value: disableCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for disableCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableReturn> for UnderlyingRustTuple<'_> {
                fn from(value: disableReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for disableReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl disableReturn {
            fn _tokenize(
                &self,
            ) -> <disableCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for disableCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = disableReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "disable()";
            const SELECTOR: [u8; 4] = [47u8, 39u8, 112u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                disableReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `enable()` and selector `0xa3907d71`.
```solidity
function enable() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableCall;
    ///Container type for the return parameters of the [`enable()`](enableCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableCall> for UnderlyingRustTuple<'_> {
                fn from(value: enableCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enableCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableReturn> for UnderlyingRustTuple<'_> {
                fn from(value: enableReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enableReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl enableReturn {
            fn _tokenize(
                &self,
            ) -> <enableCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enableCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = enableReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enable()";
            const SELECTOR: [u8; 4] = [163u8, 144u8, 125u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                enableReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `estimateRequestPriceNative(uint32,uint256)` and selector `0x3255c456`.
```solidity
function estimateRequestPriceNative(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct estimateRequestPriceNativeCall {
        #[allow(missing_docs)]
        pub _callbackGasLimit: u32,
        #[allow(missing_docs)]
        pub _requestGasPriceWei: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`estimateRequestPriceNative(uint32,uint256)`](estimateRequestPriceNativeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct estimateRequestPriceNativeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u32,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<estimateRequestPriceNativeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: estimateRequestPriceNativeCall) -> Self {
                    (value._callbackGasLimit, value._requestGasPriceWei)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for estimateRequestPriceNativeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _callbackGasLimit: tuple.0,
                        _requestGasPriceWei: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<estimateRequestPriceNativeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: estimateRequestPriceNativeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for estimateRequestPriceNativeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for estimateRequestPriceNativeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "estimateRequestPriceNative(uint32,uint256)";
            const SELECTOR: [u8; 4] = [50u8, 85u8, 196u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._callbackGasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._requestGasPriceWei),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: estimateRequestPriceNativeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: estimateRequestPriceNativeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fundSubscriptionWithNative(uint256)` and selector `0x95b55cfc`.
```solidity
function fundSubscriptionWithNative(uint256 subId) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fundSubscriptionWithNativeCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`fundSubscriptionWithNative(uint256)`](fundSubscriptionWithNativeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fundSubscriptionWithNativeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fundSubscriptionWithNativeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: fundSubscriptionWithNativeCall) -> Self {
                    (value.subId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fundSubscriptionWithNativeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { subId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fundSubscriptionWithNativeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: fundSubscriptionWithNativeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fundSubscriptionWithNativeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl fundSubscriptionWithNativeReturn {
            fn _tokenize(
                &self,
            ) -> <fundSubscriptionWithNativeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fundSubscriptionWithNativeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = fundSubscriptionWithNativeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fundSubscriptionWithNative(uint256)";
            const SELECTOR: [u8; 4] = [149u8, 181u8, 92u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                fundSubscriptionWithNativeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getActiveSubscriptionIds(uint256,uint256)` and selector `0xaefb212f`.
```solidity
function getActiveSubscriptionIds(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory ids);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveSubscriptionIdsCall {
        #[allow(missing_docs)]
        pub startIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getActiveSubscriptionIds(uint256,uint256)`](getActiveSubscriptionIdsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveSubscriptionIdsReturn {
        #[allow(missing_docs)]
        pub ids: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveSubscriptionIdsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveSubscriptionIdsCall) -> Self {
                    (value.startIndex, value.maxCount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveSubscriptionIdsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startIndex: tuple.0,
                        maxCount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveSubscriptionIdsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveSubscriptionIdsReturn) -> Self {
                    (value.ids,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveSubscriptionIdsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ids: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getActiveSubscriptionIdsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getActiveSubscriptionIds(uint256,uint256)";
            const SELECTOR: [u8; 4] = [174u8, 251u8, 33u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxCount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getActiveSubscriptionIdsReturn = r.into();
                        r.ids
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getActiveSubscriptionIdsReturn = r.into();
                        r.ids
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getChainId()` and selector `0x3408e470`.
```solidity
function getChainId() external view returns (uint256 chainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getChainIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getChainId()`](getChainIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getChainIdReturn {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getChainIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getChainIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getChainIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getChainIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getChainIdReturn) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getChainIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getChainIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getChainId()";
            const SELECTOR: [u8; 4] = [52u8, 8u8, 228u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getChainIdReturn = r.into();
                        r.chainId
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getChainIdReturn = r.into();
                        r.chainId
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getConfig()` and selector `0xc3f909d4`.
```solidity
function getConfig() external view returns (uint32 maxGasLimit, uint32 gasAfterPaymentCalculation, uint32 fulfillmentFlatFeeNativePPM, uint32 weiPerUnitGas, uint32 blsPairingCheckOverhead, uint8 nativePremiumPercentage, uint32 gasForCallExactCheck);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getConfigCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getConfig()`](getConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getConfigReturn {
        #[allow(missing_docs)]
        pub maxGasLimit: u32,
        #[allow(missing_docs)]
        pub gasAfterPaymentCalculation: u32,
        #[allow(missing_docs)]
        pub fulfillmentFlatFeeNativePPM: u32,
        #[allow(missing_docs)]
        pub weiPerUnitGas: u32,
        #[allow(missing_docs)]
        pub blsPairingCheckOverhead: u32,
        #[allow(missing_docs)]
        pub nativePremiumPercentage: u8,
        #[allow(missing_docs)]
        pub gasForCallExactCheck: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: getConfigCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32, u32, u32, u32, u32, u8, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getConfigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getConfigReturn) -> Self {
                    (
                        value.maxGasLimit,
                        value.gasAfterPaymentCalculation,
                        value.fulfillmentFlatFeeNativePPM,
                        value.weiPerUnitGas,
                        value.blsPairingCheckOverhead,
                        value.nativePremiumPercentage,
                        value.gasForCallExactCheck,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        maxGasLimit: tuple.0,
                        gasAfterPaymentCalculation: tuple.1,
                        fulfillmentFlatFeeNativePPM: tuple.2,
                        weiPerUnitGas: tuple.3,
                        blsPairingCheckOverhead: tuple.4,
                        nativePremiumPercentage: tuple.5,
                        gasForCallExactCheck: tuple.6,
                    }
                }
            }
        }
        impl getConfigReturn {
            fn _tokenize(
                &self,
            ) -> <getConfigCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxGasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.gasAfterPaymentCalculation,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.fulfillmentFlatFeeNativePPM,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.weiPerUnitGas),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.blsPairingCheckOverhead,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.nativePremiumPercentage,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasForCallExactCheck),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getConfigCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getConfigReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getConfig()";
            const SELECTOR: [u8; 4] = [195u8, 249u8, 9u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getConfigReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRequest(uint256)` and selector `0xc58343ef`.
```solidity
function getRequest(uint256 requestId) external view returns (TypesLib.BlocklockRequest memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRequestCall {
        #[allow(missing_docs)]
        pub requestId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    ///Container type for the return parameters of the [`getRequest(uint256)`](getRequestCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRequestReturn {
        #[allow(missing_docs)]
        pub _0: <TypesLib::BlocklockRequest as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRequestCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRequestCall) -> Self {
                    (value.requestId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRequestCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { requestId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (TypesLib::BlocklockRequest,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <TypesLib::BlocklockRequest as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRequestReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRequestReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRequestReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRequestCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <TypesLib::BlocklockRequest as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (TypesLib::BlocklockRequest,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRequest(uint256)";
            const SELECTOR: [u8; 4] = [197u8, 131u8, 67u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <TypesLib::BlocklockRequest as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRequestReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRequestReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMember(bytes32,uint256)` and selector `0x9010d07c`.
```solidity
function getRoleMember(bytes32 role, uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMember(bytes32,uint256)`](getRoleMemberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCall) -> Self {
                    (value.role, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMember(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [144u8, 16u8, 208u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMemberCount(bytes32)` and selector `0xca15c873`.
```solidity
function getRoleMemberCount(bytes32 role) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMemberCount(bytes32)`](getRoleMemberCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMemberCount(bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 21u8, 200u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMembers(bytes32)` and selector `0xa3246ad3`.
```solidity
function getRoleMembers(bytes32 role) external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMembersCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMembers(bytes32)`](getRoleMembersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMembersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMembersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMembersCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMembersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMembersReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMembersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMembersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMembersCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMembers(bytes32)";
            const SELECTOR: [u8; 4] = [163u8, 36u8, 106u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMembersReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMembersReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSubscription(uint256)` and selector `0xdc311dd3`.
```solidity
function getSubscription(uint256 subId) external view returns (uint96 nativeBalance, uint64 reqCount, address subOwner, address[] memory consumers);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSubscriptionCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSubscription(uint256)`](getSubscriptionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSubscriptionReturn {
        #[allow(missing_docs)]
        pub nativeBalance: alloy::sol_types::private::primitives::aliases::U96,
        #[allow(missing_docs)]
        pub reqCount: u64,
        #[allow(missing_docs)]
        pub subOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub consumers: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSubscriptionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getSubscriptionCall) -> Self {
                    (value.subId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getSubscriptionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { subId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<96>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U96,
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSubscriptionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSubscriptionReturn) -> Self {
                    (
                        value.nativeBalance,
                        value.reqCount,
                        value.subOwner,
                        value.consumers,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSubscriptionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        nativeBalance: tuple.0,
                        reqCount: tuple.1,
                        subOwner: tuple.2,
                        consumers: tuple.3,
                    }
                }
            }
        }
        impl getSubscriptionReturn {
            fn _tokenize(
                &self,
            ) -> <getSubscriptionCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        96,
                    > as alloy_sol_types::SolType>::tokenize(&self.nativeBalance),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.reqCount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.subOwner,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.consumers),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSubscriptionCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getSubscriptionReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<96>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSubscription(uint256)";
            const SELECTOR: [u8; 4] = [220u8, 49u8, 29u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getSubscriptionReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initialize(address,address)` and selector `0x485cc955`.
```solidity
function initialize(address owner, address _decryptionSender) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _decryptionSender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`initialize(address,address)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value.owner, value._decryptionSender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        _decryptionSender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeReturn {
            fn _tokenize(
                &self,
            ) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,address)";
            const SELECTOR: [u8; 4] = [72u8, 92u8, 201u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._decryptionSender,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isInFlight(uint256)` and selector `0xcd802c91`.
```solidity
function isInFlight(uint256 requestId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isInFlightCall {
        #[allow(missing_docs)]
        pub requestId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isInFlight(uint256)`](isInFlightCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isInFlightReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isInFlightCall> for UnderlyingRustTuple<'_> {
                fn from(value: isInFlightCall) -> Self {
                    (value.requestId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isInFlightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { requestId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isInFlightReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isInFlightReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isInFlightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isInFlightCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isInFlight(uint256)";
            const SELECTOR: [u8; 4] = [205u8, 128u8, 44u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isInFlightReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isInFlightReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ownerCancelSubscription(uint256)` and selector `0xaa433aff`.
```solidity
function ownerCancelSubscription(uint256 subId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCancelSubscriptionCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`ownerCancelSubscription(uint256)`](ownerCancelSubscriptionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCancelSubscriptionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCancelSubscriptionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ownerCancelSubscriptionCall) -> Self {
                    (value.subId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ownerCancelSubscriptionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { subId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCancelSubscriptionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ownerCancelSubscriptionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ownerCancelSubscriptionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl ownerCancelSubscriptionReturn {
            fn _tokenize(
                &self,
            ) -> <ownerCancelSubscriptionCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCancelSubscriptionCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerCancelSubscriptionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ownerCancelSubscription(uint256)";
            const SELECTOR: [u8; 4] = [170u8, 67u8, 58u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                ownerCancelSubscriptionReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pendingRequestExists(uint256)` and selector `0x41af6c87`.
```solidity
function pendingRequestExists(uint256 subId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingRequestExistsCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`pendingRequestExists(uint256)`](pendingRequestExistsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingRequestExistsReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingRequestExistsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingRequestExistsCall) -> Self {
                    (value.subId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingRequestExistsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { subId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingRequestExistsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingRequestExistsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingRequestExistsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingRequestExistsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingRequestExists(uint256)";
            const SELECTOR: [u8; 4] = [65u8, 175u8, 108u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pendingRequestExistsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pendingRequestExistsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `receiveDecryptionData(uint256,bytes,bytes)` and selector `0x5d3be001`.
```solidity
function receiveDecryptionData(uint256 requestId, bytes memory decryptionKey, bytes memory signature) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct receiveDecryptionDataCall {
        #[allow(missing_docs)]
        pub requestId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub decryptionKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`receiveDecryptionData(uint256,bytes,bytes)`](receiveDecryptionDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct receiveDecryptionDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<receiveDecryptionDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: receiveDecryptionDataCall) -> Self {
                    (value.requestId, value.decryptionKey, value.signature)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for receiveDecryptionDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        requestId: tuple.0,
                        decryptionKey: tuple.1,
                        signature: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<receiveDecryptionDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: receiveDecryptionDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for receiveDecryptionDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl receiveDecryptionDataReturn {
            fn _tokenize(
                &self,
            ) -> <receiveDecryptionDataCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for receiveDecryptionDataCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = receiveDecryptionDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "receiveDecryptionData(uint256,bytes,bytes)";
            const SELECTOR: [u8; 4] = [93u8, 59u8, 224u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionKey,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                receiveDecryptionDataReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeConsumer(uint256,address)` and selector `0xcb631797`.
```solidity
function removeConsumer(uint256 subId, address consumer) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeConsumerCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub consumer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeConsumer(uint256,address)`](removeConsumerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeConsumerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeConsumerCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeConsumerCall) -> Self {
                    (value.subId, value.consumer)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeConsumerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        subId: tuple.0,
                        consumer: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeConsumerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeConsumerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeConsumerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeConsumerReturn {
            fn _tokenize(
                &self,
            ) -> <removeConsumerCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeConsumerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeConsumerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeConsumer(uint256,address)";
            const SELECTOR: [u8; 4] = [203u8, 99u8, 23u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.consumer,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeConsumerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `requestBlocklock(uint32,bytes,((uint256[2],uint256[2]),bytes,bytes))` and selector `0x7909dc7b`.
```solidity
function requestBlocklock(uint32 callbackGasLimit, bytes memory condition, TypesLib.Ciphertext memory ciphertext) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestBlocklockCall {
        #[allow(missing_docs)]
        pub callbackGasLimit: u32,
        #[allow(missing_docs)]
        pub condition: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`requestBlocklock(uint32,bytes,((uint256[2],uint256[2]),bytes,bytes))`](requestBlocklockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestBlocklockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
                TypesLib::Ciphertext,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u32,
                alloy::sol_types::private::Bytes,
                <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestBlocklockCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestBlocklockCall) -> Self {
                    (value.callbackGasLimit, value.condition, value.ciphertext)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestBlocklockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        callbackGasLimit: tuple.0,
                        condition: tuple.1,
                        ciphertext: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestBlocklockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestBlocklockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestBlocklockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requestBlocklockCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
                TypesLib::Ciphertext,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requestBlocklock(uint32,bytes,((uint256[2],uint256[2]),bytes,bytes))";
            const SELECTOR: [u8; 4] = [121u8, 9u8, 220u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.callbackGasLimit),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.condition,
                    ),
                    <TypesLib::Ciphertext as alloy_sol_types::SolType>::tokenize(
                        &self.ciphertext,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: requestBlocklockReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: requestBlocklockReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `requestBlocklockWithSubscription(uint32,uint256,bytes,((uint256[2],uint256[2]),bytes,bytes))` and selector `0x062b1d90`.
```solidity
function requestBlocklockWithSubscription(uint32 callbackGasLimit, uint256 subId, bytes memory condition, TypesLib.Ciphertext memory ciphertext) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestBlocklockWithSubscriptionCall {
        #[allow(missing_docs)]
        pub callbackGasLimit: u32,
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub condition: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`requestBlocklockWithSubscription(uint32,uint256,bytes,((uint256[2],uint256[2]),bytes,bytes))`](requestBlocklockWithSubscriptionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestBlocklockWithSubscriptionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                TypesLib::Ciphertext,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u32,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
                <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestBlocklockWithSubscriptionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestBlocklockWithSubscriptionCall) -> Self {
                    (
                        value.callbackGasLimit,
                        value.subId,
                        value.condition,
                        value.ciphertext,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestBlocklockWithSubscriptionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        callbackGasLimit: tuple.0,
                        subId: tuple.1,
                        condition: tuple.2,
                        ciphertext: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestBlocklockWithSubscriptionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestBlocklockWithSubscriptionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestBlocklockWithSubscriptionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requestBlocklockWithSubscriptionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                TypesLib::Ciphertext,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requestBlocklockWithSubscription(uint32,uint256,bytes,((uint256[2],uint256[2]),bytes,bytes))";
            const SELECTOR: [u8; 4] = [6u8, 43u8, 29u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.callbackGasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.condition,
                    ),
                    <TypesLib::Ciphertext as alloy_sol_types::SolType>::tokenize(
                        &self.ciphertext,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: requestBlocklockWithSubscriptionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: requestBlocklockWithSubscriptionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `requestSubscriptionOwnerTransfer(uint256,address)` and selector `0xdac83d29`.
```solidity
function requestSubscriptionOwnerTransfer(uint256 subId, address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestSubscriptionOwnerTransferCall {
        #[allow(missing_docs)]
        pub subId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`requestSubscriptionOwnerTransfer(uint256,address)`](requestSubscriptionOwnerTransferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestSubscriptionOwnerTransferReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestSubscriptionOwnerTransferCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestSubscriptionOwnerTransferCall) -> Self {
                    (value.subId, value.newOwner)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestSubscriptionOwnerTransferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        subId: tuple.0,
                        newOwner: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestSubscriptionOwnerTransferReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestSubscriptionOwnerTransferReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestSubscriptionOwnerTransferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl requestSubscriptionOwnerTransferReturn {
            fn _tokenize(
                &self,
            ) -> <requestSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requestSubscriptionOwnerTransferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = requestSubscriptionOwnerTransferReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requestSubscriptionOwnerTransfer(uint256,address)";
            const SELECTOR: [u8; 4] = [218u8, 200u8, 61u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                requestSubscriptionOwnerTransferReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `s_config()` and selector `0x088070f5`.
```solidity
function s_config() external view returns (uint32 maxGasLimit, uint32 gasAfterPaymentCalculation, uint32 fulfillmentFlatFeeNativePPM, uint32 weiPerUnitGas, uint32 blsPairingCheckOverhead, uint8 nativePremiumPercentage, uint32 gasForCallExactCheck);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_configCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`s_config()`](s_configCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_configReturn {
        #[allow(missing_docs)]
        pub maxGasLimit: u32,
        #[allow(missing_docs)]
        pub gasAfterPaymentCalculation: u32,
        #[allow(missing_docs)]
        pub fulfillmentFlatFeeNativePPM: u32,
        #[allow(missing_docs)]
        pub weiPerUnitGas: u32,
        #[allow(missing_docs)]
        pub blsPairingCheckOverhead: u32,
        #[allow(missing_docs)]
        pub nativePremiumPercentage: u8,
        #[allow(missing_docs)]
        pub gasForCallExactCheck: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_configCall> for UnderlyingRustTuple<'_> {
                fn from(value: s_configCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for s_configCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32, u32, u32, u32, u32, u8, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_configReturn> for UnderlyingRustTuple<'_> {
                fn from(value: s_configReturn) -> Self {
                    (
                        value.maxGasLimit,
                        value.gasAfterPaymentCalculation,
                        value.fulfillmentFlatFeeNativePPM,
                        value.weiPerUnitGas,
                        value.blsPairingCheckOverhead,
                        value.nativePremiumPercentage,
                        value.gasForCallExactCheck,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for s_configReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        maxGasLimit: tuple.0,
                        gasAfterPaymentCalculation: tuple.1,
                        fulfillmentFlatFeeNativePPM: tuple.2,
                        weiPerUnitGas: tuple.3,
                        blsPairingCheckOverhead: tuple.4,
                        nativePremiumPercentage: tuple.5,
                        gasForCallExactCheck: tuple.6,
                    }
                }
            }
        }
        impl s_configReturn {
            fn _tokenize(
                &self,
            ) -> <s_configCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxGasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.gasAfterPaymentCalculation,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.fulfillmentFlatFeeNativePPM,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.weiPerUnitGas),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.blsPairingCheckOverhead,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.nativePremiumPercentage,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasForCallExactCheck),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for s_configCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = s_configReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "s_config()";
            const SELECTOR: [u8; 4] = [8u8, 128u8, 112u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                s_configReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `s_configured()` and selector `0x57a8070a`.
```solidity
function s_configured() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_configuredCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`s_configured()`](s_configuredCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_configuredReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_configuredCall> for UnderlyingRustTuple<'_> {
                fn from(value: s_configuredCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for s_configuredCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_configuredReturn> for UnderlyingRustTuple<'_> {
                fn from(value: s_configuredReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for s_configuredReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for s_configuredCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "s_configured()";
            const SELECTOR: [u8; 4] = [87u8, 168u8, 7u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: s_configuredReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: s_configuredReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `s_currentSubNonce()` and selector `0x9d40a6fd`.
```solidity
function s_currentSubNonce() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_currentSubNonceCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`s_currentSubNonce()`](s_currentSubNonceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_currentSubNonceReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_currentSubNonceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: s_currentSubNonceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for s_currentSubNonceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_currentSubNonceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: s_currentSubNonceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for s_currentSubNonceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for s_currentSubNonceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "s_currentSubNonce()";
            const SELECTOR: [u8; 4] = [157u8, 64u8, 166u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: s_currentSubNonceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: s_currentSubNonceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `s_disabled()` and selector `0xa608a1e1`.
```solidity
function s_disabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_disabledCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`s_disabled()`](s_disabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_disabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_disabledCall> for UnderlyingRustTuple<'_> {
                fn from(value: s_disabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for s_disabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_disabledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: s_disabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for s_disabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for s_disabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "s_disabled()";
            const SELECTOR: [u8; 4] = [166u8, 8u8, 161u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: s_disabledReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: s_disabledReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `s_totalNativeBalance()` and selector `0x18e3dd27`.
```solidity
function s_totalNativeBalance() external view returns (uint96);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_totalNativeBalanceCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`s_totalNativeBalance()`](s_totalNativeBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_totalNativeBalanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U96,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_totalNativeBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: s_totalNativeBalanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for s_totalNativeBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U96,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_totalNativeBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: s_totalNativeBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for s_totalNativeBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for s_totalNativeBalanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U96;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "s_totalNativeBalance()";
            const SELECTOR: [u8; 4] = [24u8, 227u8, 221u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        96,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: s_totalNativeBalanceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: s_totalNativeBalanceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `s_withdrawableDirectFundingFeeNative()` and selector `0x3bc32c75`.
```solidity
function s_withdrawableDirectFundingFeeNative() external view returns (uint96);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_withdrawableDirectFundingFeeNativeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`s_withdrawableDirectFundingFeeNative()`](s_withdrawableDirectFundingFeeNativeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_withdrawableDirectFundingFeeNativeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U96,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_withdrawableDirectFundingFeeNativeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: s_withdrawableDirectFundingFeeNativeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for s_withdrawableDirectFundingFeeNativeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U96,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_withdrawableDirectFundingFeeNativeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: s_withdrawableDirectFundingFeeNativeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for s_withdrawableDirectFundingFeeNativeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for s_withdrawableDirectFundingFeeNativeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U96;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "s_withdrawableDirectFundingFeeNative()";
            const SELECTOR: [u8; 4] = [59u8, 195u8, 44u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        96,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: s_withdrawableDirectFundingFeeNativeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: s_withdrawableDirectFundingFeeNativeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `s_withdrawableSubscriptionFeeNative()` and selector `0x995cb36e`.
```solidity
function s_withdrawableSubscriptionFeeNative() external view returns (uint96);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_withdrawableSubscriptionFeeNativeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`s_withdrawableSubscriptionFeeNative()`](s_withdrawableSubscriptionFeeNativeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct s_withdrawableSubscriptionFeeNativeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U96,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_withdrawableSubscriptionFeeNativeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: s_withdrawableSubscriptionFeeNativeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for s_withdrawableSubscriptionFeeNativeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U96,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<s_withdrawableSubscriptionFeeNativeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: s_withdrawableSubscriptionFeeNativeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for s_withdrawableSubscriptionFeeNativeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for s_withdrawableSubscriptionFeeNativeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U96;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "s_withdrawableSubscriptionFeeNative()";
            const SELECTOR: [u8; 4] = [153u8, 92u8, 179u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        96,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: s_withdrawableSubscriptionFeeNativeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: s_withdrawableSubscriptionFeeNativeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setConfig(uint32,uint32,uint32,uint32,uint32,uint8,uint32)` and selector `0x45fa4354`.
```solidity
function setConfig(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation, uint32 fulfillmentFlatFeeNativePPM, uint32 weiPerUnitGas, uint32 blsPairingCheckOverhead, uint8 nativePremiumPercentage, uint32 gasForCallExactCheck) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfigCall {
        #[allow(missing_docs)]
        pub maxGasLimit: u32,
        #[allow(missing_docs)]
        pub gasAfterPaymentCalculation: u32,
        #[allow(missing_docs)]
        pub fulfillmentFlatFeeNativePPM: u32,
        #[allow(missing_docs)]
        pub weiPerUnitGas: u32,
        #[allow(missing_docs)]
        pub blsPairingCheckOverhead: u32,
        #[allow(missing_docs)]
        pub nativePremiumPercentage: u8,
        #[allow(missing_docs)]
        pub gasForCallExactCheck: u32,
    }
    ///Container type for the return parameters of the [`setConfig(uint32,uint32,uint32,uint32,uint32,uint8,uint32)`](setConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32, u32, u32, u32, u32, u8, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: setConfigCall) -> Self {
                    (
                        value.maxGasLimit,
                        value.gasAfterPaymentCalculation,
                        value.fulfillmentFlatFeeNativePPM,
                        value.weiPerUnitGas,
                        value.blsPairingCheckOverhead,
                        value.nativePremiumPercentage,
                        value.gasForCallExactCheck,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        maxGasLimit: tuple.0,
                        gasAfterPaymentCalculation: tuple.1,
                        fulfillmentFlatFeeNativePPM: tuple.2,
                        weiPerUnitGas: tuple.3,
                        blsPairingCheckOverhead: tuple.4,
                        nativePremiumPercentage: tuple.5,
                        gasForCallExactCheck: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setConfigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setConfigReturn {
            fn _tokenize(
                &self,
            ) -> <setConfigCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setConfigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setConfigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setConfig(uint32,uint32,uint32,uint32,uint32,uint8,uint32)";
            const SELECTOR: [u8; 4] = [69u8, 250u8, 67u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxGasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.gasAfterPaymentCalculation,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.fulfillmentFlatFeeNativePPM,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.weiPerUnitGas),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.blsPairingCheckOverhead,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.nativePremiumPercentage,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasForCallExactCheck),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setConfigReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setDecryptionSender(address)` and selector `0x1e6ba15b`.
```solidity
function setDecryptionSender(address newDecryptionSender) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDecryptionSenderCall {
        #[allow(missing_docs)]
        pub newDecryptionSender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setDecryptionSender(address)`](setDecryptionSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDecryptionSenderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDecryptionSenderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDecryptionSenderCall) -> Self {
                    (value.newDecryptionSender,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDecryptionSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newDecryptionSender: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDecryptionSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDecryptionSenderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDecryptionSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setDecryptionSenderReturn {
            fn _tokenize(
                &self,
            ) -> <setDecryptionSenderCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDecryptionSenderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDecryptionSenderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDecryptionSender(address)";
            const SELECTOR: [u8; 4] = [30u8, 107u8, 161u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newDecryptionSender,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setDecryptionSenderReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `version()` and selector `0x54fd4d50`.
```solidity
function version() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct versionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`version()`](versionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct versionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<versionCall> for UnderlyingRustTuple<'_> {
                fn from(value: versionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for versionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<versionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: versionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for versionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for versionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "version()";
            const SELECTOR: [u8; 4] = [84u8, 253u8, 77u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: versionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: versionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawDirectFundingFeesNative(address)` and selector `0x54236fb3`.
```solidity
function withdrawDirectFundingFeesNative(address recipient) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawDirectFundingFeesNativeCall {
        #[allow(missing_docs)]
        pub recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`withdrawDirectFundingFeesNative(address)`](withdrawDirectFundingFeesNativeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawDirectFundingFeesNativeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawDirectFundingFeesNativeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawDirectFundingFeesNativeCall) -> Self {
                    (value.recipient,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawDirectFundingFeesNativeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { recipient: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawDirectFundingFeesNativeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawDirectFundingFeesNativeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawDirectFundingFeesNativeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawDirectFundingFeesNativeReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawDirectFundingFeesNativeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawDirectFundingFeesNativeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawDirectFundingFeesNativeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawDirectFundingFeesNative(address)";
            const SELECTOR: [u8; 4] = [84u8, 35u8, 111u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawDirectFundingFeesNativeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawSubscriptionFeesNative(address)` and selector `0xbd18636b`.
```solidity
function withdrawSubscriptionFeesNative(address recipient) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawSubscriptionFeesNativeCall {
        #[allow(missing_docs)]
        pub recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`withdrawSubscriptionFeesNative(address)`](withdrawSubscriptionFeesNativeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawSubscriptionFeesNativeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawSubscriptionFeesNativeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawSubscriptionFeesNativeCall) -> Self {
                    (value.recipient,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawSubscriptionFeesNativeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { recipient: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawSubscriptionFeesNativeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawSubscriptionFeesNativeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawSubscriptionFeesNativeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawSubscriptionFeesNativeReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawSubscriptionFeesNativeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawSubscriptionFeesNativeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawSubscriptionFeesNativeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawSubscriptionFeesNative(address)";
            const SELECTOR: [u8; 4] = [189u8, 24u8, 99u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawSubscriptionFeesNativeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`BlocklockSender`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum BlocklockSenderCalls {
        #[allow(missing_docs)]
        ADMIN_ROLE(ADMIN_ROLECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DST_H1_G1(DST_H1_G1Call),
        #[allow(missing_docs)]
        DST_H2(DST_H2Call),
        #[allow(missing_docs)]
        DST_H3(DST_H3Call),
        #[allow(missing_docs)]
        DST_H4(DST_H4Call),
        #[allow(missing_docs)]
        MAX_CONSUMERS(MAX_CONSUMERSCall),
        #[allow(missing_docs)]
        SCHEME_ID(SCHEME_IDCall),
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        acceptSubscriptionOwnerTransfer(acceptSubscriptionOwnerTransferCall),
        #[allow(missing_docs)]
        addConsumer(addConsumerCall),
        #[allow(missing_docs)]
        blocklockRequestsWithDecryptionKey(blocklockRequestsWithDecryptionKeyCall),
        #[allow(missing_docs)]
        calculateRequestPriceNative(calculateRequestPriceNativeCall),
        #[allow(missing_docs)]
        cancelSubscription(cancelSubscriptionCall),
        #[allow(missing_docs)]
        createSubscription(createSubscriptionCall),
        #[allow(missing_docs)]
        decrypt(decryptCall),
        #[allow(missing_docs)]
        decryptionSender(decryptionSenderCall),
        #[allow(missing_docs)]
        disable(disableCall),
        #[allow(missing_docs)]
        enable(enableCall),
        #[allow(missing_docs)]
        estimateRequestPriceNative(estimateRequestPriceNativeCall),
        #[allow(missing_docs)]
        fundSubscriptionWithNative(fundSubscriptionWithNativeCall),
        #[allow(missing_docs)]
        getActiveSubscriptionIds(getActiveSubscriptionIdsCall),
        #[allow(missing_docs)]
        getChainId(getChainIdCall),
        #[allow(missing_docs)]
        getConfig(getConfigCall),
        #[allow(missing_docs)]
        getRequest(getRequestCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getRoleMember(getRoleMemberCall),
        #[allow(missing_docs)]
        getRoleMemberCount(getRoleMemberCountCall),
        #[allow(missing_docs)]
        getRoleMembers(getRoleMembersCall),
        #[allow(missing_docs)]
        getSubscription(getSubscriptionCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        isInFlight(isInFlightCall),
        #[allow(missing_docs)]
        ownerCancelSubscription(ownerCancelSubscriptionCall),
        #[allow(missing_docs)]
        pendingRequestExists(pendingRequestExistsCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        receiveDecryptionData(receiveDecryptionDataCall),
        #[allow(missing_docs)]
        removeConsumer(removeConsumerCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        requestBlocklock(requestBlocklockCall),
        #[allow(missing_docs)]
        requestBlocklockWithSubscription(requestBlocklockWithSubscriptionCall),
        #[allow(missing_docs)]
        requestSubscriptionOwnerTransfer(requestSubscriptionOwnerTransferCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        s_config(s_configCall),
        #[allow(missing_docs)]
        s_configured(s_configuredCall),
        #[allow(missing_docs)]
        s_currentSubNonce(s_currentSubNonceCall),
        #[allow(missing_docs)]
        s_disabled(s_disabledCall),
        #[allow(missing_docs)]
        s_totalNativeBalance(s_totalNativeBalanceCall),
        #[allow(missing_docs)]
        s_withdrawableDirectFundingFeeNative(s_withdrawableDirectFundingFeeNativeCall),
        #[allow(missing_docs)]
        s_withdrawableSubscriptionFeeNative(s_withdrawableSubscriptionFeeNativeCall),
        #[allow(missing_docs)]
        setConfig(setConfigCall),
        #[allow(missing_docs)]
        setDecryptionSender(setDecryptionSenderCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
        #[allow(missing_docs)]
        version(versionCall),
        #[allow(missing_docs)]
        withdrawDirectFundingFeesNative(withdrawDirectFundingFeesNativeCall),
        #[allow(missing_docs)]
        withdrawSubscriptionFeesNative(withdrawSubscriptionFeesNativeCall),
    }
    #[automatically_derived]
    impl BlocklockSenderCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 43u8, 29u8, 144u8],
            [8u8, 128u8, 112u8, 245u8],
            [10u8, 224u8, 149u8, 64u8],
            [19u8, 60u8, 64u8, 199u8],
            [24u8, 227u8, 221u8, 39u8],
            [30u8, 107u8, 161u8, 91u8],
            [35u8, 82u8, 150u8, 247u8],
            [36u8, 138u8, 156u8, 163u8],
            [47u8, 39u8, 112u8, 219u8],
            [47u8, 47u8, 241u8, 93u8],
            [50u8, 85u8, 196u8, 86u8],
            [52u8, 8u8, 228u8, 112u8],
            [54u8, 86u8, 138u8, 190u8],
            [56u8, 194u8, 125u8, 18u8],
            [59u8, 195u8, 44u8, 117u8],
            [65u8, 175u8, 108u8, 135u8],
            [69u8, 250u8, 67u8, 84u8],
            [72u8, 92u8, 201u8, 85u8],
            [75u8, 22u8, 9u8, 53u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [84u8, 35u8, 111u8, 179u8],
            [84u8, 253u8, 77u8, 80u8],
            [87u8, 168u8, 7u8, 10u8],
            [93u8, 59u8, 224u8, 1u8],
            [95u8, 123u8, 218u8, 159u8],
            [100u8, 213u8, 26u8, 42u8],
            [103u8, 178u8, 118u8, 175u8],
            [115u8, 80u8, 244u8, 86u8],
            [117u8, 178u8, 56u8, 252u8],
            [121u8, 9u8, 220u8, 123u8],
            [138u8, 31u8, 22u8, 90u8],
            [144u8, 16u8, 208u8, 124u8],
            [145u8, 209u8, 72u8, 84u8],
            [149u8, 181u8, 92u8, 252u8],
            [153u8, 92u8, 179u8, 110u8],
            [157u8, 64u8, 166u8, 253u8],
            [162u8, 23u8, 253u8, 223u8],
            [162u8, 26u8, 35u8, 228u8],
            [163u8, 36u8, 106u8, 211u8],
            [163u8, 144u8, 125u8, 113u8],
            [166u8, 8u8, 161u8, 225u8],
            [170u8, 67u8, 58u8, 255u8],
            [173u8, 60u8, 177u8, 204u8],
            [174u8, 251u8, 33u8, 47u8],
            [178u8, 167u8, 202u8, 197u8],
            [189u8, 24u8, 99u8, 107u8],
            [190u8, 196u8, 192u8, 140u8],
            [195u8, 249u8, 9u8, 212u8],
            [197u8, 131u8, 67u8, 239u8],
            [201u8, 188u8, 24u8, 196u8],
            [202u8, 21u8, 200u8, 115u8],
            [203u8, 99u8, 23u8, 151u8],
            [205u8, 128u8, 44u8, 145u8],
            [213u8, 71u8, 116u8, 31u8],
            [218u8, 200u8, 61u8, 41u8],
            [220u8, 49u8, 29u8, 211u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for BlocklockSenderCalls {
        const NAME: &'static str = "BlocklockSenderCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 58usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ADMIN_ROLE(_) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DST_H1_G1(_) => {
                    <DST_H1_G1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DST_H2(_) => <DST_H2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::DST_H3(_) => <DST_H3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::DST_H4(_) => <DST_H4Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::MAX_CONSUMERS(_) => {
                    <MAX_CONSUMERSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SCHEME_ID(_) => {
                    <SCHEME_IDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::acceptSubscriptionOwnerTransfer(_) => {
                    <acceptSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addConsumer(_) => {
                    <addConsumerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::blocklockRequestsWithDecryptionKey(_) => {
                    <blocklockRequestsWithDecryptionKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calculateRequestPriceNative(_) => {
                    <calculateRequestPriceNativeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::cancelSubscription(_) => {
                    <cancelSubscriptionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createSubscription(_) => {
                    <createSubscriptionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decrypt(_) => <decryptCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::decryptionSender(_) => {
                    <decryptionSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::disable(_) => <disableCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::enable(_) => <enableCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::estimateRequestPriceNative(_) => {
                    <estimateRequestPriceNativeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fundSubscriptionWithNative(_) => {
                    <fundSubscriptionWithNativeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getActiveSubscriptionIds(_) => {
                    <getActiveSubscriptionIdsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getChainId(_) => {
                    <getChainIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getConfig(_) => {
                    <getConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRequest(_) => {
                    <getRequestCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMember(_) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMemberCount(_) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMembers(_) => {
                    <getRoleMembersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSubscription(_) => {
                    <getSubscriptionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isInFlight(_) => {
                    <isInFlightCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ownerCancelSubscription(_) => {
                    <ownerCancelSubscriptionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pendingRequestExists(_) => {
                    <pendingRequestExistsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::receiveDecryptionData(_) => {
                    <receiveDecryptionDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeConsumer(_) => {
                    <removeConsumerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requestBlocklock(_) => {
                    <requestBlocklockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requestBlocklockWithSubscription(_) => {
                    <requestBlocklockWithSubscriptionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requestSubscriptionOwnerTransfer(_) => {
                    <requestSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::s_config(_) => <s_configCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::s_configured(_) => {
                    <s_configuredCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::s_currentSubNonce(_) => {
                    <s_currentSubNonceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::s_disabled(_) => {
                    <s_disabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::s_totalNativeBalance(_) => {
                    <s_totalNativeBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::s_withdrawableDirectFundingFeeNative(_) => {
                    <s_withdrawableDirectFundingFeeNativeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::s_withdrawableSubscriptionFeeNative(_) => {
                    <s_withdrawableSubscriptionFeeNativeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setConfig(_) => {
                    <setConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDecryptionSender(_) => {
                    <setDecryptionSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::version(_) => <versionCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::withdrawDirectFundingFeesNative(_) => {
                    <withdrawDirectFundingFeesNativeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdrawSubscriptionFeesNative(_) => {
                    <withdrawSubscriptionFeesNativeCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<BlocklockSenderCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn requestBlocklockWithSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <requestBlocklockWithSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::requestBlocklockWithSubscription)
                    }
                    requestBlocklockWithSubscription
                },
                {
                    fn s_config(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_configCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::s_config)
                    }
                    s_config
                },
                {
                    fn cancelSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <cancelSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::cancelSubscription)
                    }
                    cancelSubscription
                },
                {
                    fn decryptionSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <decryptionSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::decryptionSender)
                    }
                    decryptionSender
                },
                {
                    fn s_totalNativeBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_totalNativeBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_totalNativeBalance)
                    }
                    s_totalNativeBalance
                },
                {
                    fn setDecryptionSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <setDecryptionSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::setDecryptionSender)
                    }
                    setDecryptionSender
                },
                {
                    fn DST_H1_G1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DST_H1_G1Call as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::DST_H1_G1)
                    }
                    DST_H1_G1
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn disable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <disableCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::disable)
                    }
                    disable
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn estimateRequestPriceNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <estimateRequestPriceNativeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::estimateRequestPriceNative)
                    }
                    estimateRequestPriceNative
                },
                {
                    fn getChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::getChainId)
                    }
                    getChainId
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn DST_H2(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DST_H2Call as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::DST_H2)
                    }
                    DST_H2
                },
                {
                    fn s_withdrawableDirectFundingFeeNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_withdrawableDirectFundingFeeNativeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                BlocklockSenderCalls::s_withdrawableDirectFundingFeeNative,
                            )
                    }
                    s_withdrawableDirectFundingFeeNative
                },
                {
                    fn pendingRequestExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <pendingRequestExistsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::pendingRequestExists)
                    }
                    pendingRequestExists
                },
                {
                    fn setConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <setConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::setConfig)
                    }
                    setConfig
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::initialize)
                    }
                    initialize
                },
                {
                    fn calculateRequestPriceNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <calculateRequestPriceNativeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::calculateRequestPriceNative)
                    }
                    calculateRequestPriceNative
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn withdrawDirectFundingFeesNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <withdrawDirectFundingFeesNativeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::withdrawDirectFundingFeesNative)
                    }
                    withdrawDirectFundingFeesNative
                },
                {
                    fn version(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <versionCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::version)
                    }
                    version
                },
                {
                    fn s_configured(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_configuredCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_configured)
                    }
                    s_configured
                },
                {
                    fn receiveDecryptionData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <receiveDecryptionDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::receiveDecryptionData)
                    }
                    receiveDecryptionData
                },
                {
                    fn blocklockRequestsWithDecryptionKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <blocklockRequestsWithDecryptionKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                BlocklockSenderCalls::blocklockRequestsWithDecryptionKey,
                            )
                    }
                    blocklockRequestsWithDecryptionKey
                },
                {
                    fn MAX_CONSUMERS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <MAX_CONSUMERSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::MAX_CONSUMERS)
                    }
                    MAX_CONSUMERS
                },
                {
                    fn DST_H4(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DST_H4Call as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::DST_H4)
                    }
                    DST_H4
                },
                {
                    fn DST_H3(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DST_H3Call as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::DST_H3)
                    }
                    DST_H3
                },
                {
                    fn ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::ADMIN_ROLE)
                    }
                    ADMIN_ROLE
                },
                {
                    fn requestBlocklock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <requestBlocklockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::requestBlocklock)
                    }
                    requestBlocklock
                },
                {
                    fn SCHEME_ID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <SCHEME_IDCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::SCHEME_ID)
                    }
                    SCHEME_ID
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn fundSubscriptionWithNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <fundSubscriptionWithNativeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::fundSubscriptionWithNative)
                    }
                    fundSubscriptionWithNative
                },
                {
                    fn s_withdrawableSubscriptionFeeNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_withdrawableSubscriptionFeeNativeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                BlocklockSenderCalls::s_withdrawableSubscriptionFeeNative,
                            )
                    }
                    s_withdrawableSubscriptionFeeNative
                },
                {
                    fn s_currentSubNonce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_currentSubNonceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_currentSubNonce)
                    }
                    s_currentSubNonce
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn createSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <createSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::createSubscription)
                    }
                    createSubscription
                },
                {
                    fn getRoleMembers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRoleMembersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRoleMembers)
                    }
                    getRoleMembers
                },
                {
                    fn enable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <enableCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::enable)
                    }
                    enable
                },
                {
                    fn s_disabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_disabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_disabled)
                    }
                    s_disabled
                },
                {
                    fn ownerCancelSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <ownerCancelSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::ownerCancelSubscription)
                    }
                    ownerCancelSubscription
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getActiveSubscriptionIds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getActiveSubscriptionIdsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::getActiveSubscriptionIds)
                    }
                    getActiveSubscriptionIds
                },
                {
                    fn acceptSubscriptionOwnerTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <acceptSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::acceptSubscriptionOwnerTransfer)
                    }
                    acceptSubscriptionOwnerTransfer
                },
                {
                    fn withdrawSubscriptionFeesNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <withdrawSubscriptionFeesNativeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::withdrawSubscriptionFeesNative)
                    }
                    withdrawSubscriptionFeesNative
                },
                {
                    fn addConsumer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <addConsumerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::addConsumer)
                    }
                    addConsumer
                },
                {
                    fn getConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::getConfig)
                    }
                    getConfig
                },
                {
                    fn getRequest(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRequestCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRequest)
                    }
                    getRequest
                },
                {
                    fn decrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <decryptCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSenderCalls::decrypt)
                    }
                    decrypt
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn removeConsumer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <removeConsumerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::removeConsumer)
                    }
                    removeConsumer
                },
                {
                    fn isInFlight(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <isInFlightCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::isInFlight)
                    }
                    isInFlight
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn requestSubscriptionOwnerTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <requestSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::requestSubscriptionOwnerTransfer)
                    }
                    requestSubscriptionOwnerTransfer
                },
                {
                    fn getSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderCalls::getSubscription)
                    }
                    getSubscription
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<BlocklockSenderCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn requestBlocklockWithSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <requestBlocklockWithSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::requestBlocklockWithSubscription)
                    }
                    requestBlocklockWithSubscription
                },
                {
                    fn s_config(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_configCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_config)
                    }
                    s_config
                },
                {
                    fn cancelSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <cancelSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::cancelSubscription)
                    }
                    cancelSubscription
                },
                {
                    fn decryptionSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <decryptionSenderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::decryptionSender)
                    }
                    decryptionSender
                },
                {
                    fn s_totalNativeBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_totalNativeBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_totalNativeBalance)
                    }
                    s_totalNativeBalance
                },
                {
                    fn setDecryptionSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <setDecryptionSenderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::setDecryptionSender)
                    }
                    setDecryptionSender
                },
                {
                    fn DST_H1_G1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DST_H1_G1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::DST_H1_G1)
                    }
                    DST_H1_G1
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn disable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <disableCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::disable)
                    }
                    disable
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn estimateRequestPriceNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <estimateRequestPriceNativeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::estimateRequestPriceNative)
                    }
                    estimateRequestPriceNative
                },
                {
                    fn getChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getChainId)
                    }
                    getChainId
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn DST_H2(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DST_H2Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::DST_H2)
                    }
                    DST_H2
                },
                {
                    fn s_withdrawableDirectFundingFeeNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_withdrawableDirectFundingFeeNativeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                BlocklockSenderCalls::s_withdrawableDirectFundingFeeNative,
                            )
                    }
                    s_withdrawableDirectFundingFeeNative
                },
                {
                    fn pendingRequestExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <pendingRequestExistsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::pendingRequestExists)
                    }
                    pendingRequestExists
                },
                {
                    fn setConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <setConfigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::setConfig)
                    }
                    setConfig
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::initialize)
                    }
                    initialize
                },
                {
                    fn calculateRequestPriceNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <calculateRequestPriceNativeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::calculateRequestPriceNative)
                    }
                    calculateRequestPriceNative
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn withdrawDirectFundingFeesNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <withdrawDirectFundingFeesNativeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::withdrawDirectFundingFeesNative)
                    }
                    withdrawDirectFundingFeesNative
                },
                {
                    fn version(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <versionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::version)
                    }
                    version
                },
                {
                    fn s_configured(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_configuredCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_configured)
                    }
                    s_configured
                },
                {
                    fn receiveDecryptionData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <receiveDecryptionDataCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::receiveDecryptionData)
                    }
                    receiveDecryptionData
                },
                {
                    fn blocklockRequestsWithDecryptionKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <blocklockRequestsWithDecryptionKeyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                BlocklockSenderCalls::blocklockRequestsWithDecryptionKey,
                            )
                    }
                    blocklockRequestsWithDecryptionKey
                },
                {
                    fn MAX_CONSUMERS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <MAX_CONSUMERSCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::MAX_CONSUMERS)
                    }
                    MAX_CONSUMERS
                },
                {
                    fn DST_H4(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DST_H4Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::DST_H4)
                    }
                    DST_H4
                },
                {
                    fn DST_H3(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DST_H3Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::DST_H3)
                    }
                    DST_H3
                },
                {
                    fn ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::ADMIN_ROLE)
                    }
                    ADMIN_ROLE
                },
                {
                    fn requestBlocklock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <requestBlocklockCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::requestBlocklock)
                    }
                    requestBlocklock
                },
                {
                    fn SCHEME_ID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <SCHEME_IDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::SCHEME_ID)
                    }
                    SCHEME_ID
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn fundSubscriptionWithNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <fundSubscriptionWithNativeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::fundSubscriptionWithNative)
                    }
                    fundSubscriptionWithNative
                },
                {
                    fn s_withdrawableSubscriptionFeeNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_withdrawableSubscriptionFeeNativeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                BlocklockSenderCalls::s_withdrawableSubscriptionFeeNative,
                            )
                    }
                    s_withdrawableSubscriptionFeeNative
                },
                {
                    fn s_currentSubNonce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_currentSubNonceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_currentSubNonce)
                    }
                    s_currentSubNonce
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn createSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <createSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::createSubscription)
                    }
                    createSubscription
                },
                {
                    fn getRoleMembers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRoleMembersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRoleMembers)
                    }
                    getRoleMembers
                },
                {
                    fn enable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <enableCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::enable)
                    }
                    enable
                },
                {
                    fn s_disabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <s_disabledCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::s_disabled)
                    }
                    s_disabled
                },
                {
                    fn ownerCancelSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <ownerCancelSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::ownerCancelSubscription)
                    }
                    ownerCancelSubscription
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getActiveSubscriptionIds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getActiveSubscriptionIdsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getActiveSubscriptionIds)
                    }
                    getActiveSubscriptionIds
                },
                {
                    fn acceptSubscriptionOwnerTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <acceptSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::acceptSubscriptionOwnerTransfer)
                    }
                    acceptSubscriptionOwnerTransfer
                },
                {
                    fn withdrawSubscriptionFeesNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <withdrawSubscriptionFeesNativeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::withdrawSubscriptionFeesNative)
                    }
                    withdrawSubscriptionFeesNative
                },
                {
                    fn addConsumer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <addConsumerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::addConsumer)
                    }
                    addConsumer
                },
                {
                    fn getConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getConfigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getConfig)
                    }
                    getConfig
                },
                {
                    fn getRequest(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRequestCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRequest)
                    }
                    getRequest
                },
                {
                    fn decrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <decryptCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::decrypt)
                    }
                    decrypt
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn removeConsumer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <removeConsumerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::removeConsumer)
                    }
                    removeConsumer
                },
                {
                    fn isInFlight(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <isInFlightCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::isInFlight)
                    }
                    isInFlight
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn requestSubscriptionOwnerTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <requestSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::requestSubscriptionOwnerTransfer)
                    }
                    requestSubscriptionOwnerTransfer
                },
                {
                    fn getSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderCalls> {
                        <getSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderCalls::getSubscription)
                    }
                    getSubscription
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ADMIN_ROLE(inner) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DST_H1_G1(inner) => {
                    <DST_H1_G1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DST_H2(inner) => {
                    <DST_H2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DST_H3(inner) => {
                    <DST_H3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DST_H4(inner) => {
                    <DST_H4Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::MAX_CONSUMERS(inner) => {
                    <MAX_CONSUMERSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SCHEME_ID(inner) => {
                    <SCHEME_IDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::acceptSubscriptionOwnerTransfer(inner) => {
                    <acceptSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addConsumer(inner) => {
                    <addConsumerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::blocklockRequestsWithDecryptionKey(inner) => {
                    <blocklockRequestsWithDecryptionKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::calculateRequestPriceNative(inner) => {
                    <calculateRequestPriceNativeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::cancelSubscription(inner) => {
                    <cancelSubscriptionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createSubscription(inner) => {
                    <createSubscriptionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decrypt(inner) => {
                    <decryptCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::decryptionSender(inner) => {
                    <decryptionSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::disable(inner) => {
                    <disableCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::enable(inner) => {
                    <enableCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::estimateRequestPriceNative(inner) => {
                    <estimateRequestPriceNativeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fundSubscriptionWithNative(inner) => {
                    <fundSubscriptionWithNativeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getActiveSubscriptionIds(inner) => {
                    <getActiveSubscriptionIdsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getChainId(inner) => {
                    <getChainIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getConfig(inner) => {
                    <getConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getRequest(inner) => {
                    <getRequestCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMembers(inner) => {
                    <getRoleMembersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSubscription(inner) => {
                    <getSubscriptionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isInFlight(inner) => {
                    <isInFlightCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::ownerCancelSubscription(inner) => {
                    <ownerCancelSubscriptionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pendingRequestExists(inner) => {
                    <pendingRequestExistsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::receiveDecryptionData(inner) => {
                    <receiveDecryptionDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeConsumer(inner) => {
                    <removeConsumerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requestBlocklock(inner) => {
                    <requestBlocklockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requestBlocklockWithSubscription(inner) => {
                    <requestBlocklockWithSubscriptionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requestSubscriptionOwnerTransfer(inner) => {
                    <requestSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::s_config(inner) => {
                    <s_configCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::s_configured(inner) => {
                    <s_configuredCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::s_currentSubNonce(inner) => {
                    <s_currentSubNonceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::s_disabled(inner) => {
                    <s_disabledCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::s_totalNativeBalance(inner) => {
                    <s_totalNativeBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::s_withdrawableDirectFundingFeeNative(inner) => {
                    <s_withdrawableDirectFundingFeeNativeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::s_withdrawableSubscriptionFeeNative(inner) => {
                    <s_withdrawableSubscriptionFeeNativeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setConfig(inner) => {
                    <setConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setDecryptionSender(inner) => {
                    <setDecryptionSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::version(inner) => {
                    <versionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::withdrawDirectFundingFeesNative(inner) => {
                    <withdrawDirectFundingFeesNativeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::withdrawSubscriptionFeesNative(inner) => {
                    <withdrawSubscriptionFeesNativeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ADMIN_ROLE(inner) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DST_H1_G1(inner) => {
                    <DST_H1_G1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DST_H2(inner) => {
                    <DST_H2Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::DST_H3(inner) => {
                    <DST_H3Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::DST_H4(inner) => {
                    <DST_H4Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::MAX_CONSUMERS(inner) => {
                    <MAX_CONSUMERSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SCHEME_ID(inner) => {
                    <SCHEME_IDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::acceptSubscriptionOwnerTransfer(inner) => {
                    <acceptSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addConsumer(inner) => {
                    <addConsumerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::blocklockRequestsWithDecryptionKey(inner) => {
                    <blocklockRequestsWithDecryptionKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calculateRequestPriceNative(inner) => {
                    <calculateRequestPriceNativeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::cancelSubscription(inner) => {
                    <cancelSubscriptionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createSubscription(inner) => {
                    <createSubscriptionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decrypt(inner) => {
                    <decryptCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::decryptionSender(inner) => {
                    <decryptionSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::disable(inner) => {
                    <disableCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::enable(inner) => {
                    <enableCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::estimateRequestPriceNative(inner) => {
                    <estimateRequestPriceNativeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fundSubscriptionWithNative(inner) => {
                    <fundSubscriptionWithNativeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getActiveSubscriptionIds(inner) => {
                    <getActiveSubscriptionIdsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getChainId(inner) => {
                    <getChainIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getConfig(inner) => {
                    <getConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRequest(inner) => {
                    <getRequestCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMembers(inner) => {
                    <getRoleMembersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSubscription(inner) => {
                    <getSubscriptionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isInFlight(inner) => {
                    <isInFlightCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ownerCancelSubscription(inner) => {
                    <ownerCancelSubscriptionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pendingRequestExists(inner) => {
                    <pendingRequestExistsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::receiveDecryptionData(inner) => {
                    <receiveDecryptionDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeConsumer(inner) => {
                    <removeConsumerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requestBlocklock(inner) => {
                    <requestBlocklockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requestBlocklockWithSubscription(inner) => {
                    <requestBlocklockWithSubscriptionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requestSubscriptionOwnerTransfer(inner) => {
                    <requestSubscriptionOwnerTransferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::s_config(inner) => {
                    <s_configCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::s_configured(inner) => {
                    <s_configuredCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::s_currentSubNonce(inner) => {
                    <s_currentSubNonceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::s_disabled(inner) => {
                    <s_disabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::s_totalNativeBalance(inner) => {
                    <s_totalNativeBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::s_withdrawableDirectFundingFeeNative(inner) => {
                    <s_withdrawableDirectFundingFeeNativeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::s_withdrawableSubscriptionFeeNative(inner) => {
                    <s_withdrawableSubscriptionFeeNativeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setConfig(inner) => {
                    <setConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDecryptionSender(inner) => {
                    <setDecryptionSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::version(inner) => {
                    <versionCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::withdrawDirectFundingFeesNative(inner) => {
                    <withdrawDirectFundingFeesNativeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawSubscriptionFeesNative(inner) => {
                    <withdrawSubscriptionFeesNativeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`BlocklockSender`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum BlocklockSenderErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        BalanceInvariantViolated(BalanceInvariantViolated),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        FailedToSendNative(FailedToSendNative),
        #[allow(missing_docs)]
        IndexOutOfRange(IndexOutOfRange),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        InvalidCalldata(InvalidCalldata),
        #[allow(missing_docs)]
        InvalidConsumer(InvalidConsumer),
        #[allow(missing_docs)]
        InvalidDSTLength(InvalidDSTLength),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidSubscription(InvalidSubscription),
        #[allow(missing_docs)]
        MustBeRequestedOwner(MustBeRequestedOwner),
        #[allow(missing_docs)]
        MustBeSubOwner(MustBeSubOwner),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        PendingRequestExists(PendingRequestExists),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        TooManyConsumers(TooManyConsumers),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
    }
    #[automatically_derived]
    impl BlocklockSenderErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [5u8, 164u8, 142u8, 15u8],
            [19u8, 144u8, 242u8, 161u8],
            [31u8, 106u8, 101u8, 182u8],
            [38u8, 228u8, 249u8, 186u8],
            [62u8, 229u8, 174u8, 181u8],
            [76u8, 156u8, 140u8, 227u8],
            [102u8, 151u8, 178u8, 50u8],
            [121u8, 191u8, 212u8, 1u8],
            [129u8, 41u8, 187u8, 205u8],
            [149u8, 11u8, 36u8, 121u8],
            [153u8, 150u8, 179u8, 21u8],
            [169u8, 157u8, 163u8, 2u8],
            [170u8, 29u8, 73u8, 164u8],
            [179u8, 152u8, 151u8, 159u8],
            [180u8, 47u8, 102u8, 232u8],
            [208u8, 132u8, 233u8, 117u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [216u8, 163u8, 251u8, 82u8],
            [224u8, 124u8, 141u8, 186u8],
            [226u8, 81u8, 125u8, 63u8],
            [244u8, 214u8, 120u8, 184u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for BlocklockSenderErrors {
        const NAME: &'static str = "BlocklockSenderErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 23usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BalanceInvariantViolated(_) => {
                    <BalanceInvariantViolated as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedToSendNative(_) => {
                    <FailedToSendNative as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IndexOutOfRange(_) => {
                    <IndexOutOfRange as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidCalldata(_) => {
                    <InvalidCalldata as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidConsumer(_) => {
                    <InvalidConsumer as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDSTLength(_) => {
                    <InvalidDSTLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSubscription(_) => {
                    <InvalidSubscription as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MustBeRequestedOwner(_) => {
                    <MustBeRequestedOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MustBeSubOwner(_) => {
                    <MustBeSubOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PendingRequestExists(_) => {
                    <PendingRequestExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TooManyConsumers(_) => {
                    <TooManyConsumers as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<BlocklockSenderErrors>] = &[
                {
                    fn TooManyConsumers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <TooManyConsumers as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::TooManyConsumers)
                    }
                    TooManyConsumers
                },
                {
                    fn IndexOutOfRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <IndexOutOfRange as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::IndexOutOfRange)
                    }
                    IndexOutOfRange
                },
                {
                    fn InvalidSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidSubscription as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidSubscription)
                    }
                    InvalidSubscription
                },
                {
                    fn InvalidDSTLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidDSTLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidDSTLength)
                    }
                    InvalidDSTLength
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn InvalidConsumer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidConsumer as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidConsumer)
                    }
                    InvalidConsumer
                },
                {
                    fn InvalidCalldata(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidCalldata as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidCalldata)
                    }
                    InvalidCalldata
                },
                {
                    fn FailedToSendNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <FailedToSendNative as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::FailedToSendNative)
                    }
                    FailedToSendNative
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn BalanceInvariantViolated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <BalanceInvariantViolated as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::BalanceInvariantViolated)
                    }
                    BalanceInvariantViolated
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn PendingRequestExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <PendingRequestExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::PendingRequestExists)
                    }
                    PendingRequestExists
                },
                {
                    fn MustBeRequestedOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <MustBeRequestedOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::MustBeRequestedOwner)
                    }
                    MustBeRequestedOwner
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(BlocklockSenderErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn MustBeSubOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <MustBeSubOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::MustBeSubOwner)
                    }
                    MustBeSubOwner
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<BlocklockSenderErrors>] = &[
                {
                    fn TooManyConsumers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <TooManyConsumers as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::TooManyConsumers)
                    }
                    TooManyConsumers
                },
                {
                    fn IndexOutOfRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <IndexOutOfRange as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::IndexOutOfRange)
                    }
                    IndexOutOfRange
                },
                {
                    fn InvalidSubscription(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidSubscription as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidSubscription)
                    }
                    InvalidSubscription
                },
                {
                    fn InvalidDSTLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidDSTLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidDSTLength)
                    }
                    InvalidDSTLength
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn InvalidConsumer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidConsumer as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidConsumer)
                    }
                    InvalidConsumer
                },
                {
                    fn InvalidCalldata(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidCalldata as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidCalldata)
                    }
                    InvalidCalldata
                },
                {
                    fn FailedToSendNative(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <FailedToSendNative as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::FailedToSendNative)
                    }
                    FailedToSendNative
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn BalanceInvariantViolated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <BalanceInvariantViolated as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::BalanceInvariantViolated)
                    }
                    BalanceInvariantViolated
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn PendingRequestExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <PendingRequestExists as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::PendingRequestExists)
                    }
                    PendingRequestExists
                },
                {
                    fn MustBeRequestedOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <MustBeRequestedOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::MustBeRequestedOwner)
                    }
                    MustBeRequestedOwner
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn MustBeSubOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <MustBeSubOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::MustBeSubOwner)
                    }
                    MustBeSubOwner
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSenderErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSenderErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BalanceInvariantViolated(inner) => {
                    <BalanceInvariantViolated as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedToSendNative(inner) => {
                    <FailedToSendNative as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IndexOutOfRange(inner) => {
                    <IndexOutOfRange as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidCalldata(inner) => {
                    <InvalidCalldata as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidConsumer(inner) => {
                    <InvalidConsumer as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDSTLength(inner) => {
                    <InvalidDSTLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSubscription(inner) => {
                    <InvalidSubscription as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MustBeRequestedOwner(inner) => {
                    <MustBeRequestedOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MustBeSubOwner(inner) => {
                    <MustBeSubOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PendingRequestExists(inner) => {
                    <PendingRequestExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TooManyConsumers(inner) => {
                    <TooManyConsumers as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BalanceInvariantViolated(inner) => {
                    <BalanceInvariantViolated as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::FailedToSendNative(inner) => {
                    <FailedToSendNative as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IndexOutOfRange(inner) => {
                    <IndexOutOfRange as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidCalldata(inner) => {
                    <InvalidCalldata as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidConsumer(inner) => {
                    <InvalidConsumer as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDSTLength(inner) => {
                    <InvalidDSTLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSubscription(inner) => {
                    <InvalidSubscription as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MustBeRequestedOwner(inner) => {
                    <MustBeRequestedOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MustBeSubOwner(inner) => {
                    <MustBeSubOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PendingRequestExists(inner) => {
                    <PendingRequestExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TooManyConsumers(inner) => {
                    <TooManyConsumers as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`BlocklockSender`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum BlocklockSenderEvents {
        #[allow(missing_docs)]
        BlocklockCallbackFailed(BlocklockCallbackFailed),
        #[allow(missing_docs)]
        BlocklockCallbackSuccess(BlocklockCallbackSuccess),
        #[allow(missing_docs)]
        BlocklockRequested(BlocklockRequested),
        #[allow(missing_docs)]
        ConfigSet(ConfigSet),
        #[allow(missing_docs)]
        DecryptionSenderUpdated(DecryptionSenderUpdated),
        #[allow(missing_docs)]
        Disabled(Disabled),
        #[allow(missing_docs)]
        Enabled(Enabled),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        L1GasFee(L1GasFee),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        SubscriptionCanceled(SubscriptionCanceled),
        #[allow(missing_docs)]
        SubscriptionConsumerAdded(SubscriptionConsumerAdded),
        #[allow(missing_docs)]
        SubscriptionConsumerRemoved(SubscriptionConsumerRemoved),
        #[allow(missing_docs)]
        SubscriptionCreated(SubscriptionCreated),
        #[allow(missing_docs)]
        SubscriptionFundedWithNative(SubscriptionFundedWithNative),
        #[allow(missing_docs)]
        SubscriptionOwnerTransferRequested(SubscriptionOwnerTransferRequested),
        #[allow(missing_docs)]
        SubscriptionOwnerTransferred(SubscriptionOwnerTransferred),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
    }
    #[automatically_derived]
    impl BlocklockSenderEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                13u8, 174u8, 29u8, 0u8, 46u8, 150u8, 194u8, 56u8, 235u8, 225u8, 64u8,
                202u8, 23u8, 153u8, 247u8, 112u8, 147u8, 174u8, 9u8, 224u8, 189u8, 228u8,
                15u8, 121u8, 187u8, 41u8, 237u8, 120u8, 208u8, 158u8, 101u8, 45u8,
            ],
            [
                21u8, 8u8, 53u8, 54u8, 80u8, 118u8, 102u8, 128u8, 44u8, 189u8, 132u8,
                252u8, 193u8, 227u8, 126u8, 216u8, 152u8, 121u8, 186u8, 210u8, 52u8,
                90u8, 170u8, 56u8, 212u8, 141u8, 145u8, 165u8, 7u8, 29u8, 15u8, 93u8,
            ],
            [
                29u8, 48u8, 21u8, 215u8, 186u8, 133u8, 15u8, 161u8, 152u8, 220u8, 123u8,
                26u8, 63u8, 93u8, 66u8, 119u8, 147u8, 19u8, 166u8, 129u8, 3u8, 95u8,
                119u8, 200u8, 192u8, 55u8, 100u8, 198u8, 16u8, 5u8, 81u8, 141u8,
            ],
            [
                30u8, 152u8, 13u8, 4u8, 170u8, 118u8, 72u8, 226u8, 5u8, 113u8, 62u8,
                94u8, 142u8, 163u8, 128u8, 134u8, 114u8, 172u8, 22u8, 61u8, 16u8, 147u8,
                109u8, 54u8, 249u8, 27u8, 44u8, 136u8, 172u8, 21u8, 117u8, 225u8,
            ],
            [
                33u8, 164u8, 218u8, 209u8, 112u8, 166u8, 191u8, 71u8, 108u8, 49u8, 187u8,
                207u8, 74u8, 22u8, 98u8, 130u8, 149u8, 176u8, 228u8, 80u8, 103u8, 46u8,
                236u8, 37u8, 215u8, 201u8, 51u8, 8u8, 224u8, 83u8, 68u8, 161u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                50u8, 21u8, 140u8, 96u8, 88u8, 52u8, 124u8, 22u8, 1u8, 178u8, 209u8,
                43u8, 198u8, 150u8, 172u8, 105u8, 1u8, 216u8, 169u8, 169u8, 170u8, 59u8,
                161u8, 12u8, 39u8, 171u8, 10u8, 152u8, 62u8, 132u8, 37u8, 167u8,
            ],
            [
                55u8, 132u8, 247u8, 126u8, 142u8, 136u8, 61u8, 233u8, 91u8, 93u8, 71u8,
                205u8, 113u8, 60u8, 237u8, 1u8, 34u8, 159u8, 167u8, 77u8, 17u8, 140u8,
                10u8, 70u8, 34u8, 36u8, 188u8, 176u8, 81u8, 109u8, 67u8, 241u8,
            ],
            [
                85u8, 162u8, 143u8, 222u8, 41u8, 95u8, 72u8, 44u8, 159u8, 50u8, 214u8,
                112u8, 193u8, 22u8, 16u8, 59u8, 202u8, 21u8, 114u8, 75u8, 206u8, 244u8,
                241u8, 139u8, 53u8, 84u8, 46u8, 5u8, 83u8, 195u8, 90u8, 213u8,
            ],
            [
                86u8, 41u8, 111u8, 123u8, 234u8, 224u8, 90u8, 13u8, 184u8, 21u8, 115u8,
                127u8, 219u8, 76u8, 210u8, 152u8, 137u8, 123u8, 30u8, 81u8, 118u8, 20u8,
                214u8, 36u8, 104u8, 8u8, 21u8, 49u8, 174u8, 20u8, 208u8, 153u8,
            ],
            [
                117u8, 136u8, 76u8, 218u8, 220u8, 74u8, 137u8, 232u8, 181u8, 69u8, 219u8,
                128u8, 0u8, 87u8, 240u8, 110u8, 199u8, 245u8, 51u8, 138u8, 8u8, 24u8,
                60u8, 123u8, 165u8, 21u8, 242u8, 191u8, 221u8, 159u8, 225u8, 225u8,
            ],
            [
                118u8, 3u8, 178u8, 5u8, 208u8, 54u8, 81u8, 238u8, 129u8, 47u8, 128u8,
                63u8, 204u8, 222u8, 137u8, 241u8, 1u8, 46u8, 84u8, 90u8, 156u8, 153u8,
                240u8, 171u8, 254u8, 169u8, 206u8, 221u8, 15u8, 216u8, 233u8, 2u8,
            ],
            [
                153u8, 253u8, 21u8, 151u8, 76u8, 191u8, 0u8, 240u8, 242u8, 8u8, 186u8,
                174u8, 90u8, 40u8, 37u8, 250u8, 115u8, 99u8, 151u8, 234u8, 199u8, 226u8,
                186u8, 48u8, 3u8, 200u8, 39u8, 67u8, 140u8, 160u8, 147u8, 247u8,
            ],
            [
                167u8, 207u8, 87u8, 96u8, 155u8, 74u8, 190u8, 214u8, 137u8, 180u8, 8u8,
                219u8, 11u8, 12u8, 61u8, 198u8, 48u8, 151u8, 134u8, 182u8, 192u8, 125u8,
                94u8, 251u8, 189u8, 29u8, 91u8, 21u8, 14u8, 109u8, 44u8, 6u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                192u8, 249u8, 97u8, 5u8, 31u8, 151u8, 176u8, 76u8, 73u8, 100u8, 114u8,
                209u8, 28u8, 182u8, 23u8, 13u8, 132u8, 78u8, 75u8, 44u8, 157u8, 253u8,
                59u8, 96u8, 42u8, 79u8, 160u8, 19u8, 151u8, 18u8, 212u8, 132u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                212u8, 17u8, 74u8, 182u8, 233u8, 175u8, 159u8, 89u8, 124u8, 82u8, 4u8,
                31u8, 50u8, 214u8, 45u8, 197u8, 124u8, 92u8, 78u8, 76u8, 13u8, 68u8,
                39u8, 0u8, 96u8, 105u8, 99u8, 94u8, 33u8, 108u8, 147u8, 134u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for BlocklockSenderEvents {
        const NAME: &'static str = "BlocklockSenderEvents";
        const COUNT: usize = 20usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <BlocklockCallbackFailed as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlocklockCallbackFailed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BlocklockCallbackFailed)
                }
                Some(
                    <BlocklockCallbackSuccess as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlocklockCallbackSuccess as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BlocklockCallbackSuccess)
                }
                Some(
                    <BlocklockRequested as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlocklockRequested as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BlocklockRequested)
                }
                Some(<ConfigSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ConfigSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ConfigSet)
                }
                Some(
                    <DecryptionSenderUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DecryptionSenderUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DecryptionSenderUpdated)
                }
                Some(<Disabled as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Disabled as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Disabled)
                }
                Some(<Enabled as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Enabled as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Enabled)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(<L1GasFee as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <L1GasFee as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::L1GasFee)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(
                    <SubscriptionCanceled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubscriptionCanceled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SubscriptionCanceled)
                }
                Some(
                    <SubscriptionConsumerAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubscriptionConsumerAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SubscriptionConsumerAdded)
                }
                Some(
                    <SubscriptionConsumerRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubscriptionConsumerRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SubscriptionConsumerRemoved)
                }
                Some(
                    <SubscriptionCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubscriptionCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SubscriptionCreated)
                }
                Some(
                    <SubscriptionFundedWithNative as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubscriptionFundedWithNative as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SubscriptionFundedWithNative)
                }
                Some(
                    <SubscriptionOwnerTransferRequested as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubscriptionOwnerTransferRequested as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SubscriptionOwnerTransferRequested)
                }
                Some(
                    <SubscriptionOwnerTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubscriptionOwnerTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SubscriptionOwnerTransferred)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for BlocklockSenderEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BlocklockCallbackFailed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlocklockCallbackSuccess(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlocklockRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ConfigSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DecryptionSenderUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Disabled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Enabled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::L1GasFee(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubscriptionCanceled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubscriptionConsumerAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubscriptionConsumerRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubscriptionCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubscriptionFundedWithNative(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubscriptionOwnerTransferRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubscriptionOwnerTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BlocklockCallbackFailed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlocklockCallbackSuccess(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlocklockRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ConfigSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DecryptionSenderUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Disabled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Enabled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::L1GasFee(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubscriptionCanceled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubscriptionConsumerAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubscriptionConsumerRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubscriptionCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubscriptionFundedWithNative(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubscriptionOwnerTransferRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubscriptionOwnerTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`BlocklockSender`](self) contract instance.

See the [wrapper's documentation](`BlocklockSenderInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> BlocklockSenderInstance<P, N> {
        BlocklockSenderInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<BlocklockSenderInstance<P, N>>,
    > {
        BlocklockSenderInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        BlocklockSenderInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`BlocklockSender`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`BlocklockSender`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct BlocklockSenderInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for BlocklockSenderInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("BlocklockSenderInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BlocklockSenderInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`BlocklockSender`](self) contract instance.

See the [wrapper's documentation](`BlocklockSenderInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<BlocklockSenderInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> BlocklockSenderInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> BlocklockSenderInstance<P, N> {
            BlocklockSenderInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BlocklockSenderInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`ADMIN_ROLE`] function.
        pub fn ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, ADMIN_ROLECall, N> {
            self.call_builder(&ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`DST_H1_G1`] function.
        pub fn DST_H1_G1(&self) -> alloy_contract::SolCallBuilder<&P, DST_H1_G1Call, N> {
            self.call_builder(&DST_H1_G1Call)
        }
        ///Creates a new call builder for the [`DST_H2`] function.
        pub fn DST_H2(&self) -> alloy_contract::SolCallBuilder<&P, DST_H2Call, N> {
            self.call_builder(&DST_H2Call)
        }
        ///Creates a new call builder for the [`DST_H3`] function.
        pub fn DST_H3(&self) -> alloy_contract::SolCallBuilder<&P, DST_H3Call, N> {
            self.call_builder(&DST_H3Call)
        }
        ///Creates a new call builder for the [`DST_H4`] function.
        pub fn DST_H4(&self) -> alloy_contract::SolCallBuilder<&P, DST_H4Call, N> {
            self.call_builder(&DST_H4Call)
        }
        ///Creates a new call builder for the [`MAX_CONSUMERS`] function.
        pub fn MAX_CONSUMERS(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MAX_CONSUMERSCall, N> {
            self.call_builder(&MAX_CONSUMERSCall)
        }
        ///Creates a new call builder for the [`SCHEME_ID`] function.
        pub fn SCHEME_ID(&self) -> alloy_contract::SolCallBuilder<&P, SCHEME_IDCall, N> {
            self.call_builder(&SCHEME_IDCall)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`acceptSubscriptionOwnerTransfer`] function.
        pub fn acceptSubscriptionOwnerTransfer(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, acceptSubscriptionOwnerTransferCall, N> {
            self.call_builder(
                &acceptSubscriptionOwnerTransferCall {
                    subId,
                },
            )
        }
        ///Creates a new call builder for the [`addConsumer`] function.
        pub fn addConsumer(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
            consumer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, addConsumerCall, N> {
            self.call_builder(&addConsumerCall { subId, consumer })
        }
        ///Creates a new call builder for the [`blocklockRequestsWithDecryptionKey`] function.
        pub fn blocklockRequestsWithDecryptionKey(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            blocklockRequestsWithDecryptionKeyCall,
            N,
        > {
            self.call_builder(&blocklockRequestsWithDecryptionKeyCall(_0))
        }
        ///Creates a new call builder for the [`calculateRequestPriceNative`] function.
        pub fn calculateRequestPriceNative(
            &self,
            _callbackGasLimit: u32,
        ) -> alloy_contract::SolCallBuilder<&P, calculateRequestPriceNativeCall, N> {
            self.call_builder(
                &calculateRequestPriceNativeCall {
                    _callbackGasLimit,
                },
            )
        }
        ///Creates a new call builder for the [`cancelSubscription`] function.
        pub fn cancelSubscription(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, cancelSubscriptionCall, N> {
            self.call_builder(
                &cancelSubscriptionCall {
                    subId,
                    to,
                },
            )
        }
        ///Creates a new call builder for the [`createSubscription`] function.
        pub fn createSubscription(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, createSubscriptionCall, N> {
            self.call_builder(&createSubscriptionCall)
        }
        ///Creates a new call builder for the [`decrypt`] function.
        pub fn decrypt(
            &self,
            ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
            decryptionKey: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, decryptCall, N> {
            self.call_builder(
                &decryptCall {
                    ciphertext,
                    decryptionKey,
                },
            )
        }
        ///Creates a new call builder for the [`decryptionSender`] function.
        pub fn decryptionSender(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, decryptionSenderCall, N> {
            self.call_builder(&decryptionSenderCall)
        }
        ///Creates a new call builder for the [`disable`] function.
        pub fn disable(&self) -> alloy_contract::SolCallBuilder<&P, disableCall, N> {
            self.call_builder(&disableCall)
        }
        ///Creates a new call builder for the [`enable`] function.
        pub fn enable(&self) -> alloy_contract::SolCallBuilder<&P, enableCall, N> {
            self.call_builder(&enableCall)
        }
        ///Creates a new call builder for the [`estimateRequestPriceNative`] function.
        pub fn estimateRequestPriceNative(
            &self,
            _callbackGasLimit: u32,
            _requestGasPriceWei: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, estimateRequestPriceNativeCall, N> {
            self.call_builder(
                &estimateRequestPriceNativeCall {
                    _callbackGasLimit,
                    _requestGasPriceWei,
                },
            )
        }
        ///Creates a new call builder for the [`fundSubscriptionWithNative`] function.
        pub fn fundSubscriptionWithNative(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, fundSubscriptionWithNativeCall, N> {
            self.call_builder(
                &fundSubscriptionWithNativeCall {
                    subId,
                },
            )
        }
        ///Creates a new call builder for the [`getActiveSubscriptionIds`] function.
        pub fn getActiveSubscriptionIds(
            &self,
            startIndex: alloy::sol_types::private::primitives::aliases::U256,
            maxCount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getActiveSubscriptionIdsCall, N> {
            self.call_builder(
                &getActiveSubscriptionIdsCall {
                    startIndex,
                    maxCount,
                },
            )
        }
        ///Creates a new call builder for the [`getChainId`] function.
        pub fn getChainId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getChainIdCall, N> {
            self.call_builder(&getChainIdCall)
        }
        ///Creates a new call builder for the [`getConfig`] function.
        pub fn getConfig(&self) -> alloy_contract::SolCallBuilder<&P, getConfigCall, N> {
            self.call_builder(&getConfigCall)
        }
        ///Creates a new call builder for the [`getRequest`] function.
        pub fn getRequest(
            &self,
            requestId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getRequestCall, N> {
            self.call_builder(&getRequestCall { requestId })
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getRoleMember`] function.
        pub fn getRoleMember(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCall, N> {
            self.call_builder(&getRoleMemberCall { role, index })
        }
        ///Creates a new call builder for the [`getRoleMemberCount`] function.
        pub fn getRoleMemberCount(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCountCall, N> {
            self.call_builder(&getRoleMemberCountCall { role })
        }
        ///Creates a new call builder for the [`getRoleMembers`] function.
        pub fn getRoleMembers(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMembersCall, N> {
            self.call_builder(&getRoleMembersCall { role })
        }
        ///Creates a new call builder for the [`getSubscription`] function.
        pub fn getSubscription(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getSubscriptionCall, N> {
            self.call_builder(&getSubscriptionCall { subId })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            owner: alloy::sol_types::private::Address,
            _decryptionSender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    owner,
                    _decryptionSender,
                },
            )
        }
        ///Creates a new call builder for the [`isInFlight`] function.
        pub fn isInFlight(
            &self,
            requestId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, isInFlightCall, N> {
            self.call_builder(&isInFlightCall { requestId })
        }
        ///Creates a new call builder for the [`ownerCancelSubscription`] function.
        pub fn ownerCancelSubscription(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, ownerCancelSubscriptionCall, N> {
            self.call_builder(
                &ownerCancelSubscriptionCall {
                    subId,
                },
            )
        }
        ///Creates a new call builder for the [`pendingRequestExists`] function.
        pub fn pendingRequestExists(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, pendingRequestExistsCall, N> {
            self.call_builder(&pendingRequestExistsCall { subId })
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`receiveDecryptionData`] function.
        pub fn receiveDecryptionData(
            &self,
            requestId: alloy::sol_types::private::primitives::aliases::U256,
            decryptionKey: alloy::sol_types::private::Bytes,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, receiveDecryptionDataCall, N> {
            self.call_builder(
                &receiveDecryptionDataCall {
                    requestId,
                    decryptionKey,
                    signature,
                },
            )
        }
        ///Creates a new call builder for the [`removeConsumer`] function.
        pub fn removeConsumer(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
            consumer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, removeConsumerCall, N> {
            self.call_builder(
                &removeConsumerCall {
                    subId,
                    consumer,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`requestBlocklock`] function.
        pub fn requestBlocklock(
            &self,
            callbackGasLimit: u32,
            condition: alloy::sol_types::private::Bytes,
            ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, requestBlocklockCall, N> {
            self.call_builder(
                &requestBlocklockCall {
                    callbackGasLimit,
                    condition,
                    ciphertext,
                },
            )
        }
        ///Creates a new call builder for the [`requestBlocklockWithSubscription`] function.
        pub fn requestBlocklockWithSubscription(
            &self,
            callbackGasLimit: u32,
            subId: alloy::sol_types::private::primitives::aliases::U256,
            condition: alloy::sol_types::private::Bytes,
            ciphertext: <TypesLib::Ciphertext as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            requestBlocklockWithSubscriptionCall,
            N,
        > {
            self.call_builder(
                &requestBlocklockWithSubscriptionCall {
                    callbackGasLimit,
                    subId,
                    condition,
                    ciphertext,
                },
            )
        }
        ///Creates a new call builder for the [`requestSubscriptionOwnerTransfer`] function.
        pub fn requestSubscriptionOwnerTransfer(
            &self,
            subId: alloy::sol_types::private::primitives::aliases::U256,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            requestSubscriptionOwnerTransferCall,
            N,
        > {
            self.call_builder(
                &requestSubscriptionOwnerTransferCall {
                    subId,
                    newOwner,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`s_config`] function.
        pub fn s_config(&self) -> alloy_contract::SolCallBuilder<&P, s_configCall, N> {
            self.call_builder(&s_configCall)
        }
        ///Creates a new call builder for the [`s_configured`] function.
        pub fn s_configured(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, s_configuredCall, N> {
            self.call_builder(&s_configuredCall)
        }
        ///Creates a new call builder for the [`s_currentSubNonce`] function.
        pub fn s_currentSubNonce(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, s_currentSubNonceCall, N> {
            self.call_builder(&s_currentSubNonceCall)
        }
        ///Creates a new call builder for the [`s_disabled`] function.
        pub fn s_disabled(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, s_disabledCall, N> {
            self.call_builder(&s_disabledCall)
        }
        ///Creates a new call builder for the [`s_totalNativeBalance`] function.
        pub fn s_totalNativeBalance(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, s_totalNativeBalanceCall, N> {
            self.call_builder(&s_totalNativeBalanceCall)
        }
        ///Creates a new call builder for the [`s_withdrawableDirectFundingFeeNative`] function.
        pub fn s_withdrawableDirectFundingFeeNative(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            s_withdrawableDirectFundingFeeNativeCall,
            N,
        > {
            self.call_builder(&s_withdrawableDirectFundingFeeNativeCall)
        }
        ///Creates a new call builder for the [`s_withdrawableSubscriptionFeeNative`] function.
        pub fn s_withdrawableSubscriptionFeeNative(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            s_withdrawableSubscriptionFeeNativeCall,
            N,
        > {
            self.call_builder(&s_withdrawableSubscriptionFeeNativeCall)
        }
        ///Creates a new call builder for the [`setConfig`] function.
        pub fn setConfig(
            &self,
            maxGasLimit: u32,
            gasAfterPaymentCalculation: u32,
            fulfillmentFlatFeeNativePPM: u32,
            weiPerUnitGas: u32,
            blsPairingCheckOverhead: u32,
            nativePremiumPercentage: u8,
            gasForCallExactCheck: u32,
        ) -> alloy_contract::SolCallBuilder<&P, setConfigCall, N> {
            self.call_builder(
                &setConfigCall {
                    maxGasLimit,
                    gasAfterPaymentCalculation,
                    fulfillmentFlatFeeNativePPM,
                    weiPerUnitGas,
                    blsPairingCheckOverhead,
                    nativePremiumPercentage,
                    gasForCallExactCheck,
                },
            )
        }
        ///Creates a new call builder for the [`setDecryptionSender`] function.
        pub fn setDecryptionSender(
            &self,
            newDecryptionSender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setDecryptionSenderCall, N> {
            self.call_builder(
                &setDecryptionSenderCall {
                    newDecryptionSender,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`version`] function.
        pub fn version(&self) -> alloy_contract::SolCallBuilder<&P, versionCall, N> {
            self.call_builder(&versionCall)
        }
        ///Creates a new call builder for the [`withdrawDirectFundingFeesNative`] function.
        pub fn withdrawDirectFundingFeesNative(
            &self,
            recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawDirectFundingFeesNativeCall, N> {
            self.call_builder(
                &withdrawDirectFundingFeesNativeCall {
                    recipient,
                },
            )
        }
        ///Creates a new call builder for the [`withdrawSubscriptionFeesNative`] function.
        pub fn withdrawSubscriptionFeesNative(
            &self,
            recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawSubscriptionFeesNativeCall, N> {
            self.call_builder(
                &withdrawSubscriptionFeesNativeCall {
                    recipient,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BlocklockSenderInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BlocklockCallbackFailed`] event.
        pub fn BlocklockCallbackFailed_filter(
            &self,
        ) -> alloy_contract::Event<&P, BlocklockCallbackFailed, N> {
            self.event_filter::<BlocklockCallbackFailed>()
        }
        ///Creates a new event filter for the [`BlocklockCallbackSuccess`] event.
        pub fn BlocklockCallbackSuccess_filter(
            &self,
        ) -> alloy_contract::Event<&P, BlocklockCallbackSuccess, N> {
            self.event_filter::<BlocklockCallbackSuccess>()
        }
        ///Creates a new event filter for the [`BlocklockRequested`] event.
        pub fn BlocklockRequested_filter(
            &self,
        ) -> alloy_contract::Event<&P, BlocklockRequested, N> {
            self.event_filter::<BlocklockRequested>()
        }
        ///Creates a new event filter for the [`ConfigSet`] event.
        pub fn ConfigSet_filter(&self) -> alloy_contract::Event<&P, ConfigSet, N> {
            self.event_filter::<ConfigSet>()
        }
        ///Creates a new event filter for the [`DecryptionSenderUpdated`] event.
        pub fn DecryptionSenderUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, DecryptionSenderUpdated, N> {
            self.event_filter::<DecryptionSenderUpdated>()
        }
        ///Creates a new event filter for the [`Disabled`] event.
        pub fn Disabled_filter(&self) -> alloy_contract::Event<&P, Disabled, N> {
            self.event_filter::<Disabled>()
        }
        ///Creates a new event filter for the [`Enabled`] event.
        pub fn Enabled_filter(&self) -> alloy_contract::Event<&P, Enabled, N> {
            self.event_filter::<Enabled>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`L1GasFee`] event.
        pub fn L1GasFee_filter(&self) -> alloy_contract::Event<&P, L1GasFee, N> {
            self.event_filter::<L1GasFee>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`SubscriptionCanceled`] event.
        pub fn SubscriptionCanceled_filter(
            &self,
        ) -> alloy_contract::Event<&P, SubscriptionCanceled, N> {
            self.event_filter::<SubscriptionCanceled>()
        }
        ///Creates a new event filter for the [`SubscriptionConsumerAdded`] event.
        pub fn SubscriptionConsumerAdded_filter(
            &self,
        ) -> alloy_contract::Event<&P, SubscriptionConsumerAdded, N> {
            self.event_filter::<SubscriptionConsumerAdded>()
        }
        ///Creates a new event filter for the [`SubscriptionConsumerRemoved`] event.
        pub fn SubscriptionConsumerRemoved_filter(
            &self,
        ) -> alloy_contract::Event<&P, SubscriptionConsumerRemoved, N> {
            self.event_filter::<SubscriptionConsumerRemoved>()
        }
        ///Creates a new event filter for the [`SubscriptionCreated`] event.
        pub fn SubscriptionCreated_filter(
            &self,
        ) -> alloy_contract::Event<&P, SubscriptionCreated, N> {
            self.event_filter::<SubscriptionCreated>()
        }
        ///Creates a new event filter for the [`SubscriptionFundedWithNative`] event.
        pub fn SubscriptionFundedWithNative_filter(
            &self,
        ) -> alloy_contract::Event<&P, SubscriptionFundedWithNative, N> {
            self.event_filter::<SubscriptionFundedWithNative>()
        }
        ///Creates a new event filter for the [`SubscriptionOwnerTransferRequested`] event.
        pub fn SubscriptionOwnerTransferRequested_filter(
            &self,
        ) -> alloy_contract::Event<&P, SubscriptionOwnerTransferRequested, N> {
            self.event_filter::<SubscriptionOwnerTransferRequested>()
        }
        ///Creates a new event filter for the [`SubscriptionOwnerTransferred`] event.
        pub fn SubscriptionOwnerTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, SubscriptionOwnerTransferred, N> {
            self.event_filter::<SubscriptionOwnerTransferred>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
    }
}
