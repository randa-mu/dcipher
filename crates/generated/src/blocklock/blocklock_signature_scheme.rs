/**

Generated by the following Solidity interface...
```solidity
interface BlocklockSignatureScheme {
    error BNAddFailed(uint256[4] input);
    error InvalidDSTLength(bytes dst);
    error InvalidFieldElement(uint256 x);
    error MapToPointFailed(uint256 noSqrt);
    error ModExpFailed(uint256 base, uint256 exponent, uint256 modulus);

    constructor(uint256[2] x, uint256[2] y);

    function DST() external view returns (bytes memory);
    function SCHEME_ID() external view returns (string memory);
    function getChainId() external view returns (uint256 chainId);
    function getPublicKey() external view returns (uint256[2] memory, uint256[2] memory);
    function getPublicKeyBytes() external view returns (bytes memory);
    function hashToBytes(bytes memory message) external view returns (bytes memory);
    function hashToPoint(bytes memory message) external view returns (uint256, uint256);
    function verifySignature(bytes memory message, bytes memory signature, bytes memory publicKey) external view returns (bool isValid);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "x",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      },
      {
        "name": "y",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DST",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SCHEME_ID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getChainId",
    "inputs": [],
    "outputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPublicKey",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      },
      {
        "name": "",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPublicKeyBytes",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hashToBytes",
    "inputs": [
      {
        "name": "message",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hashToPoint",
    "inputs": [
      {
        "name": "message",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "verifySignature",
    "inputs": [
      {
        "name": "message",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "publicKey",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "isValid",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "error",
    "name": "BNAddFailed",
    "inputs": [
      {
        "name": "input",
        "type": "uint256[4]",
        "internalType": "uint256[4]"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidDSTLength",
    "inputs": [
      {
        "name": "dst",
        "type": "bytes",
        "internalType": "bytes"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidFieldElement",
    "inputs": [
      {
        "name": "x",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "MapToPointFailed",
    "inputs": [
      {
        "name": "noSqrt",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ModExpFailed",
    "inputs": [
      {
        "name": "base",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "exponent",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "modulus",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod BlocklockSignatureScheme {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x5f60c081815260e0829052608081815261014060405261010083815261012084905260a052919061003390829060026102cd565b50602082015161004990600280840191906102cd565b505050348015610057575f5ffd5b506040516127b23803806127b28339810160408190526100769161039f565b6040805180820190915282815260208101829052829082905f61009b818560026102cd565b5060208201516100b190600280840191906102cd565b5090505050506100cd6100c861010260201b60201c565b610106565b6040516020016100dd91906103d2565b604051602081830303815290604052600490816100fa91906104b3565b5050506105c5565b4690565b604080518082018252601081526f181899199a1a9b1b9c1cb0b131b232b360811b602082015281516042808252608082019093526060925f9190602082018180368337019050509050600360fc1b815f815181106101665761016661056d565b60200101906001600160f81b03191690815f1a905350600f60fb1b816001815181106101945761019461056d565b60200101906001600160f81b03191690815f1a9053505f5b60208110156102c5578260048683602081106101ca576101ca61056d565b1a60f81b6001600160f81b031916901c60f81c60ff16815181106101f0576101f061056d565b01602001516001600160f81b0319168261020b836002610595565b6102169060026105b2565b815181106102265761022661056d565b60200101906001600160f81b03191690815f1a9053508285826020811061024f5761024f61056d565b825191901a600f169081106102665761026661056d565b01602001516001600160f81b03191682610281836002610595565b61028c9060026105b2565b6102979060016105b2565b815181106102a7576102a761056d565b60200101906001600160f81b03191690815f1a9053506001016101ac565b509392505050565b82600281019282156102fb579160200282015b828111156102fb5782518255916020019190600101906102e0565b5061030792915061030b565b5090565b5b80821115610307575f815560010161030c565b634e487b7160e01b5f52604160045260245ffd5b5f82601f830112610342575f5ffd5b604080519081016001600160401b03811182821017156103645761036461031f565b806040525080604084018581111561037a575f5ffd5b845b8181101561039457805183526020928301920161037c565b509195945050505050565b5f5f608083850312156103b0575f5ffd5b6103ba8484610333565b91506103c98460408501610333565b90509250929050565b7f424c4f434b4c4f434b5f424e32353447315f584d443a4b454343414b2d32353681526b5f535644575f524f5f48315f60a01b60208201525f82518060208501602c85015e605f60f81b602c939091019283015250602d01919050565b600181811c9082168061044357607f821691505b60208210810361046157634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156104ae57805f5260205f20601f840160051c8101602085101561048c5750805b601f840160051c820191505b818110156104ab575f8155600101610498565b50505b505050565b81516001600160401b038111156104cc576104cc61031f565b6104e0816104da845461042f565b84610467565b6020601f821160018114610512575f83156104fb5750848201515b5f19600385901b1c1916600184901b1784556104ab565b5f84815260208120601f198516915b828110156105415787850151825560209485019460019092019101610521565b508482101561055e57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b80820281158282048414176105ac576105ac610581565b92915050565b808201808211156105ac576105ac610581565b6121e0806105d25f395ff3fe608060405234801561000f575f5ffd5b5060043610610085575f3560e01c80638a1f165a116100585780638a1f165a146100f3578063acae9fee14610125578063eae1e15b1461012d578063f6e548e914610140575f5ffd5b80632e334452146100895780633033cc51146100a85780633408e470146100d05780635f7c7522146100de575b5f5ffd5b610091610163565b60405161009f929190611e88565b60405180910390f35b6100bb6100b6366004611ee8565b6101dc565b6040805192835260208301919091520161009f565b60405146815260200161009f565b6100e66102bc565b60405161009f9190611f55565b6100e660405180604001604052806013815260200172424e3235342d424c532d424c4f434b4c4f434b60681b81525081565b6100e6610348565b6100e661013b366004611ee8565b6103c7565b61015361014e366004611f67565b610401565b604051901515815260200161009f565b61016b611de1565b610173611de1565b60408051808201918290525f91600291908390839082845b81548152602001906001019080831161018b575050604080518082019182905294965085935060029250905082845b8154815260200190600101908083116101ba5750505050509050915091509091565b5f5f5f6102a6600480546101ef90612006565b80601f016020809104026020016040519081016040528092919081815260200182805461021b90612006565b80156102665780601f1061023d57610100808354040283529160200191610266565b820191905f5260205f20905b81548152906001019060200180831161024957829003601f168201915b505050505086868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506104e192505050565b80516020909101519093509150505b9250929050565b600480546102c990612006565b80601f01602080910402602001604051908101604052809291908181526020018280546102f590612006565b80156103405780601f1061031757610100808354040283529160200191610340565b820191905f5260205f20905b81548152906001019060200180831161032357829003601f168201915b505050505081565b60408051608081018083526060926103c292915f91839190820190839060029082845b81548152602001906001019080831161036b57505050918352505060408051808201918290526020909201919060028481019182845b8154815260200190600101908083116103a1575050505050815250506105ad565b905090565b60605f5f6103d585856101dc565b915091506103f6604051806040016040528084815260200183815250610609565b925050505b92915050565b5f5f61044188888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061064292505050565b90505f61048287878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061064292505050565b90505f6104c386868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506106c592505050565b90505f6104d1838386610766565b509b9a5050505050505050505050565b604080518082019091525f80825260208201525f6104ff84846108d9565b90505f61051282825b602002015161098e565b90505f610520836001610508565b905061052a611dff565b825181526020808401518282015282516040808401919091529083015160608301525f908460808460066107d05a03fa9050806105855781604051630251c7e160e31b815260040161057c9190612052565b60405180910390fd5b6040805180820190915284518152602081018560016020020151905298975050505050505050565b60408051608080825260a082019092526060915f91906020820181803683375050845180516020918201519682015180519083015192850191909152604084019690965260608301959095525060808101939093525090919050565b6040805181815260608181018352915f919060208201818036833750508451602095860151958301525060408101939093525090919050565b604080518082019091525f808252602082015281516040146106a65760405162461bcd60e51b815260206004820152601760248201527f496e76616c6964204731206279746573206c656e677468000000000000000000604482015260640161057c565b5060208181015160409283015183518085019094529083529082015290565b6106cd611e1d565b815160801461071e5760405162461bcd60e51b815260206004820152601760248201527f496e76616c6964204732206279746573206c656e677468000000000000000000604482015260640161057c565b50602081810151604080840151606080860151608096870151845197880185528785019586529187019290925292855281518083019092528152808301919091529082015290565b5f5f5f604051806101800160405280875f01518152602001876020015181526020017f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec81526020017f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d8152602001855f0151815260200185602001518152602001865f01516001600281106108495761084961203e565b60200201518152602001865f01515f600281106108685761086861203e565b6020020151815260200186602001516001600281106108895761088961203e565b6020020151815260200186602001515f600281106108a9576108a961203e565b6020020151905290506108ba611e42565b6020816101808460086107d05a03fa9051151597909650945050505050565b6108e1611de1565b5f6108ec8484610c6f565b90505f5f5f5f601885016001600160c01b0381511693506030860190506001600160c01b0381511694505f5160206121a05f395f51905f52855f5160206121a05f395f51905f52600160c01b870908604887015160608801516001600160c01b03908116975016945092505f5160206121a05f395f51905f5290508481600160c01b860908604080518082019091529283526020830152509695505050505050565b610996611de1565b5f5160206121a05f395f51905f5282106109c65760405163d53e941560e01b81526004810183905260240161057c565b5f5f5160206121a05f395f51905f5260045f5160206121a05f395f51905f528586090990505f5f5160206121a05f395f51905f528260010890505f5160206121a05f395f51905f52610a25835f5160206121a05f395f51905f52612096565b60010891505f610a445f5160206121a05f395f51905f52838509610dc6565b90505f5f5160206121a05f395f51905f5278016789af3a83522eb353c98fc6b36d713d5d8d1cc5dffffffa5f5160206121a05f395f51905f52845f5160206121a05f395f51905f52888b09090990505f5f5160206121a05f395f51905f52610ab9835f5160206121a05f395f51905f52612096565b5f5160206121c05f395f51905f520890505f5f5160206121a05f395f51905f52835f5160206121c05f395f51905f520890505f5f5160206121a05f395f51905f5286870990505f5f5160206121a05f395f51905f5286830990505f5f5160206121a05f395f51905f52805f5160206121a05f395f51905f528485097f10216f7ba065e00de81ac1e7808072c9dd2b2385cd7b438469602eb24829a9bd0960010890505f5f610b6e610b6988610dd0565b610e09565b5f0b600103610bbe57868c52610b8387610dd0565b9050610b8e81610e6e565b60208e0191909152915081610bb95760405163396ec77160e01b81526004810182905260240161057c565b610c21565b610bca610b6987610dd0565b5f0b600103610bdf57858c52610b8386610dd0565b828c52610beb83610dd0565b9050610bf681610e6e565b60208e0191909152915081610c215760405163396ec77160e01b81526004810182905260240161057c565b60208c0151610c2f90610e95565b610c388e610e95565b14610c5f5760208c0151610c59905f5160206121a05f395f51905f52612096565b60208d01525b5050505050505050505050919050565b815160609060ff811115610c9857836040516313727cdd60e11b815260040161057c9190611f55565b60408051608880825260c082019092525f916020820181803683370190505090505f81855f60605f8a88604051602001610cd897969594939291906120c0565b60405160208183030381529060405290505f818051906020012090505f8160018987604051602001610d0d949392919061212a565b60408051808303601f1901815282825280516020820120606080855260808501909352909350915f91602082018180368337019050509050600360015b81811015610da957858418610d6082600161216d565b8d8b604051602001610d75949392919061212a565b60408051808303601f1901815291905260205f19830181028501810195909552805194810194909420939450600101610d4a565b505f19016020908102820101919091529550505050505092915050565b5f6103fb82610ea1565b5f5f5160206121a05f395f51905f5260035f5160206121a05f395f51905f52845f5160206121a05f395f51905f52868709090892915050565b5f5f610e14836115e6565b9050610e2e60015f5160206121a05f395f51905f52612096565b8103610e3d57505f1992915050565b8015801590610e4d575080600114155b156103fb5760405163396ec77160e01b81526004810184905260240161057c565b5f5f610e79836116ae565b9150825f5160206121a05f395f51905f52838409149050915091565b5f6103fb600283612180565b5f5f5160206121a05f395f51905f528083840991508083830981838209828283098385830984848309858484098684850997508684840987858409945087898a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087838a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985050868889099750868889099750868889099750868889099750868889099750868889099750868489099750868889099750868889099750868889099750868889099750868889099750868989099750868889099750868889099750868889099750868889099750868889099750868889099750868989099750868889099750868889099750868889099750868889099750868889099750868689099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868189099750508587880996508587880996508587880996508585880996508587880996508587880996508587880996508585880996508587880996508587880996508587880996508587880996508587880996508587880996508587880996508587880996508583880996508587880996508587880996508587880996508587880996508581880996505050838586099450838586099450838586099450838586099450838186099450508284850993508284850993508284850993508281850993508284850993508284850993508285850993508284850993508284850993508284850993508284850993508284850993508284850993508281850995945050505050565b6040805160c080825260e082019092525f918291906020820181803683370190505060208082018181526040830182905260608301829052608083018690525f5160206121c05f395f51905f5260a08401525f5160206121a05f395f51905f5260c0808501919091529293505f92839160055afa90505f519250806116a75760405163c6daf7ab60e01b8152600481018590525f5160206121c05f395f51905f5260248201525f5160206121a05f395f51905f52604482015260640161057c565b5050919050565b5f5f5160206121a05f395f51905f528083840991508083830981838209828283098385830984848309858484098684850997508684840987858409945087898a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087838a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985050868889099750868889099750868889099750868889099750868889099750868889099750868489099750868889099750868889099750868889099750868889099750868889099750868989099750868889099750868889099750868889099750868889099750868889099750868889099750868989099750868889099750868889099750868889099750868889099750868889099750868689099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868189099750508587880996508587880996508587880996508585880996508587880996508587880996508587880996508585880996508587880996508587880996508587880996508587880996508587880996508587880996508587880996508587880996508583880996508587880996508587880996508587880996508587880996508581880996508587880996508587880996508587880996508587880996508583880996508587880996508587880996508587880996508584880996508587880996508587880996508587880996508587880996508587880996508581880996505050505050808283099392505050565b60405180604001604052806002906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b6040518060400160405280611e30611de1565b8152602001611e3d611de1565b905290565b60405180602001604052806001906020820280368337509192915050565b805f5b6002811015611e82578151845260209384019390910190600101611e63565b50505050565b60808101611e968285611e60565b611ea36040830184611e60565b9392505050565b5f5f83601f840112611eba575f5ffd5b50813567ffffffffffffffff811115611ed1575f5ffd5b6020830191508360208285010111156102b5575f5ffd5b5f5f60208385031215611ef9575f5ffd5b823567ffffffffffffffff811115611f0f575f5ffd5b611f1b85828601611eaa565b90969095509350505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f611ea36020830184611f27565b5f5f5f5f5f5f60608789031215611f7c575f5ffd5b863567ffffffffffffffff811115611f92575f5ffd5b611f9e89828a01611eaa565b909750955050602087013567ffffffffffffffff811115611fbd575f5ffd5b611fc989828a01611eaa565b909550935050604087013567ffffffffffffffff811115611fe8575f5ffd5b611ff489828a01611eaa565b979a9699509497509295939492505050565b600181811c9082168061201a57607f821691505b60208210810361203857634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b6080810181835f5b600481101561207957815183526020928301929091019060010161205a565b50505092915050565b634e487b7160e01b5f52601160045260245ffd5b818103818111156103fb576103fb612082565b5f81518060208401855e5f93019283525090919050565b5f6120d46120ce838b6120a9565b896120a9565b6001600160f81b031960f889811b8216835288811b8216600184015287901b16600282015261210660038201866120a9565b60f89490941b6001600160f81b031916845250506001909101979650505050505050565b84815260f884901b6001600160f81b03191660208201525f61214f60218301856120a9565b60f89390931b6001600160f81b031916835250506001019392505050565b808201808211156103fb576103fb612082565b5f8261219a57634e487b7160e01b5f52601260045260245ffd5b50069056fe30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea3
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"_`\xC0\x81\x81R`\xE0\x82\x90R`\x80\x81\x81Ra\x01@`@Ra\x01\0\x83\x81Ra\x01 \x84\x90R`\xA0R\x91\x90a\x003\x90\x82\x90`\x02a\x02\xCDV[P` \x82\x01Qa\0I\x90`\x02\x80\x84\x01\x91\x90a\x02\xCDV[PPP4\x80\x15a\0WW__\xFD[P`@Qa'\xB28\x03\x80a'\xB2\x839\x81\x01`@\x81\x90Ra\0v\x91a\x03\x9FV[`@\x80Q\x80\x82\x01\x90\x91R\x82\x81R` \x81\x01\x82\x90R\x82\x90\x82\x90_a\0\x9B\x81\x85`\x02a\x02\xCDV[P` \x82\x01Qa\0\xB1\x90`\x02\x80\x84\x01\x91\x90a\x02\xCDV[P\x90PPPPa\0\xCDa\0\xC8a\x01\x02` \x1B` \x1CV[a\x01\x06V[`@Q` \x01a\0\xDD\x91\x90a\x03\xD2V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\x04\x90\x81a\0\xFA\x91\x90a\x04\xB3V[PPPa\x05\xC5V[F\x90V[`@\x80Q\x80\x82\x01\x82R`\x10\x81Ro\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B` \x82\x01R\x81Q`B\x80\x82R`\x80\x82\x01\x90\x93R``\x92_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P`\x03`\xFC\x1B\x81_\x81Q\x81\x10a\x01fWa\x01fa\x05mV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a\x01\x94Wa\x01\x94a\x05mV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP_[` \x81\x10\x15a\x02\xC5W\x82`\x04\x86\x83` \x81\x10a\x01\xCAWa\x01\xCAa\x05mV[\x1A`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x1C`\xF8\x1C`\xFF\x16\x81Q\x81\x10a\x01\xF0Wa\x01\xF0a\x05mV[\x01` \x01Q`\x01`\x01`\xF8\x1B\x03\x19\x16\x82a\x02\x0B\x83`\x02a\x05\x95V[a\x02\x16\x90`\x02a\x05\xB2V[\x81Q\x81\x10a\x02&Wa\x02&a\x05mV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP\x82\x85\x82` \x81\x10a\x02OWa\x02Oa\x05mV[\x82Q\x91\x90\x1A`\x0F\x16\x90\x81\x10a\x02fWa\x02fa\x05mV[\x01` \x01Q`\x01`\x01`\xF8\x1B\x03\x19\x16\x82a\x02\x81\x83`\x02a\x05\x95V[a\x02\x8C\x90`\x02a\x05\xB2V[a\x02\x97\x90`\x01a\x05\xB2V[\x81Q\x81\x10a\x02\xA7Wa\x02\xA7a\x05mV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x01\x01a\x01\xACV[P\x93\x92PPPV[\x82`\x02\x81\x01\x92\x82\x15a\x02\xFBW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x02\xFBW\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90a\x02\xE0V[Pa\x03\x07\x92\x91Pa\x03\x0BV[P\x90V[[\x80\x82\x11\x15a\x03\x07W_\x81U`\x01\x01a\x03\x0CV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\x03BW__\xFD[`@\x80Q\x90\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x03dWa\x03da\x03\x1FV[\x80`@RP\x80`@\x84\x01\x85\x81\x11\x15a\x03zW__\xFD[\x84[\x81\x81\x10\x15a\x03\x94W\x80Q\x83R` \x92\x83\x01\x92\x01a\x03|V[P\x91\x95\x94PPPPPV[__`\x80\x83\x85\x03\x12\x15a\x03\xB0W__\xFD[a\x03\xBA\x84\x84a\x033V[\x91Pa\x03\xC9\x84`@\x85\x01a\x033V[\x90P\x92P\x92\x90PV[\x7FBLOCKLOCK_BN254G1_XMD:KECCAK-256\x81Rk_SVDW_RO_H1_`\xA0\x1B` \x82\x01R_\x82Q\x80` \x85\x01`,\x85\x01^`_`\xF8\x1B`,\x93\x90\x91\x01\x92\x83\x01RP`-\x01\x91\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x04CW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x04aWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x1F\x82\x11\x15a\x04\xAEW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x04\x8CWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x04\xABW_\x81U`\x01\x01a\x04\x98V[PP[PPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x04\xCCWa\x04\xCCa\x03\x1FV[a\x04\xE0\x81a\x04\xDA\x84Ta\x04/V[\x84a\x04gV[` `\x1F\x82\x11`\x01\x81\x14a\x05\x12W_\x83\x15a\x04\xFBWP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x04\xABV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a\x05AW\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\x05!V[P\x84\x82\x10\x15a\x05^W\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x05\xACWa\x05\xACa\x05\x81V[\x92\x91PPV[\x80\x82\x01\x80\x82\x11\x15a\x05\xACWa\x05\xACa\x05\x81V[a!\xE0\x80a\x05\xD2_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\x85W_5`\xE0\x1C\x80c\x8A\x1F\x16Z\x11a\0XW\x80c\x8A\x1F\x16Z\x14a\0\xF3W\x80c\xAC\xAE\x9F\xEE\x14a\x01%W\x80c\xEA\xE1\xE1[\x14a\x01-W\x80c\xF6\xE5H\xE9\x14a\x01@W__\xFD[\x80c.3DR\x14a\0\x89W\x80c03\xCCQ\x14a\0\xA8W\x80c4\x08\xE4p\x14a\0\xD0W\x80c_|u\"\x14a\0\xDEW[__\xFD[a\0\x91a\x01cV[`@Qa\0\x9F\x92\x91\x90a\x1E\x88V[`@Q\x80\x91\x03\x90\xF3[a\0\xBBa\0\xB66`\x04a\x1E\xE8V[a\x01\xDCV[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\0\x9FV[`@QF\x81R` \x01a\0\x9FV[a\0\xE6a\x02\xBCV[`@Qa\0\x9F\x91\x90a\x1FUV[a\0\xE6`@Q\x80`@\x01`@R\x80`\x13\x81R` \x01rBN254-BLS-BLOCKLOCK`h\x1B\x81RP\x81V[a\0\xE6a\x03HV[a\0\xE6a\x01;6`\x04a\x1E\xE8V[a\x03\xC7V[a\x01Sa\x01N6`\x04a\x1FgV[a\x04\x01V[`@Q\x90\x15\x15\x81R` \x01a\0\x9FV[a\x01ka\x1D\xE1V[a\x01sa\x1D\xE1V[`@\x80Q\x80\x82\x01\x91\x82\x90R_\x91`\x02\x91\x90\x83\x90\x83\x90\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x01\x8BWPP`@\x80Q\x80\x82\x01\x91\x82\x90R\x94\x96P\x85\x93P`\x02\x92P\x90P\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x01\xBAWPPPPP\x90P\x91P\x91P\x90\x91V[___a\x02\xA6`\x04\x80Ta\x01\xEF\x90a \x06V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x02\x1B\x90a \x06V[\x80\x15a\x02fW\x80`\x1F\x10a\x02=Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x02fV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x02IW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x04\xE1\x92PPPV[\x80Q` \x90\x91\x01Q\x90\x93P\x91PP[\x92P\x92\x90PV[`\x04\x80Ta\x02\xC9\x90a \x06V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x02\xF5\x90a \x06V[\x80\x15a\x03@W\x80`\x1F\x10a\x03\x17Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x03@V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x03#W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[`@\x80Q`\x80\x81\x01\x80\x83R``\x92a\x03\xC2\x92\x91_\x91\x83\x91\x90\x82\x01\x90\x83\x90`\x02\x90\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x03kWPPP\x91\x83RPP`@\x80Q\x80\x82\x01\x91\x82\x90R` \x90\x92\x01\x91\x90`\x02\x84\x81\x01\x91\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x03\xA1WPPPPP\x81RPPa\x05\xADV[\x90P\x90V[``__a\x03\xD5\x85\x85a\x01\xDCV[\x91P\x91Pa\x03\xF6`@Q\x80`@\x01`@R\x80\x84\x81R` \x01\x83\x81RPa\x06\tV[\x92PPP[\x92\x91PPV[__a\x04A\x88\x88\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x06B\x92PPPV[\x90P_a\x04\x82\x87\x87\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x06B\x92PPPV[\x90P_a\x04\xC3\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x06\xC5\x92PPPV[\x90P_a\x04\xD1\x83\x83\x86a\x07fV[P\x9B\x9APPPPPPPPPPPV[`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01R_a\x04\xFF\x84\x84a\x08\xD9V[\x90P_a\x05\x12\x82\x82[` \x02\x01Qa\t\x8EV[\x90P_a\x05 \x83`\x01a\x05\x08V[\x90Pa\x05*a\x1D\xFFV[\x82Q\x81R` \x80\x84\x01Q\x82\x82\x01R\x82Q`@\x80\x84\x01\x91\x90\x91R\x90\x83\x01Q``\x83\x01R_\x90\x84`\x80\x84`\x06a\x07\xD0Z\x03\xFA\x90P\x80a\x05\x85W\x81`@Qc\x02Q\xC7\xE1`\xE3\x1B\x81R`\x04\x01a\x05|\x91\x90a RV[`@Q\x80\x91\x03\x90\xFD[`@\x80Q\x80\x82\x01\x90\x91R\x84Q\x81R` \x81\x01\x85`\x01` \x02\x01Q\x90R\x98\x97PPPPPPPPV[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R``\x91_\x91\x90` \x82\x01\x81\x806\x837PP\x84Q\x80Q` \x91\x82\x01Q\x96\x82\x01Q\x80Q\x90\x83\x01Q\x92\x85\x01\x91\x90\x91R`@\x84\x01\x96\x90\x96R``\x83\x01\x95\x90\x95RP`\x80\x81\x01\x93\x90\x93RP\x90\x91\x90PV[`@\x80Q\x81\x81R``\x81\x81\x01\x83R\x91_\x91\x90` \x82\x01\x81\x806\x837PP\x84Q` \x95\x86\x01Q\x95\x83\x01RP`@\x81\x01\x93\x90\x93RP\x90\x91\x90PV[`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01R\x81Q`@\x14a\x06\xA6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid G1 bytes length\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05|V[P` \x81\x81\x01Q`@\x92\x83\x01Q\x83Q\x80\x85\x01\x90\x94R\x90\x83R\x90\x82\x01R\x90V[a\x06\xCDa\x1E\x1DV[\x81Q`\x80\x14a\x07\x1EW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid G2 bytes length\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05|V[P` \x81\x81\x01Q`@\x80\x84\x01Q``\x80\x86\x01Q`\x80\x96\x87\x01Q\x84Q\x97\x88\x01\x85R\x87\x85\x01\x95\x86R\x91\x87\x01\x92\x90\x92R\x92\x85R\x81Q\x80\x83\x01\x90\x92R\x81R\x80\x83\x01\x91\x90\x91R\x90\x82\x01R\x90V[___`@Q\x80a\x01\x80\x01`@R\x80\x87_\x01Q\x81R` \x01\x87` \x01Q\x81R` \x01\x7F\x19\x8E\x93\x93\x92\rH:r`\xBF\xB71\xFB]%\xF1\xAAI35\xA9\xE7\x12\x97\xE4\x85\xB7\xAE\xF3\x12\xC2\x81R` \x01\x7F\x18\0\xDE\xEF\x12\x1F\x1EvBj\0f^\\DygC\"\xD4\xF7^\xDA\xDDF\xDE\xBD\\\xD9\x92\xF6\xED\x81R` \x01\x7F']\xC4\xA2\x88\xD1\xAF\xB3\xCB\xB1\xAC\t\x18u$\xC7\xDB69]\xF7\xBE;\x99\xE6s\xB1:\x07Ze\xEC\x81R` \x01\x7F\x1D\x9B\xEF\xCD\x05\xA52>m\xA4\xD45\xF3\xB6\x17\xCD\xB3\xAF\x83(\\-\xF7\x11\xEF9\xC0\x15q\x82\x7F\x9D\x81R` \x01\x85_\x01Q\x81R` \x01\x85` \x01Q\x81R` \x01\x86_\x01Q`\x01`\x02\x81\x10a\x08IWa\x08Ia >V[` \x02\x01Q\x81R` \x01\x86_\x01Q_`\x02\x81\x10a\x08hWa\x08ha >V[` \x02\x01Q\x81R` \x01\x86` \x01Q`\x01`\x02\x81\x10a\x08\x89Wa\x08\x89a >V[` \x02\x01Q\x81R` \x01\x86` \x01Q_`\x02\x81\x10a\x08\xA9Wa\x08\xA9a >V[` \x02\x01Q\x90R\x90Pa\x08\xBAa\x1EBV[` \x81a\x01\x80\x84`\x08a\x07\xD0Z\x03\xFA\x90Q\x15\x15\x97\x90\x96P\x94PPPPPV[a\x08\xE1a\x1D\xE1V[_a\x08\xEC\x84\x84a\x0CoV[\x90P____`\x18\x85\x01`\x01`\x01`\xC0\x1B\x03\x81Q\x16\x93P`0\x86\x01\x90P`\x01`\x01`\xC0\x1B\x03\x81Q\x16\x94P_Q` a!\xA0_9_Q\x90_R\x85_Q` a!\xA0_9_Q\x90_R`\x01`\xC0\x1B\x87\t\x08`H\x87\x01Q``\x88\x01Q`\x01`\x01`\xC0\x1B\x03\x90\x81\x16\x97P\x16\x94P\x92P_Q` a!\xA0_9_Q\x90_R\x90P\x84\x81`\x01`\xC0\x1B\x86\t\x08`@\x80Q\x80\x82\x01\x90\x91R\x92\x83R` \x83\x01RP\x96\x95PPPPPPV[a\t\x96a\x1D\xE1V[_Q` a!\xA0_9_Q\x90_R\x82\x10a\t\xC6W`@Qc\xD5>\x94\x15`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x05|V[__Q` a!\xA0_9_Q\x90_R`\x04_Q` a!\xA0_9_Q\x90_R\x85\x86\t\t\x90P__Q` a!\xA0_9_Q\x90_R\x82`\x01\x08\x90P_Q` a!\xA0_9_Q\x90_Ra\n%\x83_Q` a!\xA0_9_Q\x90_Ra \x96V[`\x01\x08\x91P_a\nD_Q` a!\xA0_9_Q\x90_R\x83\x85\ta\r\xC6V[\x90P__Q` a!\xA0_9_Q\x90_Rx\x01g\x89\xAF:\x83R.\xB3S\xC9\x8F\xC6\xB3mq=]\x8D\x1C\xC5\xDF\xFF\xFF\xFA_Q` a!\xA0_9_Q\x90_R\x84_Q` a!\xA0_9_Q\x90_R\x88\x8B\t\t\t\x90P__Q` a!\xA0_9_Q\x90_Ra\n\xB9\x83_Q` a!\xA0_9_Q\x90_Ra \x96V[_Q` a!\xC0_9_Q\x90_R\x08\x90P__Q` a!\xA0_9_Q\x90_R\x83_Q` a!\xC0_9_Q\x90_R\x08\x90P__Q` a!\xA0_9_Q\x90_R\x86\x87\t\x90P__Q` a!\xA0_9_Q\x90_R\x86\x83\t\x90P__Q` a!\xA0_9_Q\x90_R\x80_Q` a!\xA0_9_Q\x90_R\x84\x85\t\x7F\x10!o{\xA0e\xE0\r\xE8\x1A\xC1\xE7\x80\x80r\xC9\xDD+#\x85\xCD{C\x84i`.\xB2H)\xA9\xBD\t`\x01\x08\x90P__a\x0Bna\x0Bi\x88a\r\xD0V[a\x0E\tV[_\x0B`\x01\x03a\x0B\xBEW\x86\x8CRa\x0B\x83\x87a\r\xD0V[\x90Pa\x0B\x8E\x81a\x0EnV[` \x8E\x01\x91\x90\x91R\x91P\x81a\x0B\xB9W`@Qc9n\xC7q`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x05|V[a\x0C!V[a\x0B\xCAa\x0Bi\x87a\r\xD0V[_\x0B`\x01\x03a\x0B\xDFW\x85\x8CRa\x0B\x83\x86a\r\xD0V[\x82\x8CRa\x0B\xEB\x83a\r\xD0V[\x90Pa\x0B\xF6\x81a\x0EnV[` \x8E\x01\x91\x90\x91R\x91P\x81a\x0C!W`@Qc9n\xC7q`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x05|V[` \x8C\x01Qa\x0C/\x90a\x0E\x95V[a\x0C8\x8Ea\x0E\x95V[\x14a\x0C_W` \x8C\x01Qa\x0CY\x90_Q` a!\xA0_9_Q\x90_Ra \x96V[` \x8D\x01R[PPPPPPPPPPP\x91\x90PV[\x81Q``\x90`\xFF\x81\x11\x15a\x0C\x98W\x83`@Qc\x13r|\xDD`\xE1\x1B\x81R`\x04\x01a\x05|\x91\x90a\x1FUV[`@\x80Q`\x88\x80\x82R`\xC0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_\x81\x85_``_\x8A\x88`@Q` \x01a\x0C\xD8\x97\x96\x95\x94\x93\x92\x91\x90a \xC0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P_\x81\x80Q\x90` \x01 \x90P_\x81`\x01\x89\x87`@Q` \x01a\r\r\x94\x93\x92\x91\x90a!*V[`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x82\x82R\x80Q` \x82\x01 ``\x80\x85R`\x80\x85\x01\x90\x93R\x90\x93P\x91_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P`\x03`\x01[\x81\x81\x10\x15a\r\xA9W\x85\x84\x18a\r`\x82`\x01a!mV[\x8D\x8B`@Q` \x01a\ru\x94\x93\x92\x91\x90a!*V[`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x91\x90R` _\x19\x83\x01\x81\x02\x85\x01\x81\x01\x95\x90\x95R\x80Q\x94\x81\x01\x94\x90\x94 \x93\x94P`\x01\x01a\rJV[P_\x19\x01` \x90\x81\x02\x82\x01\x01\x91\x90\x91R\x95PPPPPP\x92\x91PPV[_a\x03\xFB\x82a\x0E\xA1V[__Q` a!\xA0_9_Q\x90_R`\x03_Q` a!\xA0_9_Q\x90_R\x84_Q` a!\xA0_9_Q\x90_R\x86\x87\t\t\x08\x92\x91PPV[__a\x0E\x14\x83a\x15\xE6V[\x90Pa\x0E.`\x01_Q` a!\xA0_9_Q\x90_Ra \x96V[\x81\x03a\x0E=WP_\x19\x92\x91PPV[\x80\x15\x80\x15\x90a\x0EMWP\x80`\x01\x14\x15[\x15a\x03\xFBW`@Qc9n\xC7q`\xE0\x1B\x81R`\x04\x81\x01\x84\x90R`$\x01a\x05|V[__a\x0Ey\x83a\x16\xAEV[\x91P\x82_Q` a!\xA0_9_Q\x90_R\x83\x84\t\x14\x90P\x91P\x91V[_a\x03\xFB`\x02\x83a!\x80V[__Q` a!\xA0_9_Q\x90_R\x80\x83\x84\t\x91P\x80\x83\x83\t\x81\x83\x82\t\x82\x82\x83\t\x83\x85\x83\t\x84\x84\x83\t\x85\x84\x84\t\x86\x84\x85\t\x97P\x86\x84\x84\t\x87\x85\x84\t\x94P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x83\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98PP\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x84\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x89\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x89\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x86\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x81\x89\t\x97PP\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x85\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x85\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x83\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x81\x88\t\x96PPP\x83\x85\x86\t\x94P\x83\x85\x86\t\x94P\x83\x85\x86\t\x94P\x83\x85\x86\t\x94P\x83\x81\x86\t\x94PP\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x81\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x85\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x81\x85\t\x95\x94PPPPPV[`@\x80Q`\xC0\x80\x82R`\xE0\x82\x01\x90\x92R_\x91\x82\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP` \x80\x82\x01\x81\x81R`@\x83\x01\x82\x90R``\x83\x01\x82\x90R`\x80\x83\x01\x86\x90R_Q` a!\xC0_9_Q\x90_R`\xA0\x84\x01R_Q` a!\xA0_9_Q\x90_R`\xC0\x80\x85\x01\x91\x90\x91R\x92\x93P_\x92\x83\x91`\x05Z\xFA\x90P_Q\x92P\x80a\x16\xA7W`@Qc\xC6\xDA\xF7\xAB`\xE0\x1B\x81R`\x04\x81\x01\x85\x90R_Q` a!\xC0_9_Q\x90_R`$\x82\x01R_Q` a!\xA0_9_Q\x90_R`D\x82\x01R`d\x01a\x05|V[PP\x91\x90PV[__Q` a!\xA0_9_Q\x90_R\x80\x83\x84\t\x91P\x80\x83\x83\t\x81\x83\x82\t\x82\x82\x83\t\x83\x85\x83\t\x84\x84\x83\t\x85\x84\x84\t\x86\x84\x85\t\x97P\x86\x84\x84\t\x87\x85\x84\t\x94P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x83\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98PP\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x84\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x89\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x89\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x86\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x81\x89\t\x97PP\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x85\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x85\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x83\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x81\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x83\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x84\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x81\x88\t\x96PPPPPP\x80\x82\x83\t\x93\x92PPPV[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`\x80\x01`@R\x80`\x04\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`@\x01`@R\x80a\x1E0a\x1D\xE1V[\x81R` \x01a\x1E=a\x1D\xE1V[\x90R\x90V[`@Q\x80` \x01`@R\x80`\x01\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[\x80_[`\x02\x81\x10\x15a\x1E\x82W\x81Q\x84R` \x93\x84\x01\x93\x90\x91\x01\x90`\x01\x01a\x1EcV[PPPPV[`\x80\x81\x01a\x1E\x96\x82\x85a\x1E`V[a\x1E\xA3`@\x83\x01\x84a\x1E`V[\x93\x92PPPV[__\x83`\x1F\x84\x01\x12a\x1E\xBAW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1E\xD1W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x02\xB5W__\xFD[__` \x83\x85\x03\x12\x15a\x1E\xF9W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\x0FW__\xFD[a\x1F\x1B\x85\x82\x86\x01a\x1E\xAAV[\x90\x96\x90\x95P\x93PPPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x1E\xA3` \x83\x01\x84a\x1F'V[______``\x87\x89\x03\x12\x15a\x1F|W__\xFD[\x865g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\x92W__\xFD[a\x1F\x9E\x89\x82\x8A\x01a\x1E\xAAV[\x90\x97P\x95PP` \x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xBDW__\xFD[a\x1F\xC9\x89\x82\x8A\x01a\x1E\xAAV[\x90\x95P\x93PP`@\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xE8W__\xFD[a\x1F\xF4\x89\x82\x8A\x01a\x1E\xAAV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a \x1AW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a 8WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[`\x80\x81\x01\x81\x83_[`\x04\x81\x10\x15a yW\x81Q\x83R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a ZV[PPP\x92\x91PPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x03\xFBWa\x03\xFBa \x82V[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a \xD4a \xCE\x83\x8Ba \xA9V[\x89a \xA9V[`\x01`\x01`\xF8\x1B\x03\x19`\xF8\x89\x81\x1B\x82\x16\x83R\x88\x81\x1B\x82\x16`\x01\x84\x01R\x87\x90\x1B\x16`\x02\x82\x01Ra!\x06`\x03\x82\x01\x86a \xA9V[`\xF8\x94\x90\x94\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x84RPP`\x01\x90\x91\x01\x97\x96PPPPPPPV[\x84\x81R`\xF8\x84\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x82\x01R_a!O`!\x83\x01\x85a \xA9V[`\xF8\x93\x90\x93\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x83RPP`\x01\x01\x93\x92PPPV[\x80\x82\x01\x80\x82\x11\x15a\x03\xFBWa\x03\xFBa \x82V[_\x82a!\x9AWcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[P\x06\x90V\xFE0dNr\xE11\xA0)\xB8PE\xB6\x81\x81X]\x97\x81j\x91hq\xCA\x8D< \x8C\x16\xD8|\xFDG\x182'9p\x98\xD0\x14\xDC(\"\xDB@\xC0\xAC.\xCB\xC0\xB5H\xB48\xE5F\x9E\x10F\x0Bl>~\xA3",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610085575f3560e01c80638a1f165a116100585780638a1f165a146100f3578063acae9fee14610125578063eae1e15b1461012d578063f6e548e914610140575f5ffd5b80632e334452146100895780633033cc51146100a85780633408e470146100d05780635f7c7522146100de575b5f5ffd5b610091610163565b60405161009f929190611e88565b60405180910390f35b6100bb6100b6366004611ee8565b6101dc565b6040805192835260208301919091520161009f565b60405146815260200161009f565b6100e66102bc565b60405161009f9190611f55565b6100e660405180604001604052806013815260200172424e3235342d424c532d424c4f434b4c4f434b60681b81525081565b6100e6610348565b6100e661013b366004611ee8565b6103c7565b61015361014e366004611f67565b610401565b604051901515815260200161009f565b61016b611de1565b610173611de1565b60408051808201918290525f91600291908390839082845b81548152602001906001019080831161018b575050604080518082019182905294965085935060029250905082845b8154815260200190600101908083116101ba5750505050509050915091509091565b5f5f5f6102a6600480546101ef90612006565b80601f016020809104026020016040519081016040528092919081815260200182805461021b90612006565b80156102665780601f1061023d57610100808354040283529160200191610266565b820191905f5260205f20905b81548152906001019060200180831161024957829003601f168201915b505050505086868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506104e192505050565b80516020909101519093509150505b9250929050565b600480546102c990612006565b80601f01602080910402602001604051908101604052809291908181526020018280546102f590612006565b80156103405780601f1061031757610100808354040283529160200191610340565b820191905f5260205f20905b81548152906001019060200180831161032357829003601f168201915b505050505081565b60408051608081018083526060926103c292915f91839190820190839060029082845b81548152602001906001019080831161036b57505050918352505060408051808201918290526020909201919060028481019182845b8154815260200190600101908083116103a1575050505050815250506105ad565b905090565b60605f5f6103d585856101dc565b915091506103f6604051806040016040528084815260200183815250610609565b925050505b92915050565b5f5f61044188888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061064292505050565b90505f61048287878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061064292505050565b90505f6104c386868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506106c592505050565b90505f6104d1838386610766565b509b9a5050505050505050505050565b604080518082019091525f80825260208201525f6104ff84846108d9565b90505f61051282825b602002015161098e565b90505f610520836001610508565b905061052a611dff565b825181526020808401518282015282516040808401919091529083015160608301525f908460808460066107d05a03fa9050806105855781604051630251c7e160e31b815260040161057c9190612052565b60405180910390fd5b6040805180820190915284518152602081018560016020020151905298975050505050505050565b60408051608080825260a082019092526060915f91906020820181803683375050845180516020918201519682015180519083015192850191909152604084019690965260608301959095525060808101939093525090919050565b6040805181815260608181018352915f919060208201818036833750508451602095860151958301525060408101939093525090919050565b604080518082019091525f808252602082015281516040146106a65760405162461bcd60e51b815260206004820152601760248201527f496e76616c6964204731206279746573206c656e677468000000000000000000604482015260640161057c565b5060208181015160409283015183518085019094529083529082015290565b6106cd611e1d565b815160801461071e5760405162461bcd60e51b815260206004820152601760248201527f496e76616c6964204732206279746573206c656e677468000000000000000000604482015260640161057c565b50602081810151604080840151606080860151608096870151845197880185528785019586529187019290925292855281518083019092528152808301919091529082015290565b5f5f5f604051806101800160405280875f01518152602001876020015181526020017f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec81526020017f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d8152602001855f0151815260200185602001518152602001865f01516001600281106108495761084961203e565b60200201518152602001865f01515f600281106108685761086861203e565b6020020151815260200186602001516001600281106108895761088961203e565b6020020151815260200186602001515f600281106108a9576108a961203e565b6020020151905290506108ba611e42565b6020816101808460086107d05a03fa9051151597909650945050505050565b6108e1611de1565b5f6108ec8484610c6f565b90505f5f5f5f601885016001600160c01b0381511693506030860190506001600160c01b0381511694505f5160206121a05f395f51905f52855f5160206121a05f395f51905f52600160c01b870908604887015160608801516001600160c01b03908116975016945092505f5160206121a05f395f51905f5290508481600160c01b860908604080518082019091529283526020830152509695505050505050565b610996611de1565b5f5160206121a05f395f51905f5282106109c65760405163d53e941560e01b81526004810183905260240161057c565b5f5f5160206121a05f395f51905f5260045f5160206121a05f395f51905f528586090990505f5f5160206121a05f395f51905f528260010890505f5160206121a05f395f51905f52610a25835f5160206121a05f395f51905f52612096565b60010891505f610a445f5160206121a05f395f51905f52838509610dc6565b90505f5f5160206121a05f395f51905f5278016789af3a83522eb353c98fc6b36d713d5d8d1cc5dffffffa5f5160206121a05f395f51905f52845f5160206121a05f395f51905f52888b09090990505f5f5160206121a05f395f51905f52610ab9835f5160206121a05f395f51905f52612096565b5f5160206121c05f395f51905f520890505f5f5160206121a05f395f51905f52835f5160206121c05f395f51905f520890505f5f5160206121a05f395f51905f5286870990505f5f5160206121a05f395f51905f5286830990505f5f5160206121a05f395f51905f52805f5160206121a05f395f51905f528485097f10216f7ba065e00de81ac1e7808072c9dd2b2385cd7b438469602eb24829a9bd0960010890505f5f610b6e610b6988610dd0565b610e09565b5f0b600103610bbe57868c52610b8387610dd0565b9050610b8e81610e6e565b60208e0191909152915081610bb95760405163396ec77160e01b81526004810182905260240161057c565b610c21565b610bca610b6987610dd0565b5f0b600103610bdf57858c52610b8386610dd0565b828c52610beb83610dd0565b9050610bf681610e6e565b60208e0191909152915081610c215760405163396ec77160e01b81526004810182905260240161057c565b60208c0151610c2f90610e95565b610c388e610e95565b14610c5f5760208c0151610c59905f5160206121a05f395f51905f52612096565b60208d01525b5050505050505050505050919050565b815160609060ff811115610c9857836040516313727cdd60e11b815260040161057c9190611f55565b60408051608880825260c082019092525f916020820181803683370190505090505f81855f60605f8a88604051602001610cd897969594939291906120c0565b60405160208183030381529060405290505f818051906020012090505f8160018987604051602001610d0d949392919061212a565b60408051808303601f1901815282825280516020820120606080855260808501909352909350915f91602082018180368337019050509050600360015b81811015610da957858418610d6082600161216d565b8d8b604051602001610d75949392919061212a565b60408051808303601f1901815291905260205f19830181028501810195909552805194810194909420939450600101610d4a565b505f19016020908102820101919091529550505050505092915050565b5f6103fb82610ea1565b5f5f5160206121a05f395f51905f5260035f5160206121a05f395f51905f52845f5160206121a05f395f51905f52868709090892915050565b5f5f610e14836115e6565b9050610e2e60015f5160206121a05f395f51905f52612096565b8103610e3d57505f1992915050565b8015801590610e4d575080600114155b156103fb5760405163396ec77160e01b81526004810184905260240161057c565b5f5f610e79836116ae565b9150825f5160206121a05f395f51905f52838409149050915091565b5f6103fb600283612180565b5f5f5160206121a05f395f51905f528083840991508083830981838209828283098385830984848309858484098684850997508684840987858409945087898a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087838a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985050868889099750868889099750868889099750868889099750868889099750868889099750868489099750868889099750868889099750868889099750868889099750868889099750868989099750868889099750868889099750868889099750868889099750868889099750868889099750868989099750868889099750868889099750868889099750868889099750868889099750868689099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868189099750508587880996508587880996508587880996508585880996508587880996508587880996508587880996508585880996508587880996508587880996508587880996508587880996508587880996508587880996508587880996508587880996508583880996508587880996508587880996508587880996508587880996508581880996505050838586099450838586099450838586099450838586099450838186099450508284850993508284850993508284850993508281850993508284850993508284850993508285850993508284850993508284850993508284850993508284850993508284850993508284850993508281850995945050505050565b6040805160c080825260e082019092525f918291906020820181803683370190505060208082018181526040830182905260608301829052608083018690525f5160206121c05f395f51905f5260a08401525f5160206121a05f395f51905f5260c0808501919091529293505f92839160055afa90505f519250806116a75760405163c6daf7ab60e01b8152600481018590525f5160206121c05f395f51905f5260248201525f5160206121a05f395f51905f52604482015260640161057c565b5050919050565b5f5f5160206121a05f395f51905f528083840991508083830981838209828283098385830984848309858484098684850997508684840987858409945087898a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087878a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a09985087898a09985087898a09985087898a09985087838a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087828a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087848a09985087898a09985087898a09985087898a09985087898a09985087898a09985087868a09985087898a09985087898a099850878a8a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087898a09985087818a09985050868889099750868889099750868889099750868889099750868889099750868889099750868489099750868889099750868889099750868889099750868889099750868889099750868989099750868889099750868889099750868889099750868889099750868889099750868889099750868989099750868889099750868889099750868889099750868889099750868889099750868689099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868889099750868189099750508587880996508587880996508587880996508585880996508587880996508587880996508587880996508585880996508587880996508587880996508587880996508587880996508587880996508587880996508587880996508587880996508583880996508587880996508587880996508587880996508587880996508581880996508587880996508587880996508587880996508587880996508583880996508587880996508587880996508587880996508584880996508587880996508587880996508587880996508587880996508587880996508581880996505050505050808283099392505050565b60405180604001604052806002906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b6040518060400160405280611e30611de1565b8152602001611e3d611de1565b905290565b60405180602001604052806001906020820280368337509192915050565b805f5b6002811015611e82578151845260209384019390910190600101611e63565b50505050565b60808101611e968285611e60565b611ea36040830184611e60565b9392505050565b5f5f83601f840112611eba575f5ffd5b50813567ffffffffffffffff811115611ed1575f5ffd5b6020830191508360208285010111156102b5575f5ffd5b5f5f60208385031215611ef9575f5ffd5b823567ffffffffffffffff811115611f0f575f5ffd5b611f1b85828601611eaa565b90969095509350505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f611ea36020830184611f27565b5f5f5f5f5f5f60608789031215611f7c575f5ffd5b863567ffffffffffffffff811115611f92575f5ffd5b611f9e89828a01611eaa565b909750955050602087013567ffffffffffffffff811115611fbd575f5ffd5b611fc989828a01611eaa565b909550935050604087013567ffffffffffffffff811115611fe8575f5ffd5b611ff489828a01611eaa565b979a9699509497509295939492505050565b600181811c9082168061201a57607f821691505b60208210810361203857634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b6080810181835f5b600481101561207957815183526020928301929091019060010161205a565b50505092915050565b634e487b7160e01b5f52601160045260245ffd5b818103818111156103fb576103fb612082565b5f81518060208401855e5f93019283525090919050565b5f6120d46120ce838b6120a9565b896120a9565b6001600160f81b031960f889811b8216835288811b8216600184015287901b16600282015261210660038201866120a9565b60f89490941b6001600160f81b031916845250506001909101979650505050505050565b84815260f884901b6001600160f81b03191660208201525f61214f60218301856120a9565b60f89390931b6001600160f81b031916835250506001019392505050565b808201808211156103fb576103fb612082565b5f8261219a57634e487b7160e01b5f52601260045260245ffd5b50069056fe30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea3
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\x85W_5`\xE0\x1C\x80c\x8A\x1F\x16Z\x11a\0XW\x80c\x8A\x1F\x16Z\x14a\0\xF3W\x80c\xAC\xAE\x9F\xEE\x14a\x01%W\x80c\xEA\xE1\xE1[\x14a\x01-W\x80c\xF6\xE5H\xE9\x14a\x01@W__\xFD[\x80c.3DR\x14a\0\x89W\x80c03\xCCQ\x14a\0\xA8W\x80c4\x08\xE4p\x14a\0\xD0W\x80c_|u\"\x14a\0\xDEW[__\xFD[a\0\x91a\x01cV[`@Qa\0\x9F\x92\x91\x90a\x1E\x88V[`@Q\x80\x91\x03\x90\xF3[a\0\xBBa\0\xB66`\x04a\x1E\xE8V[a\x01\xDCV[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\0\x9FV[`@QF\x81R` \x01a\0\x9FV[a\0\xE6a\x02\xBCV[`@Qa\0\x9F\x91\x90a\x1FUV[a\0\xE6`@Q\x80`@\x01`@R\x80`\x13\x81R` \x01rBN254-BLS-BLOCKLOCK`h\x1B\x81RP\x81V[a\0\xE6a\x03HV[a\0\xE6a\x01;6`\x04a\x1E\xE8V[a\x03\xC7V[a\x01Sa\x01N6`\x04a\x1FgV[a\x04\x01V[`@Q\x90\x15\x15\x81R` \x01a\0\x9FV[a\x01ka\x1D\xE1V[a\x01sa\x1D\xE1V[`@\x80Q\x80\x82\x01\x91\x82\x90R_\x91`\x02\x91\x90\x83\x90\x83\x90\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x01\x8BWPP`@\x80Q\x80\x82\x01\x91\x82\x90R\x94\x96P\x85\x93P`\x02\x92P\x90P\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x01\xBAWPPPPP\x90P\x91P\x91P\x90\x91V[___a\x02\xA6`\x04\x80Ta\x01\xEF\x90a \x06V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x02\x1B\x90a \x06V[\x80\x15a\x02fW\x80`\x1F\x10a\x02=Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x02fV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x02IW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x04\xE1\x92PPPV[\x80Q` \x90\x91\x01Q\x90\x93P\x91PP[\x92P\x92\x90PV[`\x04\x80Ta\x02\xC9\x90a \x06V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x02\xF5\x90a \x06V[\x80\x15a\x03@W\x80`\x1F\x10a\x03\x17Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x03@V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x03#W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[`@\x80Q`\x80\x81\x01\x80\x83R``\x92a\x03\xC2\x92\x91_\x91\x83\x91\x90\x82\x01\x90\x83\x90`\x02\x90\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x03kWPPP\x91\x83RPP`@\x80Q\x80\x82\x01\x91\x82\x90R` \x90\x92\x01\x91\x90`\x02\x84\x81\x01\x91\x82\x84[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x03\xA1WPPPPP\x81RPPa\x05\xADV[\x90P\x90V[``__a\x03\xD5\x85\x85a\x01\xDCV[\x91P\x91Pa\x03\xF6`@Q\x80`@\x01`@R\x80\x84\x81R` \x01\x83\x81RPa\x06\tV[\x92PPP[\x92\x91PPV[__a\x04A\x88\x88\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x06B\x92PPPV[\x90P_a\x04\x82\x87\x87\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x06B\x92PPPV[\x90P_a\x04\xC3\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x06\xC5\x92PPPV[\x90P_a\x04\xD1\x83\x83\x86a\x07fV[P\x9B\x9APPPPPPPPPPPV[`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01R_a\x04\xFF\x84\x84a\x08\xD9V[\x90P_a\x05\x12\x82\x82[` \x02\x01Qa\t\x8EV[\x90P_a\x05 \x83`\x01a\x05\x08V[\x90Pa\x05*a\x1D\xFFV[\x82Q\x81R` \x80\x84\x01Q\x82\x82\x01R\x82Q`@\x80\x84\x01\x91\x90\x91R\x90\x83\x01Q``\x83\x01R_\x90\x84`\x80\x84`\x06a\x07\xD0Z\x03\xFA\x90P\x80a\x05\x85W\x81`@Qc\x02Q\xC7\xE1`\xE3\x1B\x81R`\x04\x01a\x05|\x91\x90a RV[`@Q\x80\x91\x03\x90\xFD[`@\x80Q\x80\x82\x01\x90\x91R\x84Q\x81R` \x81\x01\x85`\x01` \x02\x01Q\x90R\x98\x97PPPPPPPPV[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R``\x91_\x91\x90` \x82\x01\x81\x806\x837PP\x84Q\x80Q` \x91\x82\x01Q\x96\x82\x01Q\x80Q\x90\x83\x01Q\x92\x85\x01\x91\x90\x91R`@\x84\x01\x96\x90\x96R``\x83\x01\x95\x90\x95RP`\x80\x81\x01\x93\x90\x93RP\x90\x91\x90PV[`@\x80Q\x81\x81R``\x81\x81\x01\x83R\x91_\x91\x90` \x82\x01\x81\x806\x837PP\x84Q` \x95\x86\x01Q\x95\x83\x01RP`@\x81\x01\x93\x90\x93RP\x90\x91\x90PV[`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01R\x81Q`@\x14a\x06\xA6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid G1 bytes length\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05|V[P` \x81\x81\x01Q`@\x92\x83\x01Q\x83Q\x80\x85\x01\x90\x94R\x90\x83R\x90\x82\x01R\x90V[a\x06\xCDa\x1E\x1DV[\x81Q`\x80\x14a\x07\x1EW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid G2 bytes length\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05|V[P` \x81\x81\x01Q`@\x80\x84\x01Q``\x80\x86\x01Q`\x80\x96\x87\x01Q\x84Q\x97\x88\x01\x85R\x87\x85\x01\x95\x86R\x91\x87\x01\x92\x90\x92R\x92\x85R\x81Q\x80\x83\x01\x90\x92R\x81R\x80\x83\x01\x91\x90\x91R\x90\x82\x01R\x90V[___`@Q\x80a\x01\x80\x01`@R\x80\x87_\x01Q\x81R` \x01\x87` \x01Q\x81R` \x01\x7F\x19\x8E\x93\x93\x92\rH:r`\xBF\xB71\xFB]%\xF1\xAAI35\xA9\xE7\x12\x97\xE4\x85\xB7\xAE\xF3\x12\xC2\x81R` \x01\x7F\x18\0\xDE\xEF\x12\x1F\x1EvBj\0f^\\DygC\"\xD4\xF7^\xDA\xDDF\xDE\xBD\\\xD9\x92\xF6\xED\x81R` \x01\x7F']\xC4\xA2\x88\xD1\xAF\xB3\xCB\xB1\xAC\t\x18u$\xC7\xDB69]\xF7\xBE;\x99\xE6s\xB1:\x07Ze\xEC\x81R` \x01\x7F\x1D\x9B\xEF\xCD\x05\xA52>m\xA4\xD45\xF3\xB6\x17\xCD\xB3\xAF\x83(\\-\xF7\x11\xEF9\xC0\x15q\x82\x7F\x9D\x81R` \x01\x85_\x01Q\x81R` \x01\x85` \x01Q\x81R` \x01\x86_\x01Q`\x01`\x02\x81\x10a\x08IWa\x08Ia >V[` \x02\x01Q\x81R` \x01\x86_\x01Q_`\x02\x81\x10a\x08hWa\x08ha >V[` \x02\x01Q\x81R` \x01\x86` \x01Q`\x01`\x02\x81\x10a\x08\x89Wa\x08\x89a >V[` \x02\x01Q\x81R` \x01\x86` \x01Q_`\x02\x81\x10a\x08\xA9Wa\x08\xA9a >V[` \x02\x01Q\x90R\x90Pa\x08\xBAa\x1EBV[` \x81a\x01\x80\x84`\x08a\x07\xD0Z\x03\xFA\x90Q\x15\x15\x97\x90\x96P\x94PPPPPV[a\x08\xE1a\x1D\xE1V[_a\x08\xEC\x84\x84a\x0CoV[\x90P____`\x18\x85\x01`\x01`\x01`\xC0\x1B\x03\x81Q\x16\x93P`0\x86\x01\x90P`\x01`\x01`\xC0\x1B\x03\x81Q\x16\x94P_Q` a!\xA0_9_Q\x90_R\x85_Q` a!\xA0_9_Q\x90_R`\x01`\xC0\x1B\x87\t\x08`H\x87\x01Q``\x88\x01Q`\x01`\x01`\xC0\x1B\x03\x90\x81\x16\x97P\x16\x94P\x92P_Q` a!\xA0_9_Q\x90_R\x90P\x84\x81`\x01`\xC0\x1B\x86\t\x08`@\x80Q\x80\x82\x01\x90\x91R\x92\x83R` \x83\x01RP\x96\x95PPPPPPV[a\t\x96a\x1D\xE1V[_Q` a!\xA0_9_Q\x90_R\x82\x10a\t\xC6W`@Qc\xD5>\x94\x15`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x05|V[__Q` a!\xA0_9_Q\x90_R`\x04_Q` a!\xA0_9_Q\x90_R\x85\x86\t\t\x90P__Q` a!\xA0_9_Q\x90_R\x82`\x01\x08\x90P_Q` a!\xA0_9_Q\x90_Ra\n%\x83_Q` a!\xA0_9_Q\x90_Ra \x96V[`\x01\x08\x91P_a\nD_Q` a!\xA0_9_Q\x90_R\x83\x85\ta\r\xC6V[\x90P__Q` a!\xA0_9_Q\x90_Rx\x01g\x89\xAF:\x83R.\xB3S\xC9\x8F\xC6\xB3mq=]\x8D\x1C\xC5\xDF\xFF\xFF\xFA_Q` a!\xA0_9_Q\x90_R\x84_Q` a!\xA0_9_Q\x90_R\x88\x8B\t\t\t\x90P__Q` a!\xA0_9_Q\x90_Ra\n\xB9\x83_Q` a!\xA0_9_Q\x90_Ra \x96V[_Q` a!\xC0_9_Q\x90_R\x08\x90P__Q` a!\xA0_9_Q\x90_R\x83_Q` a!\xC0_9_Q\x90_R\x08\x90P__Q` a!\xA0_9_Q\x90_R\x86\x87\t\x90P__Q` a!\xA0_9_Q\x90_R\x86\x83\t\x90P__Q` a!\xA0_9_Q\x90_R\x80_Q` a!\xA0_9_Q\x90_R\x84\x85\t\x7F\x10!o{\xA0e\xE0\r\xE8\x1A\xC1\xE7\x80\x80r\xC9\xDD+#\x85\xCD{C\x84i`.\xB2H)\xA9\xBD\t`\x01\x08\x90P__a\x0Bna\x0Bi\x88a\r\xD0V[a\x0E\tV[_\x0B`\x01\x03a\x0B\xBEW\x86\x8CRa\x0B\x83\x87a\r\xD0V[\x90Pa\x0B\x8E\x81a\x0EnV[` \x8E\x01\x91\x90\x91R\x91P\x81a\x0B\xB9W`@Qc9n\xC7q`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x05|V[a\x0C!V[a\x0B\xCAa\x0Bi\x87a\r\xD0V[_\x0B`\x01\x03a\x0B\xDFW\x85\x8CRa\x0B\x83\x86a\r\xD0V[\x82\x8CRa\x0B\xEB\x83a\r\xD0V[\x90Pa\x0B\xF6\x81a\x0EnV[` \x8E\x01\x91\x90\x91R\x91P\x81a\x0C!W`@Qc9n\xC7q`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x05|V[` \x8C\x01Qa\x0C/\x90a\x0E\x95V[a\x0C8\x8Ea\x0E\x95V[\x14a\x0C_W` \x8C\x01Qa\x0CY\x90_Q` a!\xA0_9_Q\x90_Ra \x96V[` \x8D\x01R[PPPPPPPPPPP\x91\x90PV[\x81Q``\x90`\xFF\x81\x11\x15a\x0C\x98W\x83`@Qc\x13r|\xDD`\xE1\x1B\x81R`\x04\x01a\x05|\x91\x90a\x1FUV[`@\x80Q`\x88\x80\x82R`\xC0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_\x81\x85_``_\x8A\x88`@Q` \x01a\x0C\xD8\x97\x96\x95\x94\x93\x92\x91\x90a \xC0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P_\x81\x80Q\x90` \x01 \x90P_\x81`\x01\x89\x87`@Q` \x01a\r\r\x94\x93\x92\x91\x90a!*V[`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x82\x82R\x80Q` \x82\x01 ``\x80\x85R`\x80\x85\x01\x90\x93R\x90\x93P\x91_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P`\x03`\x01[\x81\x81\x10\x15a\r\xA9W\x85\x84\x18a\r`\x82`\x01a!mV[\x8D\x8B`@Q` \x01a\ru\x94\x93\x92\x91\x90a!*V[`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x91\x90R` _\x19\x83\x01\x81\x02\x85\x01\x81\x01\x95\x90\x95R\x80Q\x94\x81\x01\x94\x90\x94 \x93\x94P`\x01\x01a\rJV[P_\x19\x01` \x90\x81\x02\x82\x01\x01\x91\x90\x91R\x95PPPPPP\x92\x91PPV[_a\x03\xFB\x82a\x0E\xA1V[__Q` a!\xA0_9_Q\x90_R`\x03_Q` a!\xA0_9_Q\x90_R\x84_Q` a!\xA0_9_Q\x90_R\x86\x87\t\t\x08\x92\x91PPV[__a\x0E\x14\x83a\x15\xE6V[\x90Pa\x0E.`\x01_Q` a!\xA0_9_Q\x90_Ra \x96V[\x81\x03a\x0E=WP_\x19\x92\x91PPV[\x80\x15\x80\x15\x90a\x0EMWP\x80`\x01\x14\x15[\x15a\x03\xFBW`@Qc9n\xC7q`\xE0\x1B\x81R`\x04\x81\x01\x84\x90R`$\x01a\x05|V[__a\x0Ey\x83a\x16\xAEV[\x91P\x82_Q` a!\xA0_9_Q\x90_R\x83\x84\t\x14\x90P\x91P\x91V[_a\x03\xFB`\x02\x83a!\x80V[__Q` a!\xA0_9_Q\x90_R\x80\x83\x84\t\x91P\x80\x83\x83\t\x81\x83\x82\t\x82\x82\x83\t\x83\x85\x83\t\x84\x84\x83\t\x85\x84\x84\t\x86\x84\x85\t\x97P\x86\x84\x84\t\x87\x85\x84\t\x94P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x83\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98PP\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x84\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x89\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x89\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x86\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x81\x89\t\x97PP\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x85\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x85\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x83\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x81\x88\t\x96PPP\x83\x85\x86\t\x94P\x83\x85\x86\t\x94P\x83\x85\x86\t\x94P\x83\x85\x86\t\x94P\x83\x81\x86\t\x94PP\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x81\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x85\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x84\x85\t\x93P\x82\x81\x85\t\x95\x94PPPPPV[`@\x80Q`\xC0\x80\x82R`\xE0\x82\x01\x90\x92R_\x91\x82\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP` \x80\x82\x01\x81\x81R`@\x83\x01\x82\x90R``\x83\x01\x82\x90R`\x80\x83\x01\x86\x90R_Q` a!\xC0_9_Q\x90_R`\xA0\x84\x01R_Q` a!\xA0_9_Q\x90_R`\xC0\x80\x85\x01\x91\x90\x91R\x92\x93P_\x92\x83\x91`\x05Z\xFA\x90P_Q\x92P\x80a\x16\xA7W`@Qc\xC6\xDA\xF7\xAB`\xE0\x1B\x81R`\x04\x81\x01\x85\x90R_Q` a!\xC0_9_Q\x90_R`$\x82\x01R_Q` a!\xA0_9_Q\x90_R`D\x82\x01R`d\x01a\x05|V[PP\x91\x90PV[__Q` a!\xA0_9_Q\x90_R\x80\x83\x84\t\x91P\x80\x83\x83\t\x81\x83\x82\t\x82\x82\x83\t\x83\x85\x83\t\x84\x84\x83\t\x85\x84\x84\t\x86\x84\x85\t\x97P\x86\x84\x84\t\x87\x85\x84\t\x94P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x87\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x83\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x82\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x84\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x86\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x8A\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x89\x8A\t\x98P\x87\x81\x8A\t\x98PP\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x84\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x89\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x89\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x86\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x88\x89\t\x97P\x86\x81\x89\t\x97PP\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x85\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x85\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x83\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x81\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x83\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x84\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x87\x88\t\x96P\x85\x81\x88\t\x96PPPPPP\x80\x82\x83\t\x93\x92PPPV[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`\x80\x01`@R\x80`\x04\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`@\x01`@R\x80a\x1E0a\x1D\xE1V[\x81R` \x01a\x1E=a\x1D\xE1V[\x90R\x90V[`@Q\x80` \x01`@R\x80`\x01\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[\x80_[`\x02\x81\x10\x15a\x1E\x82W\x81Q\x84R` \x93\x84\x01\x93\x90\x91\x01\x90`\x01\x01a\x1EcV[PPPPV[`\x80\x81\x01a\x1E\x96\x82\x85a\x1E`V[a\x1E\xA3`@\x83\x01\x84a\x1E`V[\x93\x92PPPV[__\x83`\x1F\x84\x01\x12a\x1E\xBAW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1E\xD1W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x02\xB5W__\xFD[__` \x83\x85\x03\x12\x15a\x1E\xF9W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\x0FW__\xFD[a\x1F\x1B\x85\x82\x86\x01a\x1E\xAAV[\x90\x96\x90\x95P\x93PPPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x1E\xA3` \x83\x01\x84a\x1F'V[______``\x87\x89\x03\x12\x15a\x1F|W__\xFD[\x865g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\x92W__\xFD[a\x1F\x9E\x89\x82\x8A\x01a\x1E\xAAV[\x90\x97P\x95PP` \x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xBDW__\xFD[a\x1F\xC9\x89\x82\x8A\x01a\x1E\xAAV[\x90\x95P\x93PP`@\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xE8W__\xFD[a\x1F\xF4\x89\x82\x8A\x01a\x1E\xAAV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a \x1AW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a 8WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[`\x80\x81\x01\x81\x83_[`\x04\x81\x10\x15a yW\x81Q\x83R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a ZV[PPP\x92\x91PPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x03\xFBWa\x03\xFBa \x82V[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a \xD4a \xCE\x83\x8Ba \xA9V[\x89a \xA9V[`\x01`\x01`\xF8\x1B\x03\x19`\xF8\x89\x81\x1B\x82\x16\x83R\x88\x81\x1B\x82\x16`\x01\x84\x01R\x87\x90\x1B\x16`\x02\x82\x01Ra!\x06`\x03\x82\x01\x86a \xA9V[`\xF8\x94\x90\x94\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x84RPP`\x01\x90\x91\x01\x97\x96PPPPPPPV[\x84\x81R`\xF8\x84\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x82\x01R_a!O`!\x83\x01\x85a \xA9V[`\xF8\x93\x90\x93\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x83RPP`\x01\x01\x93\x92PPPV[\x80\x82\x01\x80\x82\x11\x15a\x03\xFBWa\x03\xFBa \x82V[_\x82a!\x9AWcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[P\x06\x90V\xFE0dNr\xE11\xA0)\xB8PE\xB6\x81\x81X]\x97\x81j\x91hq\xCA\x8D< \x8C\x16\xD8|\xFDG\x182'9p\x98\xD0\x14\xDC(\"\xDB@\xC0\xAC.\xCB\xC0\xB5H\xB48\xE5F\x9E\x10F\x0Bl>~\xA3",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BNAddFailed(uint256[4])` and selector `0x128e3f08`.
```solidity
error BNAddFailed(uint256[4] input);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BNAddFailed {
        #[allow(missing_docs)]
        pub input: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::Uint<256>,
                4usize,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [alloy::sol_types::private::primitives::aliases::U256; 4usize],
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BNAddFailed> for UnderlyingRustTuple<'_> {
            fn from(value: BNAddFailed) -> Self {
                (value.input,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BNAddFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { input: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BNAddFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BNAddFailed(uint256[4])";
            const SELECTOR: [u8; 4] = [18u8, 142u8, 63u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        4usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.input),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidDSTLength(bytes)` and selector `0x26e4f9ba`.
```solidity
error InvalidDSTLength(bytes dst);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDSTLength {
        #[allow(missing_docs)]
        pub dst: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDSTLength> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDSTLength) -> Self {
                (value.dst,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidDSTLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { dst: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDSTLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDSTLength(bytes)";
            const SELECTOR: [u8; 4] = [38u8, 228u8, 249u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.dst,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidFieldElement(uint256)` and selector `0xd53e9415`.
```solidity
error InvalidFieldElement(uint256 x);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidFieldElement {
        #[allow(missing_docs)]
        pub x: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidFieldElement> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidFieldElement) -> Self {
                (value.x,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidFieldElement {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { x: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidFieldElement {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidFieldElement(uint256)";
            const SELECTOR: [u8; 4] = [213u8, 62u8, 148u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.x),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `MapToPointFailed(uint256)` and selector `0x396ec771`.
```solidity
error MapToPointFailed(uint256 noSqrt);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MapToPointFailed {
        #[allow(missing_docs)]
        pub noSqrt: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MapToPointFailed> for UnderlyingRustTuple<'_> {
            fn from(value: MapToPointFailed) -> Self {
                (value.noSqrt,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MapToPointFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { noSqrt: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MapToPointFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MapToPointFailed(uint256)";
            const SELECTOR: [u8; 4] = [57u8, 110u8, 199u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.noSqrt),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ModExpFailed(uint256,uint256,uint256)` and selector `0xc6daf7ab`.
```solidity
error ModExpFailed(uint256 base, uint256 exponent, uint256 modulus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ModExpFailed {
        #[allow(missing_docs)]
        pub base: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub exponent: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub modulus: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ModExpFailed> for UnderlyingRustTuple<'_> {
            fn from(value: ModExpFailed) -> Self {
                (value.base, value.exponent, value.modulus)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ModExpFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    base: tuple.0,
                    exponent: tuple.1,
                    modulus: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ModExpFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ModExpFailed(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [198u8, 218u8, 247u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.base),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.exponent),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.modulus),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(uint256[2] x, uint256[2] y);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub x: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        #[allow(missing_docs)]
        pub y: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.x, value.y)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { x: tuple.0, y: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.x),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.y),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DST()` and selector `0x5f7c7522`.
```solidity
function DST() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DSTCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DST()`](DSTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DSTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DSTCall> for UnderlyingRustTuple<'_> {
                fn from(value: DSTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DSTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DSTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: DSTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for DSTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DSTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DST()";
            const SELECTOR: [u8; 4] = [95u8, 124u8, 117u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DSTReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DSTReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `SCHEME_ID()` and selector `0x8a1f165a`.
```solidity
function SCHEME_ID() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SCHEME_IDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`SCHEME_ID()`](SCHEME_IDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SCHEME_IDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SCHEME_IDCall> for UnderlyingRustTuple<'_> {
                fn from(value: SCHEME_IDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SCHEME_IDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SCHEME_IDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SCHEME_IDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SCHEME_IDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SCHEME_IDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SCHEME_ID()";
            const SELECTOR: [u8; 4] = [138u8, 31u8, 22u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: SCHEME_IDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: SCHEME_IDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getChainId()` and selector `0x3408e470`.
```solidity
function getChainId() external view returns (uint256 chainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getChainIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getChainId()`](getChainIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getChainIdReturn {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getChainIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getChainIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getChainIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getChainIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getChainIdReturn) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getChainIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getChainIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getChainId()";
            const SELECTOR: [u8; 4] = [52u8, 8u8, 228u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getChainIdReturn = r.into();
                        r.chainId
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getChainIdReturn = r.into();
                        r.chainId
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPublicKey()` and selector `0x2e334452`.
```solidity
function getPublicKey() external view returns (uint256[2] memory, uint256[2] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicKeyCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPublicKey()`](getPublicKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicKeyReturn {
        #[allow(missing_docs)]
        pub _0: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        #[allow(missing_docs)]
        pub _1: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPublicKeyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPublicKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPublicKeyReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPublicKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        impl getPublicKeyReturn {
            fn _tokenize(
                &self,
            ) -> <getPublicKeyCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPublicKeyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPublicKeyReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPublicKey()";
            const SELECTOR: [u8; 4] = [46u8, 51u8, 68u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getPublicKeyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPublicKeyBytes()` and selector `0xacae9fee`.
```solidity
function getPublicKeyBytes() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicKeyBytesCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPublicKeyBytes()`](getPublicKeyBytesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicKeyBytesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicKeyBytesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPublicKeyBytesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPublicKeyBytesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicKeyBytesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPublicKeyBytesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPublicKeyBytesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPublicKeyBytesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPublicKeyBytes()";
            const SELECTOR: [u8; 4] = [172u8, 174u8, 159u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getPublicKeyBytesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getPublicKeyBytesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hashToBytes(bytes)` and selector `0xeae1e15b`.
```solidity
function hashToBytes(bytes memory message) external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hashToBytesCall {
        #[allow(missing_docs)]
        pub message: alloy::sol_types::private::Bytes,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hashToBytes(bytes)`](hashToBytesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hashToBytesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hashToBytesCall> for UnderlyingRustTuple<'_> {
                fn from(value: hashToBytesCall) -> Self {
                    (value.message,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hashToBytesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { message: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hashToBytesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hashToBytesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hashToBytesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hashToBytesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hashToBytes(bytes)";
            const SELECTOR: [u8; 4] = [234u8, 225u8, 225u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.message,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hashToBytesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hashToBytesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hashToPoint(bytes)` and selector `0x3033cc51`.
```solidity
function hashToPoint(bytes memory message) external view returns (uint256, uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hashToPointCall {
        #[allow(missing_docs)]
        pub message: alloy::sol_types::private::Bytes,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hashToPoint(bytes)`](hashToPointCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hashToPointReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hashToPointCall> for UnderlyingRustTuple<'_> {
                fn from(value: hashToPointCall) -> Self {
                    (value.message,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hashToPointCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { message: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hashToPointReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hashToPointReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hashToPointReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        impl hashToPointReturn {
            fn _tokenize(
                &self,
            ) -> <hashToPointCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hashToPointCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hashToPointReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hashToPoint(bytes)";
            const SELECTOR: [u8; 4] = [48u8, 51u8, 204u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.message,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                hashToPointReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `verifySignature(bytes,bytes,bytes)` and selector `0xf6e548e9`.
```solidity
function verifySignature(bytes memory message, bytes memory signature, bytes memory publicKey) external view returns (bool isValid);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifySignatureCall {
        #[allow(missing_docs)]
        pub message: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub publicKey: alloy::sol_types::private::Bytes,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`verifySignature(bytes,bytes,bytes)`](verifySignatureCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifySignatureReturn {
        #[allow(missing_docs)]
        pub isValid: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifySignatureCall> for UnderlyingRustTuple<'_> {
                fn from(value: verifySignatureCall) -> Self {
                    (value.message, value.signature, value.publicKey)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verifySignatureCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        message: tuple.0,
                        signature: tuple.1,
                        publicKey: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifySignatureReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifySignatureReturn) -> Self {
                    (value.isValid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifySignatureReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { isValid: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verifySignatureCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verifySignature(bytes,bytes,bytes)";
            const SELECTOR: [u8; 4] = [246u8, 229u8, 72u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.message,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.publicKey,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: verifySignatureReturn = r.into();
                        r.isValid
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: verifySignatureReturn = r.into();
                        r.isValid
                    })
            }
        }
    };
    ///Container for all the [`BlocklockSignatureScheme`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum BlocklockSignatureSchemeCalls {
        #[allow(missing_docs)]
        DST(DSTCall),
        #[allow(missing_docs)]
        SCHEME_ID(SCHEME_IDCall),
        #[allow(missing_docs)]
        getChainId(getChainIdCall),
        #[allow(missing_docs)]
        getPublicKey(getPublicKeyCall),
        #[allow(missing_docs)]
        getPublicKeyBytes(getPublicKeyBytesCall),
        #[allow(missing_docs)]
        hashToBytes(hashToBytesCall),
        #[allow(missing_docs)]
        hashToPoint(hashToPointCall),
        #[allow(missing_docs)]
        verifySignature(verifySignatureCall),
    }
    impl BlocklockSignatureSchemeCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [46u8, 51u8, 68u8, 82u8],
            [48u8, 51u8, 204u8, 81u8],
            [52u8, 8u8, 228u8, 112u8],
            [95u8, 124u8, 117u8, 34u8],
            [138u8, 31u8, 22u8, 90u8],
            [172u8, 174u8, 159u8, 238u8],
            [234u8, 225u8, 225u8, 91u8],
            [246u8, 229u8, 72u8, 233u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(getPublicKey),
            ::core::stringify!(hashToPoint),
            ::core::stringify!(getChainId),
            ::core::stringify!(DST),
            ::core::stringify!(SCHEME_ID),
            ::core::stringify!(getPublicKeyBytes),
            ::core::stringify!(hashToBytes),
            ::core::stringify!(verifySignature),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <getPublicKeyCall as alloy_sol_types::SolCall>::SIGNATURE,
            <hashToPointCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getChainIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <DSTCall as alloy_sol_types::SolCall>::SIGNATURE,
            <SCHEME_IDCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getPublicKeyBytesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <hashToBytesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <verifySignatureCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for BlocklockSignatureSchemeCalls {
        const NAME: &'static str = "BlocklockSignatureSchemeCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 8usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DST(_) => <DSTCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::SCHEME_ID(_) => {
                    <SCHEME_IDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getChainId(_) => {
                    <getChainIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPublicKey(_) => {
                    <getPublicKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPublicKeyBytes(_) => {
                    <getPublicKeyBytesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hashToBytes(_) => {
                    <hashToBytesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hashToPoint(_) => {
                    <hashToPointCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::verifySignature(_) => {
                    <verifySignatureCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls>] = &[
                {
                    fn getPublicKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <getPublicKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::getPublicKey)
                    }
                    getPublicKey
                },
                {
                    fn hashToPoint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <hashToPointCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::hashToPoint)
                    }
                    hashToPoint
                },
                {
                    fn getChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <getChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::getChainId)
                    }
                    getChainId
                },
                {
                    fn DST(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <DSTCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSignatureSchemeCalls::DST)
                    }
                    DST
                },
                {
                    fn SCHEME_ID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <SCHEME_IDCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(BlocklockSignatureSchemeCalls::SCHEME_ID)
                    }
                    SCHEME_ID
                },
                {
                    fn getPublicKeyBytes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <getPublicKeyBytesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::getPublicKeyBytes)
                    }
                    getPublicKeyBytes
                },
                {
                    fn hashToBytes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <hashToBytesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::hashToBytes)
                    }
                    hashToBytes
                },
                {
                    fn verifySignature(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <verifySignatureCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::verifySignature)
                    }
                    verifySignature
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls>] = &[
                {
                    fn getPublicKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <getPublicKeyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::getPublicKey)
                    }
                    getPublicKey
                },
                {
                    fn hashToPoint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <hashToPointCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::hashToPoint)
                    }
                    hashToPoint
                },
                {
                    fn getChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <getChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::getChainId)
                    }
                    getChainId
                },
                {
                    fn DST(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <DSTCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::DST)
                    }
                    DST
                },
                {
                    fn SCHEME_ID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <SCHEME_IDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::SCHEME_ID)
                    }
                    SCHEME_ID
                },
                {
                    fn getPublicKeyBytes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <getPublicKeyBytesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::getPublicKeyBytes)
                    }
                    getPublicKeyBytes
                },
                {
                    fn hashToBytes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <hashToBytesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::hashToBytes)
                    }
                    hashToBytes
                },
                {
                    fn verifySignature(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeCalls> {
                        <verifySignatureCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeCalls::verifySignature)
                    }
                    verifySignature
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DST(inner) => {
                    <DSTCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::SCHEME_ID(inner) => {
                    <SCHEME_IDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getChainId(inner) => {
                    <getChainIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getPublicKey(inner) => {
                    <getPublicKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPublicKeyBytes(inner) => {
                    <getPublicKeyBytesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hashToBytes(inner) => {
                    <hashToBytesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hashToPoint(inner) => {
                    <hashToPointCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::verifySignature(inner) => {
                    <verifySignatureCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DST(inner) => {
                    <DSTCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::SCHEME_ID(inner) => {
                    <SCHEME_IDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getChainId(inner) => {
                    <getChainIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPublicKey(inner) => {
                    <getPublicKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPublicKeyBytes(inner) => {
                    <getPublicKeyBytesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hashToBytes(inner) => {
                    <hashToBytesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hashToPoint(inner) => {
                    <hashToPointCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::verifySignature(inner) => {
                    <verifySignatureCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`BlocklockSignatureScheme`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum BlocklockSignatureSchemeErrors {
        #[allow(missing_docs)]
        BNAddFailed(BNAddFailed),
        #[allow(missing_docs)]
        InvalidDSTLength(InvalidDSTLength),
        #[allow(missing_docs)]
        InvalidFieldElement(InvalidFieldElement),
        #[allow(missing_docs)]
        MapToPointFailed(MapToPointFailed),
        #[allow(missing_docs)]
        ModExpFailed(ModExpFailed),
    }
    impl BlocklockSignatureSchemeErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [18u8, 142u8, 63u8, 8u8],
            [38u8, 228u8, 249u8, 186u8],
            [57u8, 110u8, 199u8, 113u8],
            [198u8, 218u8, 247u8, 171u8],
            [213u8, 62u8, 148u8, 21u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(BNAddFailed),
            ::core::stringify!(InvalidDSTLength),
            ::core::stringify!(MapToPointFailed),
            ::core::stringify!(ModExpFailed),
            ::core::stringify!(InvalidFieldElement),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <BNAddFailed as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidDSTLength as alloy_sol_types::SolError>::SIGNATURE,
            <MapToPointFailed as alloy_sol_types::SolError>::SIGNATURE,
            <ModExpFailed as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidFieldElement as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for BlocklockSignatureSchemeErrors {
        const NAME: &'static str = "BlocklockSignatureSchemeErrors";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 5usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BNAddFailed(_) => {
                    <BNAddFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDSTLength(_) => {
                    <InvalidDSTLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidFieldElement(_) => {
                    <InvalidFieldElement as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MapToPointFailed(_) => {
                    <MapToPointFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ModExpFailed(_) => {
                    <ModExpFailed as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors>] = &[
                {
                    fn BNAddFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <BNAddFailed as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(BlocklockSignatureSchemeErrors::BNAddFailed)
                    }
                    BNAddFailed
                },
                {
                    fn InvalidDSTLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <InvalidDSTLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeErrors::InvalidDSTLength)
                    }
                    InvalidDSTLength
                },
                {
                    fn MapToPointFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <MapToPointFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeErrors::MapToPointFailed)
                    }
                    MapToPointFailed
                },
                {
                    fn ModExpFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <ModExpFailed as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(BlocklockSignatureSchemeErrors::ModExpFailed)
                    }
                    ModExpFailed
                },
                {
                    fn InvalidFieldElement(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <InvalidFieldElement as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(BlocklockSignatureSchemeErrors::InvalidFieldElement)
                    }
                    InvalidFieldElement
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors>] = &[
                {
                    fn BNAddFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <BNAddFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeErrors::BNAddFailed)
                    }
                    BNAddFailed
                },
                {
                    fn InvalidDSTLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <InvalidDSTLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeErrors::InvalidDSTLength)
                    }
                    InvalidDSTLength
                },
                {
                    fn MapToPointFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <MapToPointFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeErrors::MapToPointFailed)
                    }
                    MapToPointFailed
                },
                {
                    fn ModExpFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <ModExpFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeErrors::ModExpFailed)
                    }
                    ModExpFailed
                },
                {
                    fn InvalidFieldElement(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<BlocklockSignatureSchemeErrors> {
                        <InvalidFieldElement as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(BlocklockSignatureSchemeErrors::InvalidFieldElement)
                    }
                    InvalidFieldElement
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BNAddFailed(inner) => {
                    <BNAddFailed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidDSTLength(inner) => {
                    <InvalidDSTLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidFieldElement(inner) => {
                    <InvalidFieldElement as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MapToPointFailed(inner) => {
                    <MapToPointFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ModExpFailed(inner) => {
                    <ModExpFailed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BNAddFailed(inner) => {
                    <BNAddFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDSTLength(inner) => {
                    <InvalidDSTLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidFieldElement(inner) => {
                    <InvalidFieldElement as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MapToPointFailed(inner) => {
                    <MapToPointFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ModExpFailed(inner) => {
                    <ModExpFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`BlocklockSignatureScheme`](self) contract instance.

See the [wrapper's documentation](`BlocklockSignatureSchemeInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> BlocklockSignatureSchemeInstance<P, N> {
        BlocklockSignatureSchemeInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        x: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        y: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<BlocklockSignatureSchemeInstance<P, N>>,
    > {
        BlocklockSignatureSchemeInstance::<P, N>::deploy(__provider, x, y)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        x: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        y: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
    ) -> alloy_contract::RawCallBuilder<P, N> {
        BlocklockSignatureSchemeInstance::<P, N>::deploy_builder(__provider, x, y)
    }
    /**A [`BlocklockSignatureScheme`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`BlocklockSignatureScheme`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct BlocklockSignatureSchemeInstance<
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for BlocklockSignatureSchemeInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("BlocklockSignatureSchemeInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BlocklockSignatureSchemeInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`BlocklockSignatureScheme`](self) contract instance.

See the [wrapper's documentation](`BlocklockSignatureSchemeInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            x: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            y: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        ) -> alloy_contract::Result<BlocklockSignatureSchemeInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider, x, y);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            x: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            y: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { x, y },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> BlocklockSignatureSchemeInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> BlocklockSignatureSchemeInstance<P, N> {
            BlocklockSignatureSchemeInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BlocklockSignatureSchemeInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DST`] function.
        pub fn DST(&self) -> alloy_contract::SolCallBuilder<&P, DSTCall, N> {
            self.call_builder(&DSTCall)
        }
        ///Creates a new call builder for the [`SCHEME_ID`] function.
        pub fn SCHEME_ID(&self) -> alloy_contract::SolCallBuilder<&P, SCHEME_IDCall, N> {
            self.call_builder(&SCHEME_IDCall)
        }
        ///Creates a new call builder for the [`getChainId`] function.
        pub fn getChainId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getChainIdCall, N> {
            self.call_builder(&getChainIdCall)
        }
        ///Creates a new call builder for the [`getPublicKey`] function.
        pub fn getPublicKey(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getPublicKeyCall, N> {
            self.call_builder(&getPublicKeyCall)
        }
        ///Creates a new call builder for the [`getPublicKeyBytes`] function.
        pub fn getPublicKeyBytes(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getPublicKeyBytesCall, N> {
            self.call_builder(&getPublicKeyBytesCall)
        }
        ///Creates a new call builder for the [`hashToBytes`] function.
        pub fn hashToBytes(
            &self,
            message: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, hashToBytesCall, N> {
            self.call_builder(&hashToBytesCall { message })
        }
        ///Creates a new call builder for the [`hashToPoint`] function.
        pub fn hashToPoint(
            &self,
            message: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, hashToPointCall, N> {
            self.call_builder(&hashToPointCall { message })
        }
        ///Creates a new call builder for the [`verifySignature`] function.
        pub fn verifySignature(
            &self,
            message: alloy::sol_types::private::Bytes,
            signature: alloy::sol_types::private::Bytes,
            publicKey: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, verifySignatureCall, N> {
            self.call_builder(
                &verifySignatureCall {
                    message,
                    signature,
                    publicKey,
                },
            )
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > BlocklockSignatureSchemeInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
