/**

Generated by the following Solidity interface...
```solidity
interface ErrorsLib {
    error AlreadyFulfilled();
    error BLSSignatureVerificationFailed();
    error DestinationChainIdNotSupported(uint256 dstChainId);
    error FeeBpsExceedsThreshold(uint256 maxFeeBps);
    error FeeTooLow();
    error GasForCallExactCheckAlreadySet();
    error GrantRoleFailed();
    error HookExecutorNotSet();
    error InsufficientVerificationFeeBalance();
    error InvalidFeeBps();
    error InvalidTokenOrRecipient();
    error NewFeeTooLow(uint256 newFee, uint256 currentFee);
    error NoUpgradePending();
    error SameVersionUpgradeNotAllowed();
    error SourceChainIdMismatch(uint256 swapRequestParamsSrcChainId, uint256 contractChainId);
    error SourceChainIdShouldBeDifferentFromDestination(uint256 srcChainId, uint256 dstChainId);
    error SwapRequestCancellationAlreadyStaged();
    error SwapRequestCancellationNotStaged();
    error SwapRequestCancellationWindowNotPassed();
    error SwapRequestCancellationWindowTooShort();
    error SwapRequestParametersMismatch();
    error TokenMappingAlreadyExists();
    error TokenNotSupported();
    error TooLateToCancelUpgrade(uint256 upgradeTime);
    error UnauthorisedCaller();
    error UpgradeDelayTooShort();
    error UpgradeFailed();
    error UpgradeMustGoThroughExecuteUpgrade();
    error UpgradeTimeMustRespectDelay(uint256 earliestTime);
    error UpgradeTooEarly(uint256 upgradeTime);
    error ZeroAddress();
    error ZeroAmount();
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "error",
    "name": "AlreadyFulfilled",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BLSSignatureVerificationFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "DestinationChainIdNotSupported",
    "inputs": [
      {
        "name": "dstChainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "FeeBpsExceedsThreshold",
    "inputs": [
      {
        "name": "maxFeeBps",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "FeeTooLow",
    "inputs": []
  },
  {
    "type": "error",
    "name": "GasForCallExactCheckAlreadySet",
    "inputs": []
  },
  {
    "type": "error",
    "name": "GrantRoleFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "HookExecutorNotSet",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientVerificationFeeBalance",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidFeeBps",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidTokenOrRecipient",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NewFeeTooLow",
    "inputs": [
      {
        "name": "newFee",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "currentFee",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NoUpgradePending",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SameVersionUpgradeNotAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SourceChainIdMismatch",
    "inputs": [
      {
        "name": "swapRequestParamsSrcChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "contractChainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "SourceChainIdShouldBeDifferentFromDestination",
    "inputs": [
      {
        "name": "srcChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "dstChainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "SwapRequestCancellationAlreadyStaged",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SwapRequestCancellationNotStaged",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SwapRequestCancellationWindowNotPassed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SwapRequestCancellationWindowTooShort",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SwapRequestParametersMismatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TokenMappingAlreadyExists",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TokenNotSupported",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TooLateToCancelUpgrade",
    "inputs": [
      {
        "name": "upgradeTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnauthorisedCaller",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UpgradeDelayTooShort",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UpgradeFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UpgradeMustGoThroughExecuteUpgrade",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UpgradeTimeMustRespectDelay",
    "inputs": [
      {
        "name": "earliestTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "UpgradeTooEarly",
    "inputs": [
      {
        "name": "upgradeTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod ErrorsLib {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080806040523460175760039081601c823930815050f35b5f80fdfe5f80fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R4`\x17W`\x03\x90\x81`\x1C\x8290\x81PP\xF3[_\x80\xFD\xFE_\x80\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x5f80fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"_\x80\xFD",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyFulfilled()` and selector `0x4a4117f9`.
```solidity
error AlreadyFulfilled();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyFulfilled;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyFulfilled> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyFulfilled) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyFulfilled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyFulfilled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyFulfilled()";
            const SELECTOR: [u8; 4] = [74u8, 65u8, 23u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BLSSignatureVerificationFailed()` and selector `0xd24bb4ea`.
```solidity
error BLSSignatureVerificationFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLSSignatureVerificationFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BLSSignatureVerificationFailed>
        for UnderlyingRustTuple<'_> {
            fn from(value: BLSSignatureVerificationFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for BLSSignatureVerificationFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BLSSignatureVerificationFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BLSSignatureVerificationFailed()";
            const SELECTOR: [u8; 4] = [210u8, 75u8, 180u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DestinationChainIdNotSupported(uint256)` and selector `0x7c61178e`.
```solidity
error DestinationChainIdNotSupported(uint256 dstChainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DestinationChainIdNotSupported {
        #[allow(missing_docs)]
        pub dstChainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DestinationChainIdNotSupported>
        for UnderlyingRustTuple<'_> {
            fn from(value: DestinationChainIdNotSupported) -> Self {
                (value.dstChainId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for DestinationChainIdNotSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { dstChainId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DestinationChainIdNotSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DestinationChainIdNotSupported(uint256)";
            const SELECTOR: [u8; 4] = [124u8, 97u8, 23u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dstChainId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FeeBpsExceedsThreshold(uint256)` and selector `0x48e4389e`.
```solidity
error FeeBpsExceedsThreshold(uint256 maxFeeBps);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FeeBpsExceedsThreshold {
        #[allow(missing_docs)]
        pub maxFeeBps: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FeeBpsExceedsThreshold> for UnderlyingRustTuple<'_> {
            fn from(value: FeeBpsExceedsThreshold) -> Self {
                (value.maxFeeBps,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FeeBpsExceedsThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { maxFeeBps: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FeeBpsExceedsThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FeeBpsExceedsThreshold(uint256)";
            const SELECTOR: [u8; 4] = [72u8, 228u8, 56u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeeBps),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FeeTooLow()` and selector `0x732f9413`.
```solidity
error FeeTooLow();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FeeTooLow;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FeeTooLow> for UnderlyingRustTuple<'_> {
            fn from(value: FeeTooLow) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FeeTooLow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FeeTooLow {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FeeTooLow()";
            const SELECTOR: [u8; 4] = [115u8, 47u8, 148u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `GasForCallExactCheckAlreadySet()` and selector `0x9145681a`.
```solidity
error GasForCallExactCheckAlreadySet();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GasForCallExactCheckAlreadySet;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GasForCallExactCheckAlreadySet>
        for UnderlyingRustTuple<'_> {
            fn from(value: GasForCallExactCheckAlreadySet) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for GasForCallExactCheckAlreadySet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GasForCallExactCheckAlreadySet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GasForCallExactCheckAlreadySet()";
            const SELECTOR: [u8; 4] = [145u8, 69u8, 104u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `GrantRoleFailed()` and selector `0x589efb50`.
```solidity
error GrantRoleFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GrantRoleFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GrantRoleFailed> for UnderlyingRustTuple<'_> {
            fn from(value: GrantRoleFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GrantRoleFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GrantRoleFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GrantRoleFailed()";
            const SELECTOR: [u8; 4] = [88u8, 158u8, 251u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `HookExecutorNotSet()` and selector `0x716dae54`.
```solidity
error HookExecutorNotSet();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HookExecutorNotSet;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HookExecutorNotSet> for UnderlyingRustTuple<'_> {
            fn from(value: HookExecutorNotSet) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for HookExecutorNotSet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HookExecutorNotSet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HookExecutorNotSet()";
            const SELECTOR: [u8; 4] = [113u8, 109u8, 174u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientVerificationFeeBalance()` and selector `0xd0fcc851`.
```solidity
error InsufficientVerificationFeeBalance();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientVerificationFeeBalance;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientVerificationFeeBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientVerificationFeeBalance) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientVerificationFeeBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientVerificationFeeBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientVerificationFeeBalance()";
            const SELECTOR: [u8; 4] = [208u8, 252u8, 200u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidFeeBps()` and selector `0x8bff87cf`.
```solidity
error InvalidFeeBps();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidFeeBps;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidFeeBps> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidFeeBps) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidFeeBps {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidFeeBps {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidFeeBps()";
            const SELECTOR: [u8; 4] = [139u8, 255u8, 135u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidTokenOrRecipient()` and selector `0x295ba290`.
```solidity
error InvalidTokenOrRecipient();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidTokenOrRecipient;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidTokenOrRecipient> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidTokenOrRecipient) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidTokenOrRecipient {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidTokenOrRecipient {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidTokenOrRecipient()";
            const SELECTOR: [u8; 4] = [41u8, 91u8, 162u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NewFeeTooLow(uint256,uint256)` and selector `0x1b97bd2a`.
```solidity
error NewFeeTooLow(uint256 newFee, uint256 currentFee);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NewFeeTooLow {
        #[allow(missing_docs)]
        pub newFee: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub currentFee: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NewFeeTooLow> for UnderlyingRustTuple<'_> {
            fn from(value: NewFeeTooLow) -> Self {
                (value.newFee, value.currentFee)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NewFeeTooLow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    newFee: tuple.0,
                    currentFee: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NewFeeTooLow {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NewFeeTooLow(uint256,uint256)";
            const SELECTOR: [u8; 4] = [27u8, 151u8, 189u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newFee),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentFee),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoUpgradePending()` and selector `0x52c650f9`.
```solidity
error NoUpgradePending();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoUpgradePending;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoUpgradePending> for UnderlyingRustTuple<'_> {
            fn from(value: NoUpgradePending) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoUpgradePending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoUpgradePending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoUpgradePending()";
            const SELECTOR: [u8; 4] = [82u8, 198u8, 80u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SameVersionUpgradeNotAllowed()` and selector `0x157224fe`.
```solidity
error SameVersionUpgradeNotAllowed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SameVersionUpgradeNotAllowed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SameVersionUpgradeNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: SameVersionUpgradeNotAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SameVersionUpgradeNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SameVersionUpgradeNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SameVersionUpgradeNotAllowed()";
            const SELECTOR: [u8; 4] = [21u8, 114u8, 36u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SourceChainIdMismatch(uint256,uint256)` and selector `0x744a1481`.
```solidity
error SourceChainIdMismatch(uint256 swapRequestParamsSrcChainId, uint256 contractChainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SourceChainIdMismatch {
        #[allow(missing_docs)]
        pub swapRequestParamsSrcChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub contractChainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SourceChainIdMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: SourceChainIdMismatch) -> Self {
                (value.swapRequestParamsSrcChainId, value.contractChainId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SourceChainIdMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    swapRequestParamsSrcChainId: tuple.0,
                    contractChainId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SourceChainIdMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SourceChainIdMismatch(uint256,uint256)";
            const SELECTOR: [u8; 4] = [116u8, 74u8, 20u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.swapRequestParamsSrcChainId,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contractChainId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SourceChainIdShouldBeDifferentFromDestination(uint256,uint256)` and selector `0x9c8d8d09`.
```solidity
error SourceChainIdShouldBeDifferentFromDestination(uint256 srcChainId, uint256 dstChainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SourceChainIdShouldBeDifferentFromDestination {
        #[allow(missing_docs)]
        pub srcChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dstChainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SourceChainIdShouldBeDifferentFromDestination>
        for UnderlyingRustTuple<'_> {
            fn from(value: SourceChainIdShouldBeDifferentFromDestination) -> Self {
                (value.srcChainId, value.dstChainId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SourceChainIdShouldBeDifferentFromDestination {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    srcChainId: tuple.0,
                    dstChainId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError
        for SourceChainIdShouldBeDifferentFromDestination {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SourceChainIdShouldBeDifferentFromDestination(uint256,uint256)";
            const SELECTOR: [u8; 4] = [156u8, 141u8, 141u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.srcChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dstChainId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SwapRequestCancellationAlreadyStaged()` and selector `0x08c62bab`.
```solidity
error SwapRequestCancellationAlreadyStaged();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SwapRequestCancellationAlreadyStaged;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapRequestCancellationAlreadyStaged>
        for UnderlyingRustTuple<'_> {
            fn from(value: SwapRequestCancellationAlreadyStaged) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SwapRequestCancellationAlreadyStaged {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SwapRequestCancellationAlreadyStaged {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SwapRequestCancellationAlreadyStaged()";
            const SELECTOR: [u8; 4] = [8u8, 198u8, 43u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SwapRequestCancellationNotStaged()` and selector `0x160d218e`.
```solidity
error SwapRequestCancellationNotStaged();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SwapRequestCancellationNotStaged;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapRequestCancellationNotStaged>
        for UnderlyingRustTuple<'_> {
            fn from(value: SwapRequestCancellationNotStaged) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SwapRequestCancellationNotStaged {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SwapRequestCancellationNotStaged {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SwapRequestCancellationNotStaged()";
            const SELECTOR: [u8; 4] = [22u8, 13u8, 33u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SwapRequestCancellationWindowNotPassed()` and selector `0x22341892`.
```solidity
error SwapRequestCancellationWindowNotPassed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SwapRequestCancellationWindowNotPassed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapRequestCancellationWindowNotPassed>
        for UnderlyingRustTuple<'_> {
            fn from(value: SwapRequestCancellationWindowNotPassed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SwapRequestCancellationWindowNotPassed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SwapRequestCancellationWindowNotPassed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SwapRequestCancellationWindowNotPassed()";
            const SELECTOR: [u8; 4] = [34u8, 52u8, 24u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SwapRequestCancellationWindowTooShort()` and selector `0xe119bcf1`.
```solidity
error SwapRequestCancellationWindowTooShort();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SwapRequestCancellationWindowTooShort;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapRequestCancellationWindowTooShort>
        for UnderlyingRustTuple<'_> {
            fn from(value: SwapRequestCancellationWindowTooShort) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SwapRequestCancellationWindowTooShort {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SwapRequestCancellationWindowTooShort {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SwapRequestCancellationWindowTooShort()";
            const SELECTOR: [u8; 4] = [225u8, 25u8, 188u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SwapRequestParametersMismatch()` and selector `0xc4fec7e0`.
```solidity
error SwapRequestParametersMismatch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SwapRequestParametersMismatch;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapRequestParametersMismatch>
        for UnderlyingRustTuple<'_> {
            fn from(value: SwapRequestParametersMismatch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SwapRequestParametersMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SwapRequestParametersMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SwapRequestParametersMismatch()";
            const SELECTOR: [u8; 4] = [196u8, 254u8, 199u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TokenMappingAlreadyExists()` and selector `0x800ef11e`.
```solidity
error TokenMappingAlreadyExists();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TokenMappingAlreadyExists;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TokenMappingAlreadyExists>
        for UnderlyingRustTuple<'_> {
            fn from(value: TokenMappingAlreadyExists) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for TokenMappingAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TokenMappingAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TokenMappingAlreadyExists()";
            const SELECTOR: [u8; 4] = [128u8, 14u8, 241u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TokenNotSupported()` and selector `0x3dd1b305`.
```solidity
error TokenNotSupported();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TokenNotSupported;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TokenNotSupported> for UnderlyingRustTuple<'_> {
            fn from(value: TokenNotSupported) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TokenNotSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TokenNotSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TokenNotSupported()";
            const SELECTOR: [u8; 4] = [61u8, 209u8, 179u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TooLateToCancelUpgrade(uint256)` and selector `0xb19fe458`.
```solidity
error TooLateToCancelUpgrade(uint256 upgradeTime);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TooLateToCancelUpgrade {
        #[allow(missing_docs)]
        pub upgradeTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TooLateToCancelUpgrade> for UnderlyingRustTuple<'_> {
            fn from(value: TooLateToCancelUpgrade) -> Self {
                (value.upgradeTime,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TooLateToCancelUpgrade {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { upgradeTime: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TooLateToCancelUpgrade {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TooLateToCancelUpgrade(uint256)";
            const SELECTOR: [u8; 4] = [177u8, 159u8, 228u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.upgradeTime),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnauthorisedCaller()` and selector `0x02cda8fe`.
```solidity
error UnauthorisedCaller();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnauthorisedCaller;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorisedCaller> for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorisedCaller) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnauthorisedCaller {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorisedCaller {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorisedCaller()";
            const SELECTOR: [u8; 4] = [2u8, 205u8, 168u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UpgradeDelayTooShort()` and selector `0x65e1b9dc`.
```solidity
error UpgradeDelayTooShort();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UpgradeDelayTooShort;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UpgradeDelayTooShort> for UnderlyingRustTuple<'_> {
            fn from(value: UpgradeDelayTooShort) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UpgradeDelayTooShort {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UpgradeDelayTooShort {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UpgradeDelayTooShort()";
            const SELECTOR: [u8; 4] = [101u8, 225u8, 185u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UpgradeFailed()` and selector `0x55299b49`.
```solidity
error UpgradeFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UpgradeFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UpgradeFailed> for UnderlyingRustTuple<'_> {
            fn from(value: UpgradeFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UpgradeFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UpgradeFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UpgradeFailed()";
            const SELECTOR: [u8; 4] = [85u8, 41u8, 155u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UpgradeMustGoThroughExecuteUpgrade()` and selector `0x5cb4a606`.
```solidity
error UpgradeMustGoThroughExecuteUpgrade();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UpgradeMustGoThroughExecuteUpgrade;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UpgradeMustGoThroughExecuteUpgrade>
        for UnderlyingRustTuple<'_> {
            fn from(value: UpgradeMustGoThroughExecuteUpgrade) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UpgradeMustGoThroughExecuteUpgrade {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UpgradeMustGoThroughExecuteUpgrade {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UpgradeMustGoThroughExecuteUpgrade()";
            const SELECTOR: [u8; 4] = [92u8, 180u8, 166u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UpgradeTimeMustRespectDelay(uint256)` and selector `0x0cd4e2d6`.
```solidity
error UpgradeTimeMustRespectDelay(uint256 earliestTime);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UpgradeTimeMustRespectDelay {
        #[allow(missing_docs)]
        pub earliestTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UpgradeTimeMustRespectDelay>
        for UnderlyingRustTuple<'_> {
            fn from(value: UpgradeTimeMustRespectDelay) -> Self {
                (value.earliestTime,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UpgradeTimeMustRespectDelay {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { earliestTime: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UpgradeTimeMustRespectDelay {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UpgradeTimeMustRespectDelay(uint256)";
            const SELECTOR: [u8; 4] = [12u8, 212u8, 226u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.earliestTime),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UpgradeTooEarly(uint256)` and selector `0x61813b80`.
```solidity
error UpgradeTooEarly(uint256 upgradeTime);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UpgradeTooEarly {
        #[allow(missing_docs)]
        pub upgradeTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UpgradeTooEarly> for UnderlyingRustTuple<'_> {
            fn from(value: UpgradeTooEarly) -> Self {
                (value.upgradeTime,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UpgradeTooEarly {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { upgradeTime: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UpgradeTooEarly {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UpgradeTooEarly(uint256)";
            const SELECTOR: [u8; 4] = [97u8, 129u8, 59u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.upgradeTime),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    ///Container for all the [`ErrorsLib`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum ErrorsLibErrors {
        #[allow(missing_docs)]
        AlreadyFulfilled(AlreadyFulfilled),
        #[allow(missing_docs)]
        BLSSignatureVerificationFailed(BLSSignatureVerificationFailed),
        #[allow(missing_docs)]
        DestinationChainIdNotSupported(DestinationChainIdNotSupported),
        #[allow(missing_docs)]
        FeeBpsExceedsThreshold(FeeBpsExceedsThreshold),
        #[allow(missing_docs)]
        FeeTooLow(FeeTooLow),
        #[allow(missing_docs)]
        GasForCallExactCheckAlreadySet(GasForCallExactCheckAlreadySet),
        #[allow(missing_docs)]
        GrantRoleFailed(GrantRoleFailed),
        #[allow(missing_docs)]
        HookExecutorNotSet(HookExecutorNotSet),
        #[allow(missing_docs)]
        InsufficientVerificationFeeBalance(InsufficientVerificationFeeBalance),
        #[allow(missing_docs)]
        InvalidFeeBps(InvalidFeeBps),
        #[allow(missing_docs)]
        InvalidTokenOrRecipient(InvalidTokenOrRecipient),
        #[allow(missing_docs)]
        NewFeeTooLow(NewFeeTooLow),
        #[allow(missing_docs)]
        NoUpgradePending(NoUpgradePending),
        #[allow(missing_docs)]
        SameVersionUpgradeNotAllowed(SameVersionUpgradeNotAllowed),
        #[allow(missing_docs)]
        SourceChainIdMismatch(SourceChainIdMismatch),
        #[allow(missing_docs)]
        SourceChainIdShouldBeDifferentFromDestination(
            SourceChainIdShouldBeDifferentFromDestination,
        ),
        #[allow(missing_docs)]
        SwapRequestCancellationAlreadyStaged(SwapRequestCancellationAlreadyStaged),
        #[allow(missing_docs)]
        SwapRequestCancellationNotStaged(SwapRequestCancellationNotStaged),
        #[allow(missing_docs)]
        SwapRequestCancellationWindowNotPassed(SwapRequestCancellationWindowNotPassed),
        #[allow(missing_docs)]
        SwapRequestCancellationWindowTooShort(SwapRequestCancellationWindowTooShort),
        #[allow(missing_docs)]
        SwapRequestParametersMismatch(SwapRequestParametersMismatch),
        #[allow(missing_docs)]
        TokenMappingAlreadyExists(TokenMappingAlreadyExists),
        #[allow(missing_docs)]
        TokenNotSupported(TokenNotSupported),
        #[allow(missing_docs)]
        TooLateToCancelUpgrade(TooLateToCancelUpgrade),
        #[allow(missing_docs)]
        UnauthorisedCaller(UnauthorisedCaller),
        #[allow(missing_docs)]
        UpgradeDelayTooShort(UpgradeDelayTooShort),
        #[allow(missing_docs)]
        UpgradeFailed(UpgradeFailed),
        #[allow(missing_docs)]
        UpgradeMustGoThroughExecuteUpgrade(UpgradeMustGoThroughExecuteUpgrade),
        #[allow(missing_docs)]
        UpgradeTimeMustRespectDelay(UpgradeTimeMustRespectDelay),
        #[allow(missing_docs)]
        UpgradeTooEarly(UpgradeTooEarly),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    impl ErrorsLibErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 205u8, 168u8, 254u8],
            [8u8, 198u8, 43u8, 171u8],
            [12u8, 212u8, 226u8, 214u8],
            [21u8, 114u8, 36u8, 254u8],
            [22u8, 13u8, 33u8, 142u8],
            [27u8, 151u8, 189u8, 42u8],
            [31u8, 42u8, 32u8, 5u8],
            [34u8, 52u8, 24u8, 146u8],
            [41u8, 91u8, 162u8, 144u8],
            [61u8, 209u8, 179u8, 5u8],
            [72u8, 228u8, 56u8, 158u8],
            [74u8, 65u8, 23u8, 249u8],
            [82u8, 198u8, 80u8, 249u8],
            [85u8, 41u8, 155u8, 73u8],
            [88u8, 158u8, 251u8, 80u8],
            [92u8, 180u8, 166u8, 6u8],
            [97u8, 129u8, 59u8, 128u8],
            [101u8, 225u8, 185u8, 220u8],
            [113u8, 109u8, 174u8, 84u8],
            [115u8, 47u8, 148u8, 19u8],
            [116u8, 74u8, 20u8, 129u8],
            [124u8, 97u8, 23u8, 142u8],
            [128u8, 14u8, 241u8, 30u8],
            [139u8, 255u8, 135u8, 207u8],
            [145u8, 69u8, 104u8, 26u8],
            [156u8, 141u8, 141u8, 9u8],
            [177u8, 159u8, 228u8, 88u8],
            [196u8, 254u8, 199u8, 224u8],
            [208u8, 252u8, 200u8, 81u8],
            [210u8, 75u8, 180u8, 234u8],
            [217u8, 46u8, 35u8, 61u8],
            [225u8, 25u8, 188u8, 241u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(UnauthorisedCaller),
            ::core::stringify!(SwapRequestCancellationAlreadyStaged),
            ::core::stringify!(UpgradeTimeMustRespectDelay),
            ::core::stringify!(SameVersionUpgradeNotAllowed),
            ::core::stringify!(SwapRequestCancellationNotStaged),
            ::core::stringify!(NewFeeTooLow),
            ::core::stringify!(ZeroAmount),
            ::core::stringify!(SwapRequestCancellationWindowNotPassed),
            ::core::stringify!(InvalidTokenOrRecipient),
            ::core::stringify!(TokenNotSupported),
            ::core::stringify!(FeeBpsExceedsThreshold),
            ::core::stringify!(AlreadyFulfilled),
            ::core::stringify!(NoUpgradePending),
            ::core::stringify!(UpgradeFailed),
            ::core::stringify!(GrantRoleFailed),
            ::core::stringify!(UpgradeMustGoThroughExecuteUpgrade),
            ::core::stringify!(UpgradeTooEarly),
            ::core::stringify!(UpgradeDelayTooShort),
            ::core::stringify!(HookExecutorNotSet),
            ::core::stringify!(FeeTooLow),
            ::core::stringify!(SourceChainIdMismatch),
            ::core::stringify!(DestinationChainIdNotSupported),
            ::core::stringify!(TokenMappingAlreadyExists),
            ::core::stringify!(InvalidFeeBps),
            ::core::stringify!(GasForCallExactCheckAlreadySet),
            ::core::stringify!(SourceChainIdShouldBeDifferentFromDestination),
            ::core::stringify!(TooLateToCancelUpgrade),
            ::core::stringify!(SwapRequestParametersMismatch),
            ::core::stringify!(InsufficientVerificationFeeBalance),
            ::core::stringify!(BLSSignatureVerificationFailed),
            ::core::stringify!(ZeroAddress),
            ::core::stringify!(SwapRequestCancellationWindowTooShort),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <UnauthorisedCaller as alloy_sol_types::SolError>::SIGNATURE,
            <SwapRequestCancellationAlreadyStaged as alloy_sol_types::SolError>::SIGNATURE,
            <UpgradeTimeMustRespectDelay as alloy_sol_types::SolError>::SIGNATURE,
            <SameVersionUpgradeNotAllowed as alloy_sol_types::SolError>::SIGNATURE,
            <SwapRequestCancellationNotStaged as alloy_sol_types::SolError>::SIGNATURE,
            <NewFeeTooLow as alloy_sol_types::SolError>::SIGNATURE,
            <ZeroAmount as alloy_sol_types::SolError>::SIGNATURE,
            <SwapRequestCancellationWindowNotPassed as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidTokenOrRecipient as alloy_sol_types::SolError>::SIGNATURE,
            <TokenNotSupported as alloy_sol_types::SolError>::SIGNATURE,
            <FeeBpsExceedsThreshold as alloy_sol_types::SolError>::SIGNATURE,
            <AlreadyFulfilled as alloy_sol_types::SolError>::SIGNATURE,
            <NoUpgradePending as alloy_sol_types::SolError>::SIGNATURE,
            <UpgradeFailed as alloy_sol_types::SolError>::SIGNATURE,
            <GrantRoleFailed as alloy_sol_types::SolError>::SIGNATURE,
            <UpgradeMustGoThroughExecuteUpgrade as alloy_sol_types::SolError>::SIGNATURE,
            <UpgradeTooEarly as alloy_sol_types::SolError>::SIGNATURE,
            <UpgradeDelayTooShort as alloy_sol_types::SolError>::SIGNATURE,
            <HookExecutorNotSet as alloy_sol_types::SolError>::SIGNATURE,
            <FeeTooLow as alloy_sol_types::SolError>::SIGNATURE,
            <SourceChainIdMismatch as alloy_sol_types::SolError>::SIGNATURE,
            <DestinationChainIdNotSupported as alloy_sol_types::SolError>::SIGNATURE,
            <TokenMappingAlreadyExists as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidFeeBps as alloy_sol_types::SolError>::SIGNATURE,
            <GasForCallExactCheckAlreadySet as alloy_sol_types::SolError>::SIGNATURE,
            <SourceChainIdShouldBeDifferentFromDestination as alloy_sol_types::SolError>::SIGNATURE,
            <TooLateToCancelUpgrade as alloy_sol_types::SolError>::SIGNATURE,
            <SwapRequestParametersMismatch as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientVerificationFeeBalance as alloy_sol_types::SolError>::SIGNATURE,
            <BLSSignatureVerificationFailed as alloy_sol_types::SolError>::SIGNATURE,
            <ZeroAddress as alloy_sol_types::SolError>::SIGNATURE,
            <SwapRequestCancellationWindowTooShort as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ErrorsLibErrors {
        const NAME: &'static str = "ErrorsLibErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 32usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyFulfilled(_) => {
                    <AlreadyFulfilled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BLSSignatureVerificationFailed(_) => {
                    <BLSSignatureVerificationFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DestinationChainIdNotSupported(_) => {
                    <DestinationChainIdNotSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FeeBpsExceedsThreshold(_) => {
                    <FeeBpsExceedsThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FeeTooLow(_) => <FeeTooLow as alloy_sol_types::SolError>::SELECTOR,
                Self::GasForCallExactCheckAlreadySet(_) => {
                    <GasForCallExactCheckAlreadySet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GrantRoleFailed(_) => {
                    <GrantRoleFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HookExecutorNotSet(_) => {
                    <HookExecutorNotSet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientVerificationFeeBalance(_) => {
                    <InsufficientVerificationFeeBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidFeeBps(_) => {
                    <InvalidFeeBps as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidTokenOrRecipient(_) => {
                    <InvalidTokenOrRecipient as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NewFeeTooLow(_) => {
                    <NewFeeTooLow as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoUpgradePending(_) => {
                    <NoUpgradePending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SameVersionUpgradeNotAllowed(_) => {
                    <SameVersionUpgradeNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SourceChainIdMismatch(_) => {
                    <SourceChainIdMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SourceChainIdShouldBeDifferentFromDestination(_) => {
                    <SourceChainIdShouldBeDifferentFromDestination as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SwapRequestCancellationAlreadyStaged(_) => {
                    <SwapRequestCancellationAlreadyStaged as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SwapRequestCancellationNotStaged(_) => {
                    <SwapRequestCancellationNotStaged as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SwapRequestCancellationWindowNotPassed(_) => {
                    <SwapRequestCancellationWindowNotPassed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SwapRequestCancellationWindowTooShort(_) => {
                    <SwapRequestCancellationWindowTooShort as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SwapRequestParametersMismatch(_) => {
                    <SwapRequestParametersMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TokenMappingAlreadyExists(_) => {
                    <TokenMappingAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TokenNotSupported(_) => {
                    <TokenNotSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TooLateToCancelUpgrade(_) => {
                    <TooLateToCancelUpgrade as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorisedCaller(_) => {
                    <UnauthorisedCaller as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UpgradeDelayTooShort(_) => {
                    <UpgradeDelayTooShort as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UpgradeFailed(_) => {
                    <UpgradeFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UpgradeMustGoThroughExecuteUpgrade(_) => {
                    <UpgradeMustGoThroughExecuteUpgrade as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UpgradeTimeMustRespectDelay(_) => {
                    <UpgradeTimeMustRespectDelay as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UpgradeTooEarly(_) => {
                    <UpgradeTooEarly as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<ErrorsLibErrors>] = &[
                {
                    fn UnauthorisedCaller(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UnauthorisedCaller as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::UnauthorisedCaller)
                    }
                    UnauthorisedCaller
                },
                {
                    fn SwapRequestCancellationAlreadyStaged(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestCancellationAlreadyStaged as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestCancellationAlreadyStaged)
                    }
                    SwapRequestCancellationAlreadyStaged
                },
                {
                    fn UpgradeTimeMustRespectDelay(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeTimeMustRespectDelay as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeTimeMustRespectDelay)
                    }
                    UpgradeTimeMustRespectDelay
                },
                {
                    fn SameVersionUpgradeNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SameVersionUpgradeNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::SameVersionUpgradeNotAllowed)
                    }
                    SameVersionUpgradeNotAllowed
                },
                {
                    fn SwapRequestCancellationNotStaged(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestCancellationNotStaged as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestCancellationNotStaged)
                    }
                    SwapRequestCancellationNotStaged
                },
                {
                    fn NewFeeTooLow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <NewFeeTooLow as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(ErrorsLibErrors::NewFeeTooLow)
                    }
                    NewFeeTooLow
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(ErrorsLibErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn SwapRequestCancellationWindowNotPassed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestCancellationWindowNotPassed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestCancellationWindowNotPassed)
                    }
                    SwapRequestCancellationWindowNotPassed
                },
                {
                    fn InvalidTokenOrRecipient(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <InvalidTokenOrRecipient as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::InvalidTokenOrRecipient)
                    }
                    InvalidTokenOrRecipient
                },
                {
                    fn TokenNotSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <TokenNotSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::TokenNotSupported)
                    }
                    TokenNotSupported
                },
                {
                    fn FeeBpsExceedsThreshold(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <FeeBpsExceedsThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::FeeBpsExceedsThreshold)
                    }
                    FeeBpsExceedsThreshold
                },
                {
                    fn AlreadyFulfilled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <AlreadyFulfilled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::AlreadyFulfilled)
                    }
                    AlreadyFulfilled
                },
                {
                    fn NoUpgradePending(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <NoUpgradePending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::NoUpgradePending)
                    }
                    NoUpgradePending
                },
                {
                    fn UpgradeFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeFailed)
                    }
                    UpgradeFailed
                },
                {
                    fn GrantRoleFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <GrantRoleFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::GrantRoleFailed)
                    }
                    GrantRoleFailed
                },
                {
                    fn UpgradeMustGoThroughExecuteUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeMustGoThroughExecuteUpgrade as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeMustGoThroughExecuteUpgrade)
                    }
                    UpgradeMustGoThroughExecuteUpgrade
                },
                {
                    fn UpgradeTooEarly(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeTooEarly as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeTooEarly)
                    }
                    UpgradeTooEarly
                },
                {
                    fn UpgradeDelayTooShort(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeDelayTooShort as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeDelayTooShort)
                    }
                    UpgradeDelayTooShort
                },
                {
                    fn HookExecutorNotSet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <HookExecutorNotSet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::HookExecutorNotSet)
                    }
                    HookExecutorNotSet
                },
                {
                    fn FeeTooLow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <FeeTooLow as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(ErrorsLibErrors::FeeTooLow)
                    }
                    FeeTooLow
                },
                {
                    fn SourceChainIdMismatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SourceChainIdMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::SourceChainIdMismatch)
                    }
                    SourceChainIdMismatch
                },
                {
                    fn DestinationChainIdNotSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <DestinationChainIdNotSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::DestinationChainIdNotSupported)
                    }
                    DestinationChainIdNotSupported
                },
                {
                    fn TokenMappingAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <TokenMappingAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::TokenMappingAlreadyExists)
                    }
                    TokenMappingAlreadyExists
                },
                {
                    fn InvalidFeeBps(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <InvalidFeeBps as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::InvalidFeeBps)
                    }
                    InvalidFeeBps
                },
                {
                    fn GasForCallExactCheckAlreadySet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <GasForCallExactCheckAlreadySet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::GasForCallExactCheckAlreadySet)
                    }
                    GasForCallExactCheckAlreadySet
                },
                {
                    fn SourceChainIdShouldBeDifferentFromDestination(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SourceChainIdShouldBeDifferentFromDestination as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                ErrorsLibErrors::SourceChainIdShouldBeDifferentFromDestination,
                            )
                    }
                    SourceChainIdShouldBeDifferentFromDestination
                },
                {
                    fn TooLateToCancelUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <TooLateToCancelUpgrade as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::TooLateToCancelUpgrade)
                    }
                    TooLateToCancelUpgrade
                },
                {
                    fn SwapRequestParametersMismatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestParametersMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestParametersMismatch)
                    }
                    SwapRequestParametersMismatch
                },
                {
                    fn InsufficientVerificationFeeBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <InsufficientVerificationFeeBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::InsufficientVerificationFeeBalance)
                    }
                    InsufficientVerificationFeeBalance
                },
                {
                    fn BLSSignatureVerificationFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <BLSSignatureVerificationFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::BLSSignatureVerificationFailed)
                    }
                    BLSSignatureVerificationFailed
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(ErrorsLibErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn SwapRequestCancellationWindowTooShort(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestCancellationWindowTooShort as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestCancellationWindowTooShort)
                    }
                    SwapRequestCancellationWindowTooShort
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<ErrorsLibErrors>] = &[
                {
                    fn UnauthorisedCaller(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UnauthorisedCaller as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::UnauthorisedCaller)
                    }
                    UnauthorisedCaller
                },
                {
                    fn SwapRequestCancellationAlreadyStaged(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestCancellationAlreadyStaged as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestCancellationAlreadyStaged)
                    }
                    SwapRequestCancellationAlreadyStaged
                },
                {
                    fn UpgradeTimeMustRespectDelay(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeTimeMustRespectDelay as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeTimeMustRespectDelay)
                    }
                    UpgradeTimeMustRespectDelay
                },
                {
                    fn SameVersionUpgradeNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SameVersionUpgradeNotAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::SameVersionUpgradeNotAllowed)
                    }
                    SameVersionUpgradeNotAllowed
                },
                {
                    fn SwapRequestCancellationNotStaged(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestCancellationNotStaged as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestCancellationNotStaged)
                    }
                    SwapRequestCancellationNotStaged
                },
                {
                    fn NewFeeTooLow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <NewFeeTooLow as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::NewFeeTooLow)
                    }
                    NewFeeTooLow
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn SwapRequestCancellationWindowNotPassed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestCancellationWindowNotPassed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestCancellationWindowNotPassed)
                    }
                    SwapRequestCancellationWindowNotPassed
                },
                {
                    fn InvalidTokenOrRecipient(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <InvalidTokenOrRecipient as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::InvalidTokenOrRecipient)
                    }
                    InvalidTokenOrRecipient
                },
                {
                    fn TokenNotSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <TokenNotSupported as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::TokenNotSupported)
                    }
                    TokenNotSupported
                },
                {
                    fn FeeBpsExceedsThreshold(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <FeeBpsExceedsThreshold as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::FeeBpsExceedsThreshold)
                    }
                    FeeBpsExceedsThreshold
                },
                {
                    fn AlreadyFulfilled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <AlreadyFulfilled as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::AlreadyFulfilled)
                    }
                    AlreadyFulfilled
                },
                {
                    fn NoUpgradePending(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <NoUpgradePending as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::NoUpgradePending)
                    }
                    NoUpgradePending
                },
                {
                    fn UpgradeFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeFailed)
                    }
                    UpgradeFailed
                },
                {
                    fn GrantRoleFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <GrantRoleFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::GrantRoleFailed)
                    }
                    GrantRoleFailed
                },
                {
                    fn UpgradeMustGoThroughExecuteUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeMustGoThroughExecuteUpgrade as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeMustGoThroughExecuteUpgrade)
                    }
                    UpgradeMustGoThroughExecuteUpgrade
                },
                {
                    fn UpgradeTooEarly(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeTooEarly as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeTooEarly)
                    }
                    UpgradeTooEarly
                },
                {
                    fn UpgradeDelayTooShort(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <UpgradeDelayTooShort as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::UpgradeDelayTooShort)
                    }
                    UpgradeDelayTooShort
                },
                {
                    fn HookExecutorNotSet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <HookExecutorNotSet as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::HookExecutorNotSet)
                    }
                    HookExecutorNotSet
                },
                {
                    fn FeeTooLow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <FeeTooLow as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::FeeTooLow)
                    }
                    FeeTooLow
                },
                {
                    fn SourceChainIdMismatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SourceChainIdMismatch as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::SourceChainIdMismatch)
                    }
                    SourceChainIdMismatch
                },
                {
                    fn DestinationChainIdNotSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <DestinationChainIdNotSupported as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::DestinationChainIdNotSupported)
                    }
                    DestinationChainIdNotSupported
                },
                {
                    fn TokenMappingAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <TokenMappingAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::TokenMappingAlreadyExists)
                    }
                    TokenMappingAlreadyExists
                },
                {
                    fn InvalidFeeBps(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <InvalidFeeBps as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::InvalidFeeBps)
                    }
                    InvalidFeeBps
                },
                {
                    fn GasForCallExactCheckAlreadySet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <GasForCallExactCheckAlreadySet as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::GasForCallExactCheckAlreadySet)
                    }
                    GasForCallExactCheckAlreadySet
                },
                {
                    fn SourceChainIdShouldBeDifferentFromDestination(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SourceChainIdShouldBeDifferentFromDestination as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                ErrorsLibErrors::SourceChainIdShouldBeDifferentFromDestination,
                            )
                    }
                    SourceChainIdShouldBeDifferentFromDestination
                },
                {
                    fn TooLateToCancelUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <TooLateToCancelUpgrade as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::TooLateToCancelUpgrade)
                    }
                    TooLateToCancelUpgrade
                },
                {
                    fn SwapRequestParametersMismatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestParametersMismatch as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestParametersMismatch)
                    }
                    SwapRequestParametersMismatch
                },
                {
                    fn InsufficientVerificationFeeBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <InsufficientVerificationFeeBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::InsufficientVerificationFeeBalance)
                    }
                    InsufficientVerificationFeeBalance
                },
                {
                    fn BLSSignatureVerificationFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <BLSSignatureVerificationFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::BLSSignatureVerificationFailed)
                    }
                    BLSSignatureVerificationFailed
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn SwapRequestCancellationWindowTooShort(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<ErrorsLibErrors> {
                        <SwapRequestCancellationWindowTooShort as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(ErrorsLibErrors::SwapRequestCancellationWindowTooShort)
                    }
                    SwapRequestCancellationWindowTooShort
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyFulfilled(inner) => {
                    <AlreadyFulfilled as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BLSSignatureVerificationFailed(inner) => {
                    <BLSSignatureVerificationFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DestinationChainIdNotSupported(inner) => {
                    <DestinationChainIdNotSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FeeBpsExceedsThreshold(inner) => {
                    <FeeBpsExceedsThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FeeTooLow(inner) => {
                    <FeeTooLow as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::GasForCallExactCheckAlreadySet(inner) => {
                    <GasForCallExactCheckAlreadySet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::GrantRoleFailed(inner) => {
                    <GrantRoleFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::HookExecutorNotSet(inner) => {
                    <HookExecutorNotSet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientVerificationFeeBalance(inner) => {
                    <InsufficientVerificationFeeBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidFeeBps(inner) => {
                    <InvalidFeeBps as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidTokenOrRecipient(inner) => {
                    <InvalidTokenOrRecipient as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NewFeeTooLow(inner) => {
                    <NewFeeTooLow as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NoUpgradePending(inner) => {
                    <NoUpgradePending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SameVersionUpgradeNotAllowed(inner) => {
                    <SameVersionUpgradeNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SourceChainIdMismatch(inner) => {
                    <SourceChainIdMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SourceChainIdShouldBeDifferentFromDestination(inner) => {
                    <SourceChainIdShouldBeDifferentFromDestination as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SwapRequestCancellationAlreadyStaged(inner) => {
                    <SwapRequestCancellationAlreadyStaged as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SwapRequestCancellationNotStaged(inner) => {
                    <SwapRequestCancellationNotStaged as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SwapRequestCancellationWindowNotPassed(inner) => {
                    <SwapRequestCancellationWindowNotPassed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SwapRequestCancellationWindowTooShort(inner) => {
                    <SwapRequestCancellationWindowTooShort as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SwapRequestParametersMismatch(inner) => {
                    <SwapRequestParametersMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TokenMappingAlreadyExists(inner) => {
                    <TokenMappingAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TokenNotSupported(inner) => {
                    <TokenNotSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TooLateToCancelUpgrade(inner) => {
                    <TooLateToCancelUpgrade as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnauthorisedCaller(inner) => {
                    <UnauthorisedCaller as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UpgradeDelayTooShort(inner) => {
                    <UpgradeDelayTooShort as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UpgradeFailed(inner) => {
                    <UpgradeFailed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::UpgradeMustGoThroughExecuteUpgrade(inner) => {
                    <UpgradeMustGoThroughExecuteUpgrade as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UpgradeTimeMustRespectDelay(inner) => {
                    <UpgradeTimeMustRespectDelay as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UpgradeTooEarly(inner) => {
                    <UpgradeTooEarly as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyFulfilled(inner) => {
                    <AlreadyFulfilled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BLSSignatureVerificationFailed(inner) => {
                    <BLSSignatureVerificationFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DestinationChainIdNotSupported(inner) => {
                    <DestinationChainIdNotSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FeeBpsExceedsThreshold(inner) => {
                    <FeeBpsExceedsThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FeeTooLow(inner) => {
                    <FeeTooLow as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::GasForCallExactCheckAlreadySet(inner) => {
                    <GasForCallExactCheckAlreadySet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GrantRoleFailed(inner) => {
                    <GrantRoleFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::HookExecutorNotSet(inner) => {
                    <HookExecutorNotSet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientVerificationFeeBalance(inner) => {
                    <InsufficientVerificationFeeBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidFeeBps(inner) => {
                    <InvalidFeeBps as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidTokenOrRecipient(inner) => {
                    <InvalidTokenOrRecipient as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NewFeeTooLow(inner) => {
                    <NewFeeTooLow as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoUpgradePending(inner) => {
                    <NoUpgradePending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SameVersionUpgradeNotAllowed(inner) => {
                    <SameVersionUpgradeNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SourceChainIdMismatch(inner) => {
                    <SourceChainIdMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SourceChainIdShouldBeDifferentFromDestination(inner) => {
                    <SourceChainIdShouldBeDifferentFromDestination as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SwapRequestCancellationAlreadyStaged(inner) => {
                    <SwapRequestCancellationAlreadyStaged as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SwapRequestCancellationNotStaged(inner) => {
                    <SwapRequestCancellationNotStaged as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SwapRequestCancellationWindowNotPassed(inner) => {
                    <SwapRequestCancellationWindowNotPassed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SwapRequestCancellationWindowTooShort(inner) => {
                    <SwapRequestCancellationWindowTooShort as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SwapRequestParametersMismatch(inner) => {
                    <SwapRequestParametersMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TokenMappingAlreadyExists(inner) => {
                    <TokenMappingAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TokenNotSupported(inner) => {
                    <TokenNotSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TooLateToCancelUpgrade(inner) => {
                    <TooLateToCancelUpgrade as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnauthorisedCaller(inner) => {
                    <UnauthorisedCaller as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UpgradeDelayTooShort(inner) => {
                    <UpgradeDelayTooShort as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UpgradeFailed(inner) => {
                    <UpgradeFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UpgradeMustGoThroughExecuteUpgrade(inner) => {
                    <UpgradeMustGoThroughExecuteUpgrade as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UpgradeTimeMustRespectDelay(inner) => {
                    <UpgradeTimeMustRespectDelay as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UpgradeTooEarly(inner) => {
                    <UpgradeTooEarly as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ErrorsLib`](self) contract instance.

See the [wrapper's documentation](`ErrorsLibInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> ErrorsLibInstance<P, N> {
        ErrorsLibInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ErrorsLibInstance<P, N>>,
    > {
        ErrorsLibInstance::<P, N>::deploy(__provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        ErrorsLibInstance::<P, N>::deploy_builder(__provider)
    }
    /**A [`ErrorsLib`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ErrorsLib`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ErrorsLibInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for ErrorsLibInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ErrorsLibInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > ErrorsLibInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`ErrorsLib`](self) contract instance.

See the [wrapper's documentation](`ErrorsLibInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
        ) -> alloy_contract::Result<ErrorsLibInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> ErrorsLibInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ErrorsLibInstance<P, N> {
            ErrorsLibInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > ErrorsLibInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > ErrorsLibInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
